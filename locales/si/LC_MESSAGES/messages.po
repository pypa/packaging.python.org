# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2013–2020, PyPA
# This file is distributed under the same license as the Python Packaging User Guide package.
# HelaBasa <R45XvezA@protonmail.ch>, 2021.
msgid ""
msgstr ""
"Project-Id-Version: Python Packaging User Guide\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-07-06 19:32+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Automatically generated\n"
"Language-Team: none\n"
"Language: si\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../source/contribute.rst:5
msgid "Contribute to this guide"
msgstr ""

#: ../source/contribute.rst:7
msgid "The |PyPUG| welcomes contributors! There are lots of ways to help out, including:"
msgstr ""

#: ../source/contribute.rst:10
msgid "Reading the guide and giving feedback"
msgstr ""

#: ../source/contribute.rst:11
msgid "Reviewing new contributions"
msgstr ""

#: ../source/contribute.rst:12
msgid "Revising existing content"
msgstr ""

#: ../source/contribute.rst:13
msgid "Writing new content"
msgstr ""

#: ../source/contribute.rst:15
msgid "Most of the work on the |PyPUG| takes place on the `project's GitHub repository`__. To get started, check out the list of `open issues`__ and `pull requests`__. If you're planning to write or edit the guide, please read the :ref:`style guide <contributing_style_guide>`."
msgstr ""

#: ../source/contribute.rst:24
msgid "By contributing to the |PyPUG|, you're expected to follow the PSF's `Code of Conduct`__."
msgstr ""

#: ../source/contribute.rst:31
msgid "Documentation types"
msgstr ""

#: ../source/contribute.rst:33
msgid "This project consists of four distinct documentation types with specific purposes. When proposing new additions to the project please pick the appropriate documentation type."
msgstr ""

#: ../source/contribute.rst:38
#: ../source/tutorials/index.rst:2
msgid "Tutorials"
msgstr ""

#: ../source/contribute.rst:40
msgid "Tutorials are focused on teaching the reader new concepts by accomplishing a goal. They are opinionated step-by-step guides. They do not include extraneous warnings or information. `example tutorial-style document`_."
msgstr ""

#: ../source/contribute.rst:47
#: ../source/guides/index.rst:2
msgid "Guides"
msgstr ""

#: ../source/contribute.rst:49
msgid "Guides are focused on accomplishing a specific task and can assume some level of pre-requisite knowledge. These are similar to tutorials, but have a narrow and clear focus and can provide lots of caveats and additional information as needed. They may also discuss multiple approaches to accomplishing the task. :doc:`example guide-style document <guides/packaging-namespace-packages>`."
msgstr ""

#: ../source/contribute.rst:56
#: ../source/discussions/index.rst:2
msgid "Discussions"
msgstr ""

#: ../source/contribute.rst:58
msgid "Discussions are focused on understanding and information. These explore a specific topic without a specific goal in mind. :doc:`example discussion-style document <discussions/install-requires-vs-requirements>`."
msgstr ""

#: ../source/contribute.rst:63
msgid "Specifications"
msgstr ""

#: ../source/contribute.rst:65
msgid "Specifications are reference documention focused on comprehensively documenting an agreed-upon interface for interoperability between packaging tools. :doc:`example specification-style document <specifications/core-metadata>`."
msgstr ""

#: ../source/contribute.rst:73
msgid "Building the guide locally"
msgstr ""

#: ../source/contribute.rst:75
msgid "Though not required to contribute, it may be useful to build this guide locally in order to test your changes. In order to build this guide locally, you'll need:"
msgstr ""

#: ../source/contribute.rst:79
msgid "`Nox <https://nox.readthedocs.io/en/latest/>`_. You can install or upgrade nox using ``pip``::"
msgstr ""

#: ../source/contribute.rst:84
msgid "Python 3.6. Our build scripts are designed to work with Python 3.6 only. See the `Hitchhiker's Guide to Python installation instructions`_ to install Python 3.6 on your operating system."
msgstr ""

#: ../source/contribute.rst:91
msgid "To build the guide, run the following bash command in the source folder::"
msgstr ""

#: ../source/contribute.rst:95
msgid "After the process has completed you can find the HTML output in the ``./build/html`` directory. You can open the ``index.html`` file to view the guide in web browser, but it's recommended to serve the guide using an HTTP server."
msgstr ""

#: ../source/contribute.rst:100
msgid "You can build the guide and serve it via an HTTP server using the following command::"
msgstr ""

#: ../source/contribute.rst:105
msgid "The guide will be browsable via http://localhost:8000."
msgstr ""

#: ../source/contribute.rst:109
msgid "Where the guide is deployed"
msgstr ""

#: ../source/contribute.rst:111
msgid "The guide is deployed via ReadTheDocs and the configuration lives at https://readthedocs.org/projects/python-packaging-user-guide/. It's served from a custom domain and fronted by Fast.ly."
msgstr ""

#: ../source/contribute.rst:117
msgid "Style guide"
msgstr ""

#: ../source/contribute.rst:119
msgid "This style guide has recommendations for how you should write the |PyPUG|. Before you start writing, please review it. By following the style guide, your contributions will help add to a cohesive whole and make it easier for your contributions to be accepted into the project."
msgstr ""

#: ../source/contribute.rst:126
msgid "Purpose"
msgstr ""

#: ../source/contribute.rst:128
msgid "The purpose of the |PyPUG| is to be the authoritative resource on how to package, publish, and install Python projects using current tools."
msgstr ""

#: ../source/contribute.rst:133
msgid "Scope"
msgstr ""

#: ../source/contribute.rst:135
msgid "The guide is meant to answer questions and solve problems with accurate and focused recommendations."
msgstr ""

#: ../source/contribute.rst:138
msgid "The guide isn't meant to be comprehensive and it's not meant to replace individual projects' documentation. For example, pip has dozens of commands, options, and settings. The pip documentation describes each of them in detail, while this guide describes only the parts of pip that are needed to complete the specific tasks described in this guide."
msgstr ""

#: ../source/contribute.rst:146
msgid "Audience"
msgstr ""

#: ../source/contribute.rst:148
msgid "The audience of this guide is anyone who uses Python with packages."
msgstr ""

#: ../source/contribute.rst:150
msgid "Don't forget that the Python community is big and welcoming. Readers may not share your age, gender, education, culture, and more, but they deserve to learn about packaging just as much as you do."
msgstr ""

#: ../source/contribute.rst:154
msgid "In particular, keep in mind that not all people who use Python see themselves as programmers. The audience of this guide includes astronomers or painters or students as well as professional software developers."
msgstr ""

#: ../source/contribute.rst:160
msgid "Voice and tone"
msgstr ""

#: ../source/contribute.rst:162
msgid "When writing this guide, strive to write with a voice that's approachable and humble, even if you have all the answers."
msgstr ""

#: ../source/contribute.rst:165
msgid "Imagine you're working on a Python project with someone you know to be smart and skilled. You like working with them and they like working with you. That person has asked you a question and you know the answer. How do you respond? *That* is how you should write this guide."
msgstr ""

#: ../source/contribute.rst:170
msgid "Here's a quick check: try reading aloud to get a sense for your writing's voice and tone. Does it sound like something you would say or does it sound like you're acting out a part or giving a speech? Feel free to use contractions and don't worry about sticking to fussy grammar rules. You are hereby granted permission to end a sentence in a preposition, if that's what you want to end it with."
msgstr ""

#: ../source/contribute.rst:177
msgid "When writing the guide, adjust your tone for the seriousness and difficulty of the topic. If you're writing an introductory tutorial, it's OK to make a joke, but if you're covering a sensitive security recommendation, you might want to avoid jokes altogether."
msgstr ""

#: ../source/contribute.rst:184
msgid "Conventions and mechanics"
msgstr ""

#: ../source/contribute.rst:192
msgid "**Write to the reader**"
msgstr ""

#: ../source/contribute.rst:187
msgid "When giving recommendations or steps to take, address the reader as *you* or use the imperative mood."
msgstr ""

#: ../source/contribute.rst:0
msgid "Wrong: To install it, the user runs…"
msgstr ""

#: ../source/contribute.rst:0
msgid "Right: You can install it by running…"
msgstr ""

#: ../source/contribute.rst:0
msgid "Right: To install it, run…"
msgstr ""

#: ../source/contribute.rst:198
msgid "**State assumptions**"
msgstr ""

#: ../source/contribute.rst:195
msgid "Avoid making unstated assumptions. Reading on the web means that any page of the guide may be the first page of the guide that the reader ever sees. If you're going to make assumptions, then say what assumptions that you're going to make."
msgstr ""

#: ../source/contribute.rst:203
msgid "**Cross-reference generously**"
msgstr ""

#: ../source/contribute.rst:201
msgid "The first time you mention a tool or practice, link to the part of the guide that covers it, or link to a relevant document elsewhere. Save the reader a search."
msgstr ""

#: ../source/contribute.rst:213
msgid "**Respect naming practices**"
msgstr ""

#: ../source/contribute.rst:206
msgid "When naming tools, sites, people, and other proper nouns, use their preferred capitalization."
msgstr ""

#: ../source/contribute.rst:0
msgid "Wrong: Pip uses…"
msgstr ""

#: ../source/contribute.rst:0
msgid "Right: pip uses…"
msgstr ""

#: ../source/contribute.rst:0
msgid "Wrong: …hosted on github."
msgstr ""

#: ../source/contribute.rst:0
msgid "Right: …hosted on GitHub."
msgstr ""

#: ../source/contribute.rst:222
msgid "**Use a gender-neutral style**"
msgstr ""

#: ../source/contribute.rst:216
msgid "Often, you'll address the reader directly with *you*, *your* and *yours*. Otherwise, use gender-neutral pronouns *they*, *their*, and *theirs* or avoid pronouns entirely."
msgstr ""

#: ../source/contribute.rst:0
msgid "Wrong: A maintainer uploads the file. Then he…"
msgstr ""

#: ../source/contribute.rst:0
msgid "Right: A maintainer uploads the file. Then they…"
msgstr ""

#: ../source/contribute.rst:0
msgid "Right: A maintainer uploads the file. Then the maintainer…"
msgstr ""

#: ../source/contribute.rst:234
msgid "**Headings**"
msgstr ""

#: ../source/contribute.rst:225
msgid "Write headings that use words the reader is searching for. A good way to do this is to have your heading complete an implied question. For example, a reader might want to know *How do I install MyLibrary?* so a good heading might be *Install MyLibrary*."
msgstr ""

#: ../source/contribute.rst:230
msgid "In section headings, use sentence case. In other words, write headings as you would write a typical sentence."
msgstr ""

#: ../source/contribute.rst:0
msgid "Wrong: Things You Should Know About Python"
msgstr ""

#: ../source/contribute.rst:0
msgid "Right: Things you should know about Python"
msgstr ""

#: ../source/contribute.rst:237
msgid "**Numbers**"
msgstr ""

#: ../source/contribute.rst:237
msgid "In body text, write numbers one through nine as words. For other numbers or numbers in tables, use numerals."
msgstr ""

#: ../source/discussions/deploying-python-applications.rst:4
msgid "Deploying Python applications"
msgstr ""

#: ../source/discussions/deploying-python-applications.rst:0
#: ../source/guides/index-mirrors-and-caches.rst:0
#: ../source/guides/installing-using-linux-tools.rst:0
#: ../source/guides/packaging-binary-extensions.rst:0
#: ../source/guides/supporting-multiple-python-versions.rst:0
#: ../source/guides/supporting-windows-using-appveyor.rst:0
msgid "Page Status"
msgstr ""

#: ../source/discussions/deploying-python-applications.rst:6
#: ../source/guides/index-mirrors-and-caches.rst:7
#: ../source/guides/installing-using-linux-tools.rst:7
#: ../source/guides/packaging-binary-extensions.rst:7
#: ../source/guides/supporting-multiple-python-versions.rst:7
#: ../source/guides/supporting-windows-using-appveyor.rst:5
msgid "Incomplete"
msgstr ""

#: ../source/discussions/deploying-python-applications.rst:0
#: ../source/guides/index-mirrors-and-caches.rst:0
#: ../source/guides/installing-using-linux-tools.rst:0
#: ../source/guides/packaging-binary-extensions.rst:0
#: ../source/guides/supporting-multiple-python-versions.rst:0
#: ../source/guides/supporting-windows-using-appveyor.rst:0
msgid "Last Reviewed"
msgstr ""

#: ../source/discussions/deploying-python-applications.rst:7
msgid "2014-11-11"
msgstr ""

#: ../source/discussions/deploying-python-applications.rst:11
#: ../source/discussions/install-requires-vs-requirements.rst:9
#: ../source/guides/analyzing-pypi-package-downloads.rst:12
#: ../source/guides/distributing-packages-using-setuptools.rst:22
#: ../source/guides/index-mirrors-and-caches.rst:12
#: ../source/guides/installing-scientific-packages.rst:9
#: ../source/guides/packaging-binary-extensions.rst:17
#: ../source/guides/supporting-multiple-python-versions.rst:12
#: ../source/guides/supporting-windows-using-appveyor.rst:15
#: ../source/overview.rst:23
#: ../source/specifications/core-metadata.rst:38
#: ../source/specifications/direct-url.rst:14
#: ../source/tutorials/installing-packages.rst:23
msgid "Contents"
msgstr ""

#: ../source/discussions/deploying-python-applications.rst:14
msgid "Overview"
msgstr ""

#: ../source/discussions/deploying-python-applications.rst:18
msgid "Supporting multiple hardware platforms"
msgstr ""

#: ../source/discussions/deploying-python-applications.rst:40
msgid "OS packaging & installers"
msgstr ""

#: ../source/discussions/deploying-python-applications.rst:52
msgid "Windows"
msgstr ""

#: ../source/discussions/deploying-python-applications.rst:61
msgid "Pynsist"
msgstr ""

#: ../source/discussions/deploying-python-applications.rst:63
msgid "`Pynsist <https://pypi.org/project/pynsist>`__ is a tool that bundles Python programs together with the Python-interpreter into a single installer based on NSIS. In most cases, packaging only requires the user to choose a version of the Python-interpreter and declare the dependencies of the program. The tool downloads the specified Python-interpreter for Windows and packages it with all the dependencies in a single Windows-executable installer."
msgstr ""

#: ../source/discussions/deploying-python-applications.rst:70
msgid "The installed program can be started from a shortcut that the installer adds to the start-menu. It uses a Python interpreter installed within its application directory, independent of any other Python installation on the computer."
msgstr ""

#: ../source/discussions/deploying-python-applications.rst:74
msgid "A big advantage of Pynsist is that the Windows packages can be built on Linux. There are several examples for different kinds of programs (console, GUI) in the `documentation <https://pynsist.readthedocs.io>`__. The tool is released under the MIT-licence."
msgstr ""

#: ../source/discussions/deploying-python-applications.rst:80
msgid "Application bundles"
msgstr ""

#: ../source/discussions/deploying-python-applications.rst:91
msgid "Configuration management"
msgstr ""

#: ../source/discussions/index.rst:4
msgid "**Discussions** are focused on providing comprehensive information about a specific topic. If you're just trying to get stuff done, see :doc:`/guides/index`."
msgstr ""

#: ../source/discussions/install-requires-vs-requirements.rst:5
msgid "install_requires vs requirements files"
msgstr ""

#: ../source/discussions/install-requires-vs-requirements.rst:12
#: ../source/guides/distributing-packages-using-setuptools.rst:382
msgid "install_requires"
msgstr ""

#: ../source/discussions/install-requires-vs-requirements.rst:14
msgid "``install_requires`` is a :ref:`setuptools` :file:`setup.py` keyword that should be used to specify what a project **minimally** needs to run correctly. When the project is installed by :ref:`pip`, this is the specification that is used to install its dependencies."
msgstr ""

#: ../source/discussions/install-requires-vs-requirements.rst:19
msgid "For example, if the project requires A and B, your ``install_requires`` would be like so:"
msgstr ""

#: ../source/discussions/install-requires-vs-requirements.rst:29
msgid "Additionally, it's best practice to indicate any known lower or upper bounds."
msgstr ""

#: ../source/discussions/install-requires-vs-requirements.rst:31
msgid "For example, it may be known, that your project requires at least v1 of 'A', and v2 of 'B', so it would be like so:"
msgstr ""

#: ../source/discussions/install-requires-vs-requirements.rst:41
msgid "It may also be known that project A follows semantic versioning, and that v2 of 'A' will indicate a break in compatibility, so it makes sense to not allow v2:"
msgstr ""

#: ../source/discussions/install-requires-vs-requirements.rst:51
msgid "It is not considered best practice to use ``install_requires`` to pin dependencies to specific versions, or to specify sub-dependencies (i.e. dependencies of your dependencies).  This is overly-restrictive, and prevents the user from gaining the benefit of dependency upgrades."
msgstr ""

#: ../source/discussions/install-requires-vs-requirements.rst:56
msgid "Lastly, it's important to understand that ``install_requires`` is a listing of \"Abstract\" requirements, i.e just names and version restrictions that don't determine where the dependencies will be fulfilled from (i.e. from what index or source).  The where (i.e. how they are to be made \"Concrete\") is to be determined at install time using :ref:`pip` options. [1]_"
msgstr ""

#: ../source/discussions/install-requires-vs-requirements.rst:64
#: ../source/tutorials/installing-packages.rst:460
msgid "Requirements files"
msgstr ""

#: ../source/discussions/install-requires-vs-requirements.rst:66
msgid ":ref:`Requirements Files <pip:Requirements Files>` described most simply, are just a list of :ref:`pip:pip install` arguments placed into a file."
msgstr ""

#: ../source/discussions/install-requires-vs-requirements.rst:69
msgid "Whereas ``install_requires`` defines the dependencies for a single project, :ref:`Requirements Files <pip:Requirements Files>` are often used to define the requirements for a complete Python environment."
msgstr ""

#: ../source/discussions/install-requires-vs-requirements.rst:73
msgid "Whereas ``install_requires`` requirements are minimal, requirements files often contain an exhaustive listing of pinned versions for the purpose of achieving :ref:`repeatable installations <pip:Repeatability>` of a complete environment."
msgstr ""

#: ../source/discussions/install-requires-vs-requirements.rst:78
msgid "Whereas ``install_requires`` requirements are \"Abstract\", i.e. not associated with any particular index, requirements files often contain pip options like ``--index-url`` or ``--find-links`` to make requirements \"Concrete\", i.e. associated with a particular index or directory of packages. [1]_"
msgstr ""

#: ../source/discussions/install-requires-vs-requirements.rst:84
msgid "Whereas ``install_requires`` metadata is automatically analyzed by pip during an install, requirements files are not, and only are used when a user specifically installs them using ``python -m pip install -r``."
msgstr ""

#: ../source/discussions/install-requires-vs-requirements.rst:90
msgid "For more on \"Abstract\" vs \"Concrete\" requirements, see https://caremad.io/2013/07/setup-vs-requirement/."
msgstr ""

#: ../source/discussions/pip-vs-easy-install.rst:6
msgid "pip vs easy_install"
msgstr ""

#: ../source/discussions/pip-vs-easy-install.rst:9
msgid ":ref:`easy_install <easy_install>`, now `deprecated`_, was released in 2004 as part of :ref:`setuptools`. It was notable at the time for installing :term:`packages <Distribution Package>` from :term:`PyPI <Python Package Index (PyPI)>` using requirement specifiers, and automatically installing dependencies."
msgstr ""

#: ../source/discussions/pip-vs-easy-install.rst:14
msgid ":ref:`pip` came later in 2008, as alternative to :ref:`easy_install <easy_install>`, although still largely built on top of :ref:`setuptools` components.  It was notable at the time for *not* installing packages as :term:`Eggs <Egg>` or from :term:`Eggs <Egg>` (but rather simply as 'flat' packages from :term:`sdists <Source Distribution (or \"sdist\")>`), and introducing the idea of :ref:`Requirements Files <pip:Requirements Files>`, which gave users the power to easily replicate environments."
msgstr ""

#: ../source/discussions/pip-vs-easy-install.rst:22
msgid "Here's a breakdown of the important differences between pip and the deprecated easy_install:"
msgstr ""

#: ../source/discussions/pip-vs-easy-install.rst:25
msgid "**pip**"
msgstr ""

#: ../source/discussions/pip-vs-easy-install.rst:25
msgid "**easy_install**"
msgstr ""

#: ../source/discussions/pip-vs-easy-install.rst:27
msgid "Installs from :term:`Wheels <Wheel>`"
msgstr ""

#: ../source/discussions/pip-vs-easy-install.rst:27
#: ../source/discussions/pip-vs-easy-install.rst:38
#: ../source/discussions/pip-vs-easy-install.rst:44
#: ../source/discussions/pip-vs-easy-install.rst:48
#: ../source/discussions/pip-vs-easy-install.rst:54
#: ../source/discussions/pip-vs-easy-install.rst:57
msgid "Yes"
msgstr ""

#: ../source/discussions/pip-vs-easy-install.rst:27
#: ../source/discussions/pip-vs-easy-install.rst:30
#: ../source/discussions/pip-vs-easy-install.rst:32
#: ../source/discussions/pip-vs-easy-install.rst:35
#: ../source/discussions/pip-vs-easy-install.rst:38
#: ../source/discussions/pip-vs-easy-install.rst:44
#: ../source/discussions/pip-vs-easy-install.rst:48
#: ../source/discussions/pip-vs-easy-install.rst:51
#: ../source/discussions/pip-vs-easy-install.rst:54
#: ../source/discussions/pip-vs-easy-install.rst:57
msgid "No"
msgstr ""

#: ../source/discussions/pip-vs-easy-install.rst:30
msgid "Uninstall Packages"
msgstr ""

#: ../source/discussions/pip-vs-easy-install.rst:30
msgid "Yes (``python -m pip uninstall``)"
msgstr ""

#: ../source/discussions/pip-vs-easy-install.rst:32
msgid "Dependency Overrides"
msgstr ""

#: ../source/discussions/pip-vs-easy-install.rst:32
msgid "Yes (:ref:`Requirements Files <pip:Requirements Files>`)"
msgstr ""

#: ../source/discussions/pip-vs-easy-install.rst:35
msgid "List Installed Packages"
msgstr ""

#: ../source/discussions/pip-vs-easy-install.rst:35
msgid "Yes (``python -m pip list`` and ``python -m pip freeze``)"
msgstr ""

#: ../source/discussions/pip-vs-easy-install.rst:38
msgid ":pep:`438` Support"
msgstr ""

#: ../source/discussions/pip-vs-easy-install.rst:41
msgid "Installation format"
msgstr ""

#: ../source/discussions/pip-vs-easy-install.rst:41
msgid "'Flat' packages with :file:`egg-info` metadata."
msgstr ""

#: ../source/discussions/pip-vs-easy-install.rst:41
msgid "Encapsulated Egg format"
msgstr ""

#: ../source/discussions/pip-vs-easy-install.rst:44
msgid "sys.path modification"
msgstr ""

#: ../source/discussions/pip-vs-easy-install.rst:48
msgid "Installs from :term:`Eggs <Egg>`"
msgstr ""

#: ../source/discussions/pip-vs-easy-install.rst:51
msgid "`pylauncher support`_"
msgstr ""

#: ../source/discussions/pip-vs-easy-install.rst:51
msgid "Yes [1]_"
msgstr ""

#: ../source/discussions/pip-vs-easy-install.rst:54
msgid ":ref:`Multi-version Installs`"
msgstr ""

#: ../source/discussions/pip-vs-easy-install.rst:57
msgid "Exclude scripts during install"
msgstr ""

#: ../source/discussions/pip-vs-easy-install.rst:60
msgid "per project index"
msgstr ""

#: ../source/discussions/pip-vs-easy-install.rst:60
msgid "Only in virtualenv"
msgstr ""

#: ../source/discussions/pip-vs-easy-install.rst:60
msgid "Yes, via setup.cfg"
msgstr ""

#: ../source/discussions/pip-vs-easy-install.rst:68
msgid "https://setuptools.readthedocs.io/en/latest/easy_install.html#natural-script-launcher"
msgstr ""

#: ../source/discussions/wheel-vs-egg.rst:5
msgid "Wheel vs Egg"
msgstr ""

#: ../source/discussions/wheel-vs-egg.rst:7
msgid ":term:`Wheel` and :term:`Egg` are both packaging formats that aim to support the use case of needing an install artifact that doesn't require building or compilation, which can be costly in testing and production workflows."
msgstr ""

#: ../source/discussions/wheel-vs-egg.rst:11
msgid "The :term:`Egg` format was introduced by :ref:`setuptools` in 2004, whereas the :term:`Wheel` format was introduced by :pep:`427` in 2012."
msgstr ""

#: ../source/discussions/wheel-vs-egg.rst:14
msgid ":term:`Wheel` is currently considered the standard for :term:`built <Built Distribution>` and :term:`binary <Binary Distribution>` packaging for Python."
msgstr ""

#: ../source/discussions/wheel-vs-egg.rst:17
msgid "Here's a breakdown of the important differences between :term:`Wheel` and :term:`Egg`."
msgstr ""

#: ../source/discussions/wheel-vs-egg.rst:20
msgid ":term:`Wheel` has an :pep:`official PEP <427>`. :term:`Egg` did not."
msgstr ""

#: ../source/discussions/wheel-vs-egg.rst:22
msgid ":term:`Wheel` is a :term:`distribution <Distribution Package>` format, i.e a packaging format. [1]_ :term:`Egg` was both a distribution format and a runtime installation format (if left zipped), and was designed to be importable."
msgstr ""

#: ../source/discussions/wheel-vs-egg.rst:26
msgid ":term:`Wheel` archives do not include .pyc files. Therefore, when the distribution only contains Python files (i.e. no compiled extensions), and is compatible with Python 2 and 3, it's possible for a wheel to be \"universal\", similar to an :term:`sdist <Source Distribution (or \"sdist\")>`."
msgstr ""

#: ../source/discussions/wheel-vs-egg.rst:31
msgid ":term:`Wheel` uses :pep:`PEP376-compliant <376>` ``.dist-info`` directories. Egg used ``.egg-info``."
msgstr ""

#: ../source/discussions/wheel-vs-egg.rst:34
msgid ":term:`Wheel` has a :pep:`richer file naming convention <425>`. A single wheel archive can indicate its compatibility with a number of Python language versions and implementations, ABIs, and system architectures."
msgstr ""

#: ../source/discussions/wheel-vs-egg.rst:38
msgid ":term:`Wheel` is versioned. Every wheel file contains the version of the wheel specification and the implementation that packaged it."
msgstr ""

#: ../source/discussions/wheel-vs-egg.rst:41
msgid ":term:`Wheel` is internally organized by `sysconfig path type <http://docs.python.org/2/library/sysconfig.html#installation-paths>`_, therefore making it easier to convert to other formats."
msgstr ""

#: ../source/discussions/wheel-vs-egg.rst:47
msgid "Circumstantially, in some cases, wheels can be used as an importable runtime format, although :pep:`this is not officially supported at this time <427#is-it-possible-to-import-python-code-directly-from-a-wheel-file>`."
msgstr ""

#: ../source/glossary.rst:3
msgid "Glossary"
msgstr ""

#: ../source/glossary.rst:8
msgid "Binary Distribution"
msgstr ""

#: ../source/glossary.rst:11
msgid "A specific kind of :term:`Built Distribution` that contains compiled extensions."
msgstr ""

#: ../source/glossary.rst:14
msgid "Built Distribution"
msgstr ""

#: ../source/glossary.rst:17
msgid "A :term:`Distribution <Distribution Package>` format containing files and metadata that only need to be moved to the correct location on the target system, to be installed. :term:`Wheel` is such a format, whereas distutil's :term:`Source Distribution <Source Distribution (or \"sdist\")>` is not, in that it requires a build step before it can be installed.  This format does not imply that Python files have to be precompiled (:term:`Wheel` intentionally does not include compiled Python files)."
msgstr ""

#: ../source/glossary.rst:26
msgid "Distribution Package"
msgstr ""

#: ../source/glossary.rst:29
msgid "A versioned archive file that contains Python :term:`packages <Import Package>`, :term:`modules <Module>`, and other resource files that are used to distribute a :term:`Release`. The archive file is what an end-user will download from the internet and install."
msgstr ""

#: ../source/glossary.rst:34
msgid "A distribution package is more commonly referred to with the single words \"package\" or \"distribution\", but this guide may use the expanded term when more clarity is needed to prevent confusion with an :term:`Import Package` (which is also commonly called a \"package\") or another kind of distribution (e.g. a Linux distribution or the Python language distribution), which are often referred to with the single term \"distribution\"."
msgstr ""

#: ../source/glossary.rst:41
msgid "Egg"
msgstr ""

#: ../source/glossary.rst:44
msgid "A :term:`Built Distribution` format introduced by :ref:`setuptools`, which is being replaced by :term:`Wheel`.  For details, see `The Internal Structure of Python Eggs <https://setuptools.readthedocs.io/en/latest/deprecated/python_eggs.html>`_ and `Python Eggs <http://peak.telecommunity.com/DevCenter/PythonEggs>`_"
msgstr ""

#: ../source/glossary.rst:49
msgid "Extension Module"
msgstr ""

#: ../source/glossary.rst:52
msgid "A :term:`Module` written in the low-level language of the Python implementation: C/C++ for Python, Java for Jython. Typically contained in a single dynamically loadable pre-compiled file, e.g.  a shared object (.so) file for Python extensions on Unix, a DLL (given the .pyd extension) for Python extensions on Windows, or a Java class file for Jython extensions."
msgstr ""

#: ../source/glossary.rst:59
msgid "Known Good Set (KGS)"
msgstr ""

#: ../source/glossary.rst:62
msgid "A set of distributions at specified versions which are compatible with each other. Typically a test suite will be run which passes all tests before a specific set of packages is declared a known good set. This term is commonly used by frameworks and toolkits which are comprised of multiple individual distributions."
msgstr ""

#: ../source/glossary.rst:68
msgid "Import Package"
msgstr ""

#: ../source/glossary.rst:71
msgid "A Python module which can contain other modules or recursively, other packages."
msgstr ""

#: ../source/glossary.rst:74
msgid "An import package is more commonly referred to with the single word \"package\", but this guide will use the expanded term when more clarity is needed to prevent confusion with a :term:`Distribution Package` which is also commonly called a \"package\"."
msgstr ""

#: ../source/glossary.rst:78
msgid "Module"
msgstr ""

#: ../source/glossary.rst:81
msgid "The basic unit of code reusability in Python, existing in one of two types: :term:`Pure Module`, or :term:`Extension Module`."
msgstr ""

#: ../source/glossary.rst:84
msgid "Package Index"
msgstr ""

#: ../source/glossary.rst:87
msgid "A repository of distributions with a web interface to automate :term:`package <Distribution Package>` discovery and consumption."
msgstr ""

#: ../source/glossary.rst:90
msgid "Per Project Index"
msgstr ""

#: ../source/glossary.rst:93
msgid "A private or other non-canonical :term:`Package Index` indicated by a specific :term:`Project` as the index preferred or required to resolve dependencies of that project."
msgstr ""

#: ../source/glossary.rst:97
msgid "Project"
msgstr ""

#: ../source/glossary.rst:100
msgid "A library, framework, script, plugin, application, or collection of data or other resources, or some combination thereof that is intended to be packaged into a :term:`Distribution <Distribution Package>`."
msgstr ""

#: ../source/glossary.rst:104
msgid "Since most projects create :term:`Distributions <Distribution Package>` using either :pep:`518` ``build-system``, :ref:`distutils` or :ref:`setuptools`, another practical way to define projects currently is something that contains a :term:`pyproject.toml`, :term:`setup.py`, or :term:`setup.cfg` file at the root of the project source directory."
msgstr ""

#: ../source/glossary.rst:110
msgid "Python projects must have unique names, which are registered on :term:`PyPI <Python Package Index (PyPI)>`. Each project will then contain one or more :term:`Releases <Release>`, and each release may comprise one or more :term:`distributions <Distribution Package>`."
msgstr ""

#: ../source/glossary.rst:115
msgid "Note that there is a strong convention to name a project after the name of the package that is imported to run that project. However, this doesn't have to hold true. It's possible to install a distribution from the project 'foo' and have it provide a package importable only as 'bar'."
msgstr ""

#: ../source/glossary.rst:121
msgid "Pure Module"
msgstr ""

#: ../source/glossary.rst:124
msgid "A :term:`Module` written in Python and contained in a single ``.py`` file (and possibly associated ``.pyc`` and/or ``.pyo`` files)."
msgstr ""

#: ../source/glossary.rst:127
msgid "Python Packaging Authority (PyPA)"
msgstr ""

#: ../source/glossary.rst:130
msgid "PyPA is a working group that maintains many of the relevant projects in Python packaging. They maintain a site at https://www.pypa.io, host projects on `GitHub <https://github.com/pypa>`_ and `Bitbucket <https://bitbucket.org/pypa>`_, and discuss issues on the `distutils-sig mailing list <https://mail.python.org/mailman3/lists/distutils-sig.python.org/>`_ and `the Python Discourse forum <https://discuss.python.org/c/packaging>`__."
msgstr ""

#: ../source/glossary.rst:139
msgid "Python Package Index (PyPI)"
msgstr ""

#: ../source/glossary.rst:142
msgid "`PyPI <https://pypi.org>`_ is the default :term:`Package Index` for the Python community. It is open to all Python developers to consume and distribute their distributions."
msgstr ""

#: ../source/glossary.rst:145
msgid "pypi.org"
msgstr ""

#: ../source/glossary.rst:148
msgid "`pypi.org <https://pypi.org>`_ is the domain name for the :term:`Python Package Index (PyPI)`. It replaced the legacy index domain name, ``pypi.python.org``, in 2017. It is powered by :ref:`warehouse`."
msgstr ""

#: ../source/glossary.rst:152
msgid "pyproject.toml"
msgstr ""

#: ../source/glossary.rst:155
msgid "The tool-agnostic :term:`Project` specification file. Defined in :pep:`518`."
msgstr ""

#: ../source/glossary.rst:157
msgid "Release"
msgstr ""

#: ../source/glossary.rst:160
msgid "A snapshot of a :term:`Project` at a particular point in time, denoted by a version identifier."
msgstr ""

#: ../source/glossary.rst:163
msgid "Making a release may entail the publishing of multiple :term:`Distributions <Distribution Package>`.  For example, if version 1.0 of a project was released, it could be available in both a source distribution format and a Windows installer distribution format."
msgstr ""

#: ../source/glossary.rst:168
msgid "Requirement"
msgstr ""

#: ../source/glossary.rst:171
msgid "A specification for a :term:`package <Distribution Package>` to be installed.  :ref:`pip`, the :term:`PYPA <Python Packaging Authority (PyPA)>` recommended installer, allows various forms of specification that can all be considered a \"requirement\". For more information, see the :ref:`pip:pip install` reference."
msgstr ""

#: ../source/glossary.rst:177
msgid "Requirement Specifier"
msgstr ""

#: ../source/glossary.rst:180
msgid "A format used by :ref:`pip` to install packages from a :term:`Package Index`. For an EBNF diagram of the format, see the `pkg_resources.Requirement <https://setuptools.readthedocs.io/en/latest/pkg_resources.html#requirement-objects>`_ entry in the :ref:`setuptools` docs. For example, \"foo>=1.3\" is a requirement specifier, where \"foo\" is the project name, and the \">=1.3\" portion is the :term:`Version Specifier`"
msgstr ""

#: ../source/glossary.rst:187
msgid "Requirements File"
msgstr ""

#: ../source/glossary.rst:190
msgid "A file containing a list of :term:`Requirements <Requirement>` that can be installed using :ref:`pip`. For more information, see the :ref:`pip` docs on :ref:`pip:Requirements Files`."
msgstr ""

#: ../source/glossary.rst:194
#: ../source/guides/distributing-packages-using-setuptools.rst:56
msgid "setup.py"
msgstr ""

#: ../source/glossary.rst:195
#: ../source/guides/distributing-packages-using-setuptools.rst:77
msgid "setup.cfg"
msgstr ""

#: ../source/glossary.rst:198
msgid "The project specification files for :ref:`distutils` and :ref:`setuptools`. See also :term:`pyproject.toml`."
msgstr ""

#: ../source/glossary.rst:201
msgid "Source Archive"
msgstr ""

#: ../source/glossary.rst:204
msgid "An archive containing the raw source code for a :term:`Release`, prior to creation of a :term:`Source Distribution <Source Distribution (or \"sdist\")>` or :term:`Built Distribution`."
msgstr ""

#: ../source/glossary.rst:208
msgid "Source Distribution (or \"sdist\")"
msgstr ""

#: ../source/glossary.rst:211
msgid "A :term:`distribution <Distribution Package>` format (usually generated using ``python setup.py sdist``) that provides metadata and the essential source files needed for installing by a tool like :ref:`pip`, or for generating a :term:`Built Distribution`."
msgstr ""

#: ../source/glossary.rst:216
msgid "System Package"
msgstr ""

#: ../source/glossary.rst:219
msgid "A package provided in a format native to the operating system, e.g. an rpm or dpkg file."
msgstr ""

#: ../source/glossary.rst:222
msgid "Version Specifier"
msgstr ""

#: ../source/glossary.rst:225
msgid "The version component of a :term:`Requirement Specifier`. For example, the \">=1.3\" portion of \"foo>=1.3\".  :pep:`440` contains a :pep:`full specification <440#version-specifiers>` of the specifiers that Python packaging currently supports.  Support for PEP440 was implemented in :ref:`setuptools` v8.0 and :ref:`pip` v6.0."
msgstr ""

#: ../source/glossary.rst:231
msgid "Virtual Environment"
msgstr ""

#: ../source/glossary.rst:234
msgid "An isolated Python environment that allows packages to be installed for use by a particular application, rather than being installed system wide. For more information, see the section on :ref:`Creating and using Virtual Environments`."
msgstr ""

#: ../source/glossary.rst:238
msgid "Wheel"
msgstr ""

#: ../source/glossary.rst:241
msgid "A :term:`Built Distribution` format introduced by :pep:`427`, which is intended to replace the :term:`Egg` format.  Wheel is currently supported by :ref:`pip`."
msgstr ""

#: ../source/glossary.rst:244
msgid "Working Set"
msgstr ""

#: ../source/glossary.rst:247
msgid "A collection of :term:`distributions <Distribution Package>` available for importing. These are the distributions that are on the `sys.path` variable. At most, one :term:`Distribution <Distribution Package>` for a project is possible in a working set."
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:3
msgid "Analyzing PyPI package downloads"
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:5
msgid "This section covers how to use the public PyPI download statistics dataset to learn more about downloads of a package (or packages) hosted on PyPI. For example, you can use it to discover the distribution of Python versions used to download a package."
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:15
#: ../source/guides/supporting-windows-using-appveyor.rst:18
msgid "Background"
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:17
msgid "PyPI does not display download statistics for a number of reasons: [#]_"
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:19
msgid "**Inefficient to make work with a Content Distribution Network (CDN):** Download statistics change constantly. Including them in project pages, which are heavily cached, would require invalidating the cache more often, and reduce the overall effectiveness of the cache."
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:24
msgid "**Highly inaccurate:** A number of things prevent the download counts from being accurate, some of which include:"
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:27
msgid "``pip``'s download cache (lowers download counts)"
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:28
msgid "Internal or unofficial mirrors (can both raise or lower download counts)"
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:29
msgid "Packages not hosted on PyPI (for comparisons sake)"
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:30
msgid "Unofficial scripts or attempts at download count inflation (raises download counts)"
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:32
msgid "Known historical data quality issues (lowers download counts)"
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:34
msgid "**Not particularly useful:** Just because a project has been downloaded a lot doesn't mean it's good; Similarly just because a project hasn't been downloaded a lot doesn't mean it's bad!"
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:38
msgid "In short, because it's value is low for various reasons, and the tradeoffs required to make it work are high, it has been not an effective use of limited resources."
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:43
msgid "Public dataset"
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:45
msgid "As an alternative, the `Linehaul project <https://github.com/pypa/linehaul>`__ streams download logs from PyPI to `Google BigQuery`_ [#]_, where they are stored as a public dataset."
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:50
msgid "Getting set up"
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:52
msgid "In order to use `Google BigQuery`_ to query the `public PyPI download statistics dataset`_, you'll need a Google account and to enable the BigQuery API on a Google Cloud Platform project. You can run the up to 1TB of queries per month `using the BigQuery free tier without a credit card <https://cloud.google.com/blog/big-data/2017/01/how-to-run-a-terabyte-of-google-bigquery-queries-each-month-without-a-credit-card>`__"
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:58
msgid "Navigate to the `BigQuery web UI`_."
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:59
msgid "Create a new project."
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:60
msgid "Enable the `BigQuery API <https://console.developers.google.com/apis/library/bigquery-json.googleapis.com>`__."
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:63
msgid "For more detailed instructions on how to get started with BigQuery, check out the `BigQuery quickstart guide <https://cloud.google.com/bigquery/docs/quickstarts/quickstart-web-ui>`__."
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:69
msgid "Data schema"
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:71
msgid "Linehaul writes an entry in a ``bigquery-public-data.pypi.file_downloads`` table for each download. The table contains information about what file was downloaded and how it was downloaded. Some useful columns from the `table schema <https://console.cloud.google.com/bigquery?pli=1&p=bigquery-public-data&d=pypi&t=file_downloads&page=table>`__ include:"
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:78
msgid "Column"
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:78
#: ../source/guides/using-manifest-in.rst:67
#: ../source/specifications/core-metadata.rst:185
msgid "Description"
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:78
#: ../source/specifications/direct-url.rst:226
msgid "Examples"
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:80
msgid "timestamp"
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:80
msgid "Date and time"
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:80
msgid "``2020-03-09 00:33:03 UTC``"
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:82
msgid "file.project"
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:82
msgid "Project name"
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:82
msgid "``pipenv``, ``nose``"
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:84
msgid "file.version"
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:84
msgid "Package version"
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:84
msgid "``0.1.6``, ``1.4.2``"
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:86
msgid "details.installer.name"
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:86
msgid "Installer"
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:86
msgid "pip, `bandersnatch`_"
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:88
msgid "details.python"
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:88
msgid "Python version"
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:88
msgid "``2.7.12``, ``3.6.4``"
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:93
msgid "Useful queries"
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:95
msgid "Run queries in the `BigQuery web UI`_ by clicking the \"Compose query\" button."
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:97
msgid "Note that the rows are stored in a partitioned, which helps limit the cost of queries. These example queries analyze downloads from recent history by filtering on the ``timestamp`` column."
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:102
msgid "Counting package downloads"
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:104
msgid "The following query counts the total number of downloads for the project \"pytest\"."
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:119
#: ../source/guides/analyzing-pypi-package-downloads.rst:140
#: ../source/guides/analyzing-pypi-package-downloads.rst:168
#: ../source/guides/analyzing-pypi-package-downloads.rst:205
msgid "num_downloads"
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:121
msgid "26190085"
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:124
msgid "To only count downloads from pip, filter on the ``details.installer.name`` column."
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:142
msgid "24334215"
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:146
msgid "Package downloads over time"
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:148
msgid "To group by monthly downloads, use the ``TIMESTAMP_TRUNC`` function. Also filtering by this column reduces corresponding costs."
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:168
msgid "month"
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:170
msgid "1956741"
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:170
msgid "2018-01-01"
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:172
msgid "2344692"
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:172
msgid "2017-12-01"
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:174
msgid "1730398"
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:174
msgid "2017-11-01"
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:176
msgid "2047310"
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:176
msgid "2017-10-01"
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:178
msgid "1744443"
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:178
msgid "2017-09-01"
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:180
msgid "1916952"
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:180
msgid "2017-08-01"
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:184
msgid "Python versions over time"
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:186
msgid "Extract the Python version from the ``details.python`` column. Warning: This query processes over 500 GB of data."
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:205
msgid "python"
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:207
msgid "3.7"
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:207
msgid "18051328726"
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:209
msgid "3.6"
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:209
msgid "9635067203"
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:211
msgid "3.8"
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:211
msgid "7781904681"
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:213
msgid "2.7"
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:213
msgid "6381252241"
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:215
msgid "null"
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:215
msgid "2026630299"
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:217
msgid "3.5"
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:217
msgid "1894153540"
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:221
msgid "Caveats"
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:223
msgid "In addition to the caveats listed in the background above, Linehaul suffered from a bug which caused it to significantly under-report download statistics prior to July 26, 2018. Downloads before this date are proportionally accurate (e.g. the percentage of Python 2 vs. Python 3 downloads) but total numbers are lower than actual by an order of magnitude."
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:231
msgid "Additional tools"
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:233
msgid "Besides using the BigQuery console, there are some additional tools which may be useful when analyzing download statistics."
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:237
msgid "``google-cloud-bigquery``"
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:239
msgid "You can also access the public PyPI download statistics dataset programmatically via the BigQuery API and the `google-cloud-bigquery`_ project, the official Python client library for BigQuery."
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:267
msgid "``pypinfo``"
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:269
msgid "`pypinfo`_ is a command-line tool which provides access to the dataset and can generate several useful queries. For example, you can query the total number of download for a package with the command ``pypinfo package_name``."
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:273
msgid "Install `pypinfo`_ using pip."
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:279
msgid "Usage:"
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:295
msgid "``pandas-gbq``"
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:297
msgid "The `pandas-gbq`_ project allows for accessing query results via `Pandas`_."
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:301
#: ../source/specifications/binary-distribution-format.rst:459
msgid "References"
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:303
msgid "`PyPI Download Counts deprecation email <https://mail.python.org/pipermail/distutils-sig/2013-May/020855.html>`__"
msgstr ""

#: ../source/guides/analyzing-pypi-package-downloads.rst:304
msgid "`PyPI BigQuery dataset announcement email <https://mail.python.org/pipermail/distutils-sig/2016-May/028986.html>`__"
msgstr ""

#: ../source/guides/creating-and-discovering-plugins.rst:3
msgid "Creating and discovering plugins"
msgstr ""

#: ../source/guides/creating-and-discovering-plugins.rst:5
msgid "Often when creating a Python application or library you'll want the ability to provide customizations or extra features via **plugins**. Because Python packages can be separately distributed, your application or library may want to automatically **discover** all of the plugins available."
msgstr ""

#: ../source/guides/creating-and-discovering-plugins.rst:10
msgid "There are three major approaches to doing automatic plugin discovery:"
msgstr ""

#: ../source/guides/creating-and-discovering-plugins.rst:12
msgid "`Using naming convention`_."
msgstr ""

#: ../source/guides/creating-and-discovering-plugins.rst:13
msgid "`Using namespace packages`_."
msgstr ""

#: ../source/guides/creating-and-discovering-plugins.rst:14
msgid "`Using package metadata`_."
msgstr ""

#: ../source/guides/creating-and-discovering-plugins.rst:18
msgid "Using naming convention"
msgstr ""

#: ../source/guides/creating-and-discovering-plugins.rst:20
msgid "If all of the plugins for your application follow the same naming convention, you can use :func:`pkgutil.iter_modules` to discover all of the top-level modules that match the naming convention. For example, `Flask`_ uses the naming convention ``flask_{plugin_name}``. If you wanted to automatically discover all of the Flask plugins installed:"
msgstr ""

#: ../source/guides/creating-and-discovering-plugins.rst:38
msgid "If you had both the `Flask-SQLAlchemy`_ and `Flask-Talisman`_ plugins installed then ``discovered_plugins`` would be:"
msgstr ""

#: ../source/guides/creating-and-discovering-plugins.rst:48
msgid "Using naming convention for plugins also allows you to query the Python Package Index's `simple API`_ for all packages that conform to your naming convention."
msgstr ""

#: ../source/guides/creating-and-discovering-plugins.rst:59
msgid "Using namespace packages"
msgstr ""

#: ../source/guides/creating-and-discovering-plugins.rst:61
msgid ":doc:`Namespace packages <packaging-namespace-packages>` can be used to provide a convention for where to place plugins and also provides a way to perform discovery. For example, if you make the sub-package ``myapp.plugins`` a namespace package then other :term:`distributions <Distribution Package>` can provide modules and packages to that namespace. Once installed, you can use :func:`pkgutil.iter_modules` to discover all modules and packages installed under that namespace:"
msgstr ""

#: ../source/guides/creating-and-discovering-plugins.rst:89
msgid "Specifying ``myapp.plugins.__path__`` to :func:`~pkgutil.iter_modules` causes it to only look for the modules directly under that namespace. For example, if you have installed distributions that provide the modules ``myapp.plugins.a`` and ``myapp.plugins.b`` then ``discovered_plugins`` in this case would be:"
msgstr ""

#: ../source/guides/creating-and-discovering-plugins.rst:101
msgid "This sample uses a sub-package as the namespace package (``myapp.plugins``), but it's also possible to use a top-level package for this purpose (such as ``myapp_plugins``). How to pick the namespace to use is a matter of preference, but it's not recommended to make your project's main top-level package (``myapp`` in this case) a namespace package for the purpose of plugins, as one bad plugin could cause the entire namespace to break which would in turn make your project unimportable. For the \"namespace sub-package\" approach to work, the plugin packages must omit the :file:`__init__.py` for your top-level package directory (``myapp`` in this case) and include the namespace-package style :file:`__init__.py` in the namespace sub-package directory (``myapp/plugins``).  This also means that plugins will need to explicitly pass a list of packages to :func:`setup`'s ``packages`` argument instead of using :func:`setuptools.find_packages`."
msgstr ""

#: ../source/guides/creating-and-discovering-plugins.rst:115
msgid "Namespace packages are a complex feature and there are several different ways to create them. It's highly recommended to read the :doc:`packaging-namespace-packages` documentation and clearly document which approach is preferred for plugins to your project."
msgstr ""

#: ../source/guides/creating-and-discovering-plugins.rst:121
msgid "Using package metadata"
msgstr ""

#: ../source/guides/creating-and-discovering-plugins.rst:123
msgid "`Setuptools`_ provides :doc:`special support <setuptools:userguide/entry_point>` for plugins. By providing the ``entry_points`` argument to :func:`setup` in :file:`setup.py` plugins can register themselves for discovery."
msgstr ""

#: ../source/guides/creating-and-discovering-plugins.rst:128
msgid "For example if you have a package named ``myapp-plugin-a`` and it includes in its :file:`setup.py`:"
msgstr ""

#: ../source/guides/creating-and-discovering-plugins.rst:139
msgid "Then you can discover and load all of the registered entry points by using :func:`importlib.metadata.entry_points` (or the `backport`_ ``importlib_metadata >= 3.6`` for Python 3.6-3.9):"
msgstr ""

#: ../source/guides/creating-and-discovering-plugins.rst:154
msgid "In this example, ``discovered_plugins`` would be a collection of type :class:`importlib.metadata.EntryPoint`:"
msgstr ""

#: ../source/guides/creating-and-discovering-plugins.rst:163
msgid "Now the module of your choice can be imported by executing ``discovered_plugins['a'].load()``."
msgstr ""

#: ../source/guides/creating-and-discovering-plugins.rst:166
msgid "The ``entry_point`` specification in :file:`setup.py` is fairly flexible and has a lot of options. It's recommended to read over the entire section on :doc:`entry points <setuptools:userguide/entry_point>` ."
msgstr ""

#: ../source/guides/creating-and-discovering-plugins.rst:170
msgid "Since this specification is part of the :doc:`standard library <python:library/importlib.metadata>`, most packaging tools other than setuptools provide support for defining entry points."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:5
msgid "Packaging and distributing projects"
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:7
msgid "This section covers the basics of how to configure, package and distribute your own Python projects.  It assumes that you are already familiar with the contents of the :doc:`/tutorials/installing-packages` page."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:11
msgid "The section does *not* aim to cover best practices for Python project development as a whole.  For example, it does not provide guidance or tool recommendations for version control, documentation, or testing."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:15
msgid "For more reference material, see :std:doc:`Building and Distributing Packages <userguide/index>` in the :ref:`setuptools` docs, but note that some advisory content there may be outdated. In the event of conflicts, prefer the advice in the Python Packaging User Guide."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:25
msgid "Requirements for packaging and distributing"
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:26
msgid "First, make sure you have already fulfilled the :ref:`requirements for installing packages <installing_requirements>`."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:29
msgid "Install \"twine\" [1]_:"
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:43
msgid "You'll need this to upload your project :term:`distributions <Distribution Package>` to :term:`PyPI <Python Package Index (PyPI)>` (see :ref:`below <Uploading your Project to PyPI>`)."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:49
msgid "Configuring your project"
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:53
msgid "Initial files"
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:58
msgid "The most important file is :file:`setup.py` which exists at the root of your project directory. For an example, see the `setup.py <https://github.com/pypa/sampleproject/blob/master/setup.py>`_ in the `PyPA sample project <https://github.com/pypa/sampleproject>`_."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:63
msgid ":file:`setup.py` serves two primary functions:"
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:65
msgid "It's the file where various aspects of your project are configured. The primary feature of :file:`setup.py` is that it contains a global ``setup()`` function.  The keyword arguments to this function are how specific details of your project are defined.  The most relevant arguments are explained in :ref:`the section below <setup() args>`."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:71
msgid "It's the command line interface for running various commands that relate to packaging tasks. To get a listing of available commands, run ``python setup.py --help-commands``."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:79
msgid ":file:`setup.cfg` is an ini file that contains option defaults for :file:`setup.py` commands.  For an example, see the `setup.cfg <https://github.com/pypa/sampleproject/blob/master/setup.cfg>`_ in the `PyPA sample project <https://github.com/pypa/sampleproject>`_."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:86
msgid "README.rst / README.md"
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:88
msgid "All projects should contain a readme file that covers the goal of the project. The most common format is `reStructuredText <http://docutils.sourceforge.net/rst.html>`_ with an \"rst\" extension, although this is not a requirement; multiple variants of `Markdown <https://daringfireball.net/projects/markdown/>`_ are supported as well (look at ``setup()``'s :ref:`long_description_content_type <description>` argument)."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:95
msgid "For an example, see `README.md <https://github.com/pypa/sampleproject/blob/master/README.md>`_ from the `PyPA sample project <https://github.com/pypa/sampleproject>`_."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:99
msgid "Projects using :ref:`setuptools` 0.6.27+ have standard readme files (:file:`README.rst`, :file:`README.txt`, or :file:`README`) included in source distributions by default. The built-in :ref:`distutils` library adopts this behavior beginning in Python 3.7. Additionally, :ref:`setuptools` 36.4.0+ will include a :file:`README.md` if found. If you are using setuptools, you don't need to list your readme file in :file:`MANIFEST.in`. Otherwise, include it to be explicit."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:108
msgid "MANIFEST.in"
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:110
msgid "A :file:`MANIFEST.in` is needed when you need to package additional files that are not automatically included in a source distribution.  For details on writing a :file:`MANIFEST.in` file, including a list of what's included by default, see \":ref:`Using MANIFEST.in`\"."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:115
msgid "For an example, see the `MANIFEST.in <https://github.com/pypa/sampleproject/blob/master/MANIFEST.in>`_ from the `PyPA sample project <https://github.com/pypa/sampleproject>`_."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:119
msgid ":file:`MANIFEST.in` does not affect binary distributions such as wheels."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:122
msgid "LICENSE.txt"
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:124
msgid "Every package should include a license file detailing the terms of distribution. In many jurisdictions, packages without an explicit license can not be legally used or distributed by anyone other than the copyright holder. If you're unsure which license to choose, you can use resources such as `GitHub's Choose a License <https://choosealicense.com/>`_ or consult a lawyer."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:130
msgid "For an example, see the `LICENSE.txt <https://github.com/pypa/sampleproject/blob/master/LICENSE.txt>`_ from the `PyPA sample project <https://github.com/pypa/sampleproject>`_."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:135
msgid "<your package>"
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:137
msgid "Although it's not required, the most common practice is to include your Python modules and packages under a single top-level package that has the same :ref:`name <setup() name>` as your project, or something very close."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:141
msgid "For an example, see the `sample <https://github.com/pypa/sampleproject/tree/master/src/sample>`_ package that's included in the `PyPA sample project <https://github.com/pypa/sampleproject>`_."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:149
msgid "setup() args"
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:151
msgid "As mentioned above, the primary feature of :file:`setup.py` is that it contains a global ``setup()`` function.  The keyword arguments to this function are how specific details of your project are defined."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:155
msgid "The most relevant arguments are explained below. Most of the snippets given are taken from the `setup.py <https://github.com/pypa/sampleproject/blob/master/setup.py>`_ contained in the `PyPA sample project <https://github.com/pypa/sampleproject>`_."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:164
msgid "name"
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:170
msgid "This is the name of your project, determining how your project is listed on :term:`PyPI <Python Package Index (PyPI)>`.  Per :pep:`508`, valid project names must:"
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:174
msgid "Consist only of ASCII letters, digits, underscores (``_``), hyphens (``-``), and/or periods (``.``), and"
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:176
msgid "Start & end with an ASCII letter or digit."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:178
msgid "Comparison of project names is case insensitive and treats arbitrarily-long runs of underscores, hyphens, and/or periods as equal.  For example, if you register a project named ``cool-stuff``, users will be able to download it or declare a dependency on it using any of the following spellings::"
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:190
#: ../source/specifications/binary-distribution-format.rst:127
msgid "version"
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:196
msgid "This is the current version of your project, allowing your users to determine whether or not they have the latest version, and to indicate which specific versions they've tested their own software against."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:200
msgid "Versions are displayed on :term:`PyPI <Python Package Index (PyPI)>` for each release if you publish your project."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:203
msgid "See :ref:`Choosing a versioning scheme` for more information on ways to use versions to convey compatibility information to your users."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:206
msgid "If the project code itself needs run-time access to the version, the simplest way is to keep the version in both :file:`setup.py` and your code. If you'd rather not duplicate the value, there are a few ways to manage this. See the \":ref:`Single sourcing the version`\" Advanced Topics section."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:214
msgid "description"
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:222
msgid "Give a short and long description for your project."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:224
msgid "These values will be displayed on :term:`PyPI <Python Package Index (PyPI)>` if you publish your project. On ``pypi.org``, the user interface displays ``description`` in the grey banner and ``long_description`` in the section named \"Project Description\"."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:229
msgid "``description`` is also displayed in lists of projects. For example, it's visible in the search results pages such as https://pypi.org/search/?q=jupyter, the front-page lists of trending projects and new releases, and the list of projects you maintain within your account profile (such as https://pypi.org/user/jaraco/)."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:235
msgid "A `content type <https://packaging.python.org/specifications/core-metadata/#description-content-type-optional>`_ can be specified with the ``long_description_content_type`` argument, which can be one of ``text/plain``, ``text/x-rst``, or ``text/markdown``, corresponding to no formatting, `reStructuredText (reST) <http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#reference-names>`_, and the Github-flavored Markdown dialect of `Markdown <https://daringfireball.net/projects/markdown/>`_ respectively."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:245
msgid "url"
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:252
msgid "Give a homepage URL for your project."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:256
msgid "author"
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:263
msgid "Provide details about the author."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:267
msgid "license"
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:273
msgid "The ``license`` argument doesn't have to indicate the license under which your package is being released, although you may optionally do so if you want.  If you're using a standard, well-known license, then your main indication can and should be via the ``classifiers`` argument. Classifiers exist for all major open-source licenses."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:279
msgid "The \"license\" argument is more typically used to indicate differences from well-known licenses, or to include your own, unique license. As a general rule, it's a good idea to use a standard, well-known license, both to avoid confusion and because some organizations avoid software whose license is unapproved."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:287
msgid "classifiers"
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:316
msgid "Provide a list of classifiers that categorize your project. For a full listing, see https://pypi.org/classifiers/."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:319
msgid "Although the list of classifiers is often used to declare what Python versions a project supports, this information is only used for searching & browsing projects on PyPI, not for installing projects.  To actually restrict what Python versions a project can be installed on, use the :ref:`python_requires` argument."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:327
msgid "keywords"
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:333
msgid "List keywords that describe your project."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:337
msgid "project_urls"
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:349
msgid "List additional relevant URLs about your project. This is the place to link to bug trackers, source repositories, or where to support package development. The string of the key is the exact text that will be displayed on PyPI."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:355
msgid "packages"
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:361
msgid "Set ``packages`` to a list of all :term:`packages <Import Package>` in your project, including their subpackages, sub-subpackages, etc.  Although the packages can be listed manually, ``setuptools.find_packages()`` finds them automatically.  Use the ``include`` keyword argument to find only the given packages.  Use the ``exclude`` keyword argument to omit packages that are not intended to be released and installed."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:370
msgid "py_modules"
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:376
msgid "If your project contains any single-file Python modules that aren't part of a package, set ``py_modules`` to a list of the names of the modules (minus the ``.py`` extension) in order to make :ref:`setuptools` aware of them."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:388
msgid "\"install_requires\" should be used to specify what dependencies a project minimally needs to run. When the project is installed by :ref:`pip`, this is the specification that is used to install its dependencies."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:392
msgid "For more on using \"install_requires\" see :ref:`install_requires vs Requirements files`."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:398
msgid "python_requires"
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:400
msgid "If your project only runs on certain Python versions, setting the ``python_requires`` argument to the appropriate :pep:`440` version specifier string will prevent :ref:`pip` from installing the project on other Python versions.  For example, if your package is for Python 3+ only, write::"
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:407
msgid "If your package is for Python 2.6, 2.7, and all versions of Python 3 starting with 3.3, write::"
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:412
msgid "And so on."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:416
msgid "Support for this feature is relatively recent.  Your project's source distributions and wheels (see :ref:`Packaging Your Project`) must be built using at least version 24.2.0 of :ref:`setuptools` in order for the ``python_requires`` argument to be recognized and the appropriate metadata generated."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:422
msgid "In addition, only versions 9.0.0 and higher of :ref:`pip` recognize the ``python_requires`` metadata.  Users with earlier versions of pip will be able to download & install projects on any Python version regardless of the projects' ``python_requires`` values."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:431
msgid "package_data"
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:440
msgid "Often, additional files need to be installed into a :term:`package <Import Package>`. These files are often data that’s closely related to the package’s implementation, or text files containing documentation that might be of interest to programmers using the package. These files are called \"package data\"."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:445
msgid "The value must be a mapping from package name to a list of relative path names that should be copied into the package. The paths are interpreted as relative to the directory containing the package."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:449
msgid "For more information, see :std:doc:`Including Data Files <setuptools:userguide/datafiles>` from the :std:doc:`setuptools docs <setuptools:index>`."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:457
msgid "data_files"
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:463
msgid "Although configuring :ref:`Package Data` is sufficient for most needs, in some cases you may need to place data files *outside* of your :term:`packages <Import Package>`.  The ``data_files`` directive allows you to do that. It is mostly useful if you need to install files which are used by other programs, which may be unaware of Python packages."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:469
msgid "Each ``(directory, files)`` pair in the sequence specifies the installation directory and the files to install there. The ``directory`` must be a relative path (although this may change in the future, see `wheel Issue #92 <https://github.com/pypa/wheel/issues/92>`_). and it is interpreted relative to the installation prefix (Python’s ``sys.prefix`` for a default installation; ``site.USER_BASE`` for a user installation). Each file name in ``files`` is interpreted relative to the :file:`setup.py` script at the top of the project source distribution."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:479
msgid "For more information see the distutils section on `Installing Additional Files <http://docs.python.org/3/distutils/setupscript.html#installing-additional-files>`_."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:484
msgid "When installing packages as egg, ``data_files`` is not supported. So, if your project uses :ref:`setuptools`, you must use ``pip`` to install it. Alternatively, if you must use ``python setup.py``, then you need to pass the ``--old-and-unmanageable`` option."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:491
msgid "scripts"
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:493
msgid "Although ``setup()`` supports a `scripts <http://docs.python.org/3/distutils/setupscript.html#installing-scripts>`_ keyword for pointing to pre-made scripts to install, the recommended approach to achieve cross-platform compatibility is to use :ref:`console_scripts` entry points (see below)."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:500
msgid "entry_points"
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:509
msgid "Use this keyword to specify any plugins that your project provides for any named entry points that may be defined by your project or others that you depend on."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:512
msgid "For more information, see the section on `Advertising Behavior <https://setuptools.readthedocs.io/en/latest/userguide/entry_point.html#dynamic-discovery-of-services-and-plugins>`_ from the :ref:`setuptools` docs."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:516
msgid "The most commonly used entry point is \"console_scripts\" (see below)."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:521
msgid "console_scripts"
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:531
msgid "Use \"console_script\" `entry points <https://setuptools.readthedocs.io/en/latest/setuptools.html#dynamic-discovery-of-services-and-plugins>`_ to register your script interfaces. You can then let the toolchain handle the work of turning these interfaces into actual scripts [2]_.  The scripts will be generated during the install of your :term:`distribution <Distribution Package>`."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:538
msgid "For more information, see `Automatic Script Creation <https://setuptools.readthedocs.io/en/latest/setuptools.html#automatic-script-creation>`_ from the `setuptools docs <https://setuptools.readthedocs.io>`_."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:545
msgid "Choosing a versioning scheme"
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:548
msgid "Standards compliance for interoperability"
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:550
msgid "Different Python projects may use different versioning schemes based on the needs of that particular project, but all of them are required to comply with the flexible :pep:`public version scheme <440#public-version-identifiers>` specified in :pep:`440` in order to be supported in tools and libraries like ``pip`` and ``setuptools``."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:556
msgid "Here are some examples of compliant version numbers::"
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:567
msgid "To further accommodate historical variations in approaches to version numbering, :pep:`440` also defines a comprehensive technique for :pep:`version normalisation <440#normalization>` that maps variant spellings of different version numbers to a standardised canonical form."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:573
msgid "Scheme choices"
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:576
msgid "Semantic versioning (preferred)"
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:578
msgid "For new projects, the recommended versioning scheme is based on `Semantic Versioning <http://semver.org>`_, but adopts a different approach to handling pre-releases and build metadata."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:582
msgid "The essence of semantic versioning is a 3-part MAJOR.MINOR.MAINTENANCE numbering scheme, where the project author increments:"
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:585
msgid "MAJOR version when they make incompatible API changes,"
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:586
msgid "MINOR version when they add functionality in a backwards-compatible manner, and"
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:587
msgid "MAINTENANCE version when they make backwards-compatible bug fixes."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:589
msgid "Adopting this approach as a project author allows users to make use of :pep:`\"compatible release\" <440#compatible-release>` specifiers, where ``name ~= X.Y`` requires at least release X.Y, but also allows any later release with a matching MAJOR version."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:594
msgid "Python projects adopting semantic versioning should abide by clauses 1-8 of the `Semantic Versioning 2.0.0 specification <http://semver.org>`_."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:598
msgid "Date based versioning"
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:600
msgid "Semantic versioning is not a suitable choice for all projects, such as those with a regular time based release cadence and a deprecation process that provides warnings for a number of releases prior to removal of a feature."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:604
msgid "A key advantage of date based versioning is that it is straightforward to tell how old the base feature set of a particular release is given just the version number."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:607
msgid "Version numbers for date based projects typically take the form of YEAR.MONTH (for example, ``12.04``, ``15.10``)."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:611
msgid "Serial versioning"
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:613
msgid "This is the simplest possible versioning scheme, and consists of a single number which is incremented every release."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:616
msgid "While serial versioning is very easy to manage as a developer, it is the hardest to track as an end user, as serial version numbers convey little or no information regarding API backwards compatibility."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:621
msgid "Hybrid schemes"
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:623
msgid "Combinations of the above schemes are possible. For example, a project may combine date based versioning with serial versioning to create a YEAR.SERIAL numbering scheme that readily conveys the approximate age of a release, but doesn't otherwise commit to a particular release cadence within the year."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:629
msgid "Pre-release versioning"
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:631
msgid "Regardless of the base versioning scheme, pre-releases for a given final release may be published as:"
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:634
msgid "zero or more dev releases (denoted with a \".devN\" suffix)"
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:635
msgid "zero or more alpha releases (denoted with a \".aN\" suffix)"
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:636
msgid "zero or more beta releases (denoted with a \".bN\" suffix)"
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:637
msgid "zero or more release candidates (denoted with a \".rcN\" suffix)"
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:639
msgid "``pip`` and other modern Python package installers ignore pre-releases by default when deciding which versions of dependencies to install."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:644
msgid "Local version identifiers"
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:646
msgid "Public version identifiers are designed to support distribution via :term:`PyPI <Python Package Index (PyPI)>`. Python's software distribution tools also support the notion of a :pep:`local version identifier <440#local-version-identifiers>`, which can be used to identify local development builds not intended for publication, or modified variants of a release maintained by a redistributor."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:653
msgid "A local version identifier takes the form ``<public version identifier>+<local version label>``. For example::"
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:661
msgid "Working in \"development mode\""
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:663
msgid "Although not required, it's common to locally install your project in \"editable\" or \"develop\" mode while you're working on it.  This allows your project to be both installed and editable in project form."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:667
msgid "Assuming you're in the root of your project directory, then run:"
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:674
msgid "Although somewhat cryptic, ``-e`` is short for ``--editable``, and ``.`` refers to the current working directory, so together, it means to install the current directory (i.e. your project) in editable mode.  This will also install any dependencies declared with \"install_requires\" and any scripts declared with \"console_scripts\".  Dependencies will be installed in the usual, non-editable mode."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:680
msgid "It's fairly common to also want to install some of your dependencies in editable mode as well. For example, supposing your project requires \"foo\" and \"bar\", but you want \"bar\" installed from VCS in editable mode, then you could construct a requirements file like so::"
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:688
msgid "The first line says to install your project and any dependencies. The second line overrides the \"bar\" dependency, such that it's fulfilled from VCS, not PyPI."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:692
msgid "If, however, you want \"bar\" installed from a local directory in editable mode, the requirements file should look like this, with the local paths at the top of the file::"
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:697
msgid "Otherwise, the dependency will be fulfilled from PyPI, due to the installation order of the requirements file.  For more on requirements files, see the :ref:`Requirements File <pip:Requirements Files>` section in the pip docs.  For more on VCS installs, see the :ref:`VCS Support <pip:VCS Support>` section of the pip docs."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:701
msgid "Lastly, if you don't want to install any dependencies at all, you can run::"
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:706
msgid "For more information, see the `Development Mode <https://setuptools.readthedocs.io/en/latest/setuptools.html#development-mode>`_ section of the `setuptools docs <https://setuptools.readthedocs.io>`_."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:713
msgid "Packaging your project"
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:715
msgid "To have your project installable from a :term:`Package Index` like :term:`PyPI <Python Package Index (PyPI)>`, you'll need to create a :term:`Distribution <Distribution Package>` (aka \":term:`Package <Distribution Package>`\") for your project."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:720
msgid "Before you can build wheels and sdists for your project, you'll need to install the ``build`` package:"
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:737
msgid "Source distributions"
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:739
msgid "Minimally, you should create a :term:`Source Distribution <Source Distribution (or \"sdist\")>`:"
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:755
msgid "A \"source distribution\" is unbuilt (i.e. it's not a :term:`Built Distribution`), and requires a build step when installed by pip.  Even if the distribution is pure Python (i.e. contains no extensions), it still involves a build step to build out the installation metadata from :file:`setup.py` and/or :file:`setup.cfg`."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:763
msgid "Wheels"
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:765
msgid "You should also create a wheel for your project. A wheel is a :term:`built package <Built Distribution>` that can be installed without needing to go through the \"build\" process. Installing wheels is substantially faster for the end user than installing from a source distribution."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:770
msgid "If your project is pure Python then you'll be creating a :ref:`\"Pure Python Wheel\" (see section below) <Pure Python Wheels>`."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:773
msgid "If your project contains compiled extensions, then you'll be creating what's called a :ref:`*Platform Wheel* (see section below) <Platform Wheels>`."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:776
msgid "If your project also supports Python 2 *and* contains no C extensions, then you should create what's called a *Universal Wheel* by adding the following to your :file:`setup.cfg` file:"
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:785
msgid "Only use this setting if your project does not have any C extensions *and* supports Python 2 and 3."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:792
msgid "Pure Python Wheels"
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:794
msgid "*Pure Python Wheels* contain no compiled extensions, and therefore only require a single Python wheel."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:797
#: ../source/guides/distributing-packages-using-setuptools.rst:826
msgid "To build the wheel:"
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:811
msgid "The ``wheel`` package will detect that the code is pure Python, and build a wheel that's named such that it's usable on any Python 3 installation.  For details on the naming of wheel files, see :pep:`425`."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:815
msgid "If you run ``build`` without ``--wheel`` or ``--sdist``, it will build both files for you; this is useful when you don't need multiple wheels."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:821
msgid "Platform Wheels"
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:823
msgid "*Platform Wheels* are wheels that are specific to a certain platform like Linux, macOS, or Windows, usually due to containing compiled extensions."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:841
msgid "The ``wheel`` package will detect that the code is not pure Python, and build a wheel that's named such that it's only usable on the platform that it was built on. For details on the naming of wheel files, see :pep:`425`."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:847
msgid ":term:`PyPI <Python Package Index (PyPI)>` currently supports uploads of platform wheels for Windows, macOS, and the multi-distro ``manylinux*`` ABI. Details of the latter are defined in :pep:`513`."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:855
msgid "Uploading your Project to PyPI"
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:857
msgid "When you ran the command to create your distribution, a new directory ``dist/`` was created under your project's root directory. That's where you'll find your distribution file(s) to upload."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:861
msgid "These files are only created when you run the command to create your distribution. This means that any time you change the source of your project or the configuration in your :file:`setup.py` file, you will need to rebuild these files again before you can distribute the changes to PyPI."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:866
msgid "Before releasing on main PyPI repo, you might prefer training with the `PyPI test site <https://test.pypi.org/>`_ which is cleaned on a semi regular basis. See :ref:`using-test-pypi` on how to setup your configuration in order to use it."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:871
msgid "In other resources you may encounter references to using ``python setup.py register`` and ``python setup.py upload``. These methods of registering and uploading a package are **strongly discouraged** as it may use a plaintext HTTP or unverified HTTPS connection on some Python versions, allowing your username and password to be intercepted during transmission."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:877
msgid "The reStructuredText parser used on PyPI is **not** Sphinx! Furthermore, to ensure safety of all users, certain kinds of URLs and directives are forbidden or stripped out (e.g., the ``.. raw::`` directive). **Before** trying to upload your distribution, you should check to see if your brief / long descriptions provided in :file:`setup.py` are valid.  You can do this by running :std:doc:`twine check <index>` on your package files::"
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:888
msgid "Create an account"
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:890
msgid "First, you need a :term:`PyPI <Python Package Index (PyPI)>` user account. You can create an account `using the form on the PyPI website <https://pypi.org/account/register/>`_."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:894
msgid "Now you'll create a PyPI `API token`_ so you will be able to securely upload your project."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:897
msgid "Go to https://pypi.org/manage/account/#api-tokens and create a new `API token`_; don't limit its scope to a particular project, since you are creating a new project."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:901
msgid "**Don't close the page until you have copied and saved the token — you won't see that token again.**"
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:904
msgid "To avoid having to copy and paste the token every time you upload, you can create a :file:`$HOME/.pypirc` file:"
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:913
msgid "**Be aware that this stores your token in plaintext.**"
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:915
#: ../source/guides/migrating-to-pypi-org.rst:70
#: ../source/guides/migrating-to-pypi-org.rst:109
#: ../source/guides/using-testpypi.rst:83
msgid "For more details, see the :ref:`specification <pypirc>` for :file:`.pypirc`."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:921
msgid "Upload your distributions"
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:923
msgid "Once you have an account you can upload your distributions to :term:`PyPI <Python Package Index (PyPI)>` using :ref:`twine`."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:926
msgid "The process for uploading a release is the same regardless of whether or not the project already exists on PyPI - if it doesn't exist yet, it will be automatically created when the first release is uploaded."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:930
msgid "For the second and subsequent releases, PyPI only requires that the version number of the new release differ from any previous releases."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:937
msgid "You can see if your package has successfully uploaded by navigating to the URL ``https://pypi.org/project/<sampleproject>`` where ``sampleproject`` is the name of your project that you uploaded. It may take a minute or two for your project to appear on the site."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:944
#: ../source/tutorials/installing-packages.rst:663
msgid "Depending on your platform, this may require root or Administrator access. :ref:`pip` is currently considering changing this by `making user installs the default behavior <https://github.com/pypa/pip/issues/1668>`_."
msgstr ""

#: ../source/guides/distributing-packages-using-setuptools.rst:950
msgid "Specifically, the \"console_script\" approach generates ``.exe`` files on Windows, which are necessary because the OS special-cases ``.exe`` files. Script-execution features like ``PATHEXT`` and the :pep:`Python Launcher for Windows <397>` allow scripts to be used in many cases, but not all."
msgstr ""

#: ../source/guides/dropping-older-python-versions.rst:5
msgid "Dropping support for older Python versions"
msgstr ""

#: ../source/guides/dropping-older-python-versions.rst:7
msgid "Dropping support for older Python versions is supported by the standard :ref:`core-metadata` 1.2 specification via a \"Requires-Python\" attribute."
msgstr ""

#: ../source/guides/dropping-older-python-versions.rst:9
msgid "Metadata 1.2+ clients, such as Pip 9.0+, will adhere to this specification by matching the current Python runtime and comparing it with the required version in the package metadata. If they do not match, it will attempt to install the last package distribution that supported that Python runtime."
msgstr ""

#: ../source/guides/dropping-older-python-versions.rst:12
msgid "This mechanism can be used to drop support for older Python versions, by amending the \"Requires-Python\" attribute in the package metadata."
msgstr ""

#: ../source/guides/dropping-older-python-versions.rst:14
msgid "This guide is specifically for users of :ref:`setuptools`, other packaging tools such as ``flit`` may offer similar functionality but users will need to consult relevant documentation."
msgstr ""

#: ../source/guides/dropping-older-python-versions.rst:17
msgid "Requirements"
msgstr ""

#: ../source/guides/dropping-older-python-versions.rst:19
msgid "This workflow requires that:"
msgstr ""

#: ../source/guides/dropping-older-python-versions.rst:21
msgid "The publisher is using the latest version of :ref:`setuptools`,"
msgstr ""

#: ../source/guides/dropping-older-python-versions.rst:22
msgid "The latest version of :ref:`twine` is used to upload the package,"
msgstr ""

#: ../source/guides/dropping-older-python-versions.rst:23
msgid "The user installing the package has at least Pip 9.0, or a client that supports the Metadata 1.2 specification."
msgstr ""

#: ../source/guides/dropping-older-python-versions.rst:26
msgid "Dealing with the universal wheels"
msgstr ""

#: ../source/guides/dropping-older-python-versions.rst:28
msgid "Traditionally, projects providing Python code that is semantically compatible with both Python 2 and Python 3, produce :term:`wheels <Wheel>` that have a ``py2.py3`` tag in their names. When dropping support for Python 2, it is important not to forget to change this tag to just ``py3``. It is often configured within :file:`setup.cfg` under the ``[bdist_wheel]`` section by setting ``universal = 1`` if they use setuptools."
msgstr ""

#: ../source/guides/dropping-older-python-versions.rst:36
msgid "If you use this method, either remove this option or section, or explicitly set ``universal`` to ``0``:"
msgstr ""

#: ../source/guides/dropping-older-python-versions.rst:48
msgid "Since it is possible to override the :file:`setup.cfg` settings via CLI flags, make sure that your scripts don't have ``--universal`` in your package creation scripts."
msgstr ""

#: ../source/guides/dropping-older-python-versions.rst:53
msgid "Defining the Python version required"
msgstr ""

#: ../source/guides/dropping-older-python-versions.rst:56
msgid "1. Download the newest version of Setuptools"
msgstr ""

#: ../source/guides/dropping-older-python-versions.rst:58
msgid "Ensure that before you generate source distributions or binary distributions, you update Setuptools and install twine."
msgstr ""

#: ../source/guides/dropping-older-python-versions.rst:60
msgid "Steps:"
msgstr ""

#: ../source/guides/dropping-older-python-versions.rst:74
msgid "`setuptools` version should be above 24.0.0."
msgstr ""

#: ../source/guides/dropping-older-python-versions.rst:77
msgid "2. Specify the version ranges for supported Python distributions"
msgstr ""

#: ../source/guides/dropping-older-python-versions.rst:79
msgid "You can specify version ranges and exclusion rules, such as at least Python 3. Or, Python 2.7, 3.4 and beyond."
msgstr ""

#: ../source/guides/dropping-older-python-versions.rst:81
#: ../source/specifications/core-metadata.rst:139
#: ../source/specifications/core-metadata.rst:463
#: ../source/specifications/core-metadata.rst:487
#: ../source/specifications/core-metadata.rst:527
#: ../source/specifications/core-metadata.rst:550
#: ../source/specifications/core-metadata.rst:583
#: ../source/specifications/core-metadata.rst:693
#: ../source/specifications/core-metadata.rst:722
msgid "Examples::"
msgstr ""

#: ../source/guides/dropping-older-python-versions.rst:86
msgid "The way to set those values is within the call to ``setup`` within your :file:`setup.py` script. This will insert the ``Requires-Python`` metadata values based on the argument you provide in ``python_requires``."
msgstr ""

#: ../source/guides/dropping-older-python-versions.rst:101
msgid "3. Validating the Metadata before publishing"
msgstr ""

#: ../source/guides/dropping-older-python-versions.rst:103
msgid "Within a Python source package (the zip or the tar-gz file you download) is a text file called PKG-INFO."
msgstr ""

#: ../source/guides/dropping-older-python-versions.rst:105
msgid "This file is generated by Distutils or :ref:`setuptools` when it generates the source package. The file contains a set of keys and values, the list of keys is part of the PyPa standard metadata format."
msgstr ""

#: ../source/guides/dropping-older-python-versions.rst:108
msgid "You can see the contents of the generated file like this::"
msgstr ""

#: ../source/guides/dropping-older-python-versions.rst:112
msgid "Validate that the following is in place, before publishing the package:"
msgstr ""

#: ../source/guides/dropping-older-python-versions.rst:114
msgid "If you have upgraded correctly, the Metadata-Version value should be 1.2 or higher."
msgstr ""

#: ../source/guides/dropping-older-python-versions.rst:115
msgid "The Requires-Python field is set and matches your specification in setup.py."
msgstr ""

#: ../source/guides/dropping-older-python-versions.rst:118
msgid "4. Using Twine to publish"
msgstr ""

#: ../source/guides/dropping-older-python-versions.rst:120
msgid "Twine has a number of advantages, apart from being faster it is now the supported method for publishing packages."
msgstr ""

#: ../source/guides/dropping-older-python-versions.rst:122
msgid "Make sure you are using the newest version of Twine, at least 1.9."
msgstr ""

#: ../source/guides/dropping-older-python-versions.rst:125
msgid "Dropping a Python release"
msgstr ""

#: ../source/guides/dropping-older-python-versions.rst:127
msgid "Once you have published a package with the Requires-Python metadata, you can then make a further update removing that Python runtime from support."
msgstr ""

#: ../source/guides/dropping-older-python-versions.rst:129
msgid "It must be done in this order for the automated fallback to work."
msgstr ""

#: ../source/guides/dropping-older-python-versions.rst:131
msgid "For example, you published the Requires-Python: \">=2.7\" as version 1.0.0 of your package."
msgstr ""

#: ../source/guides/dropping-older-python-versions.rst:133
msgid "If you were then to update the version string to \">=3.5\", and publish a new version 2.0.0 of your package, any users running Pip 9.0+ from version 2.7 will have version 1.0.0 of the package installed, and any >=3.5 users will receive version 2.0.0."
msgstr ""

#: ../source/guides/hosting-your-own-index.rst:5
msgid "Hosting your own simple repository"
msgstr ""

#: ../source/guides/hosting-your-own-index.rst:8
msgid "If you wish to host your own simple repository [1]_, you can either use a software package like `devpi`_ or you can use simply create the proper directory structure and use any web server that can serve static files and generate an autoindex."
msgstr ""

#: ../source/guides/hosting-your-own-index.rst:13
msgid "In either case, since you'll be hosting a repository that is likely not in your user's default repositories, you should instruct them in your project's description to configure their installer appropriately. For example with pip:"
msgstr ""

#: ../source/guides/hosting-your-own-index.rst:29
msgid "In addition, it is **highly** recommended that you serve your repository with valid HTTPS. At this time, the security of your user's installations depends on all repositories using a valid HTTPS setup."
msgstr ""

#: ../source/guides/hosting-your-own-index.rst:35
msgid "\"Manual\" repository"
msgstr ""

#: ../source/guides/hosting-your-own-index.rst:37
msgid "The directory layout is fairly simple, within a root directory you need to create a directory for each project. This directory should be the normalized name (as defined by :pep:`503`) of the project. Within each of these directories simply place each of the downloadable files. If you have the projects \"Foo\" (with the versions 1.0 and 2.0) and \"bar\" (with the version 0.1) You should end up with a structure that looks like::"
msgstr ""

#: ../source/guides/hosting-your-own-index.rst:51
msgid "Once you have this layout, simply configure your webserver to serve the root directory with autoindex enabled. For an example using the built in Web server in `Twisted`_, you would simply run ``twistd -n web --path .`` and then instruct users to add the URL to their installer's configuration."
msgstr ""

#: ../source/guides/hosting-your-own-index.rst:58
msgid "For complete documentation of the simple repository protocol, see :pep:`503`."
msgstr ""

#: ../source/guides/index.rst:8
#: ../source/guides/index.rst:8
msgid "Installing Packages:"
msgstr ""

#: ../source/guides/index.rst:20
#: ../source/guides/index.rst:20
msgid "Building and Publishing Projects:"
msgstr ""

#: ../source/guides/index.rst:38
#: ../source/guides/index.rst:38
msgid "Miscellaneous:"
msgstr ""

#: ../source/guides/index.rst:4
msgid "**Guides** are focused on accomplishing a specific task and assume that you are already familiar with the basics of Python packaging. If you're looking for an introduction to packaging, see :doc:`/tutorials/index`."
msgstr ""

#: ../source/guides/index-mirrors-and-caches.rst:5
msgid "Package index mirrors and caches"
msgstr ""

#: ../source/guides/index-mirrors-and-caches.rst:8
#: ../source/guides/supporting-multiple-python-versions.rst:8
msgid "2014-12-24"
msgstr ""

#: ../source/guides/index-mirrors-and-caches.rst:14
msgid "Mirroring or caching of PyPI can be used to speed up local package installation, allow offline work, handle corporate firewalls or just plain Internet flakiness."
msgstr ""

#: ../source/guides/index-mirrors-and-caches.rst:17
msgid "Three options are available in this area:"
msgstr ""

#: ../source/guides/index-mirrors-and-caches.rst:19
msgid "pip provides local caching options,"
msgstr ""

#: ../source/guides/index-mirrors-and-caches.rst:20
msgid "devpi provides higher-level caching option, potentially shared amongst many users or machines, and"
msgstr ""

#: ../source/guides/index-mirrors-and-caches.rst:22
msgid "bandersnatch provides a local complete mirror of all PyPI :term:`packages <Distribution Package>`."
msgstr ""

#: ../source/guides/index-mirrors-and-caches.rst:27
msgid "Caching with pip"
msgstr ""

#: ../source/guides/index-mirrors-and-caches.rst:29
msgid "pip provides a number of facilities for speeding up installation by using local cached copies of :term:`packages <Distribution Package>`:"
msgstr ""

#: ../source/guides/index-mirrors-and-caches.rst:32
msgid "`Fast & local installs <https://pip.pypa.io/en/latest/user_guide/#installing-from-local-packages>`_ by downloading all the requirements for a project and then pointing pip at those downloaded files instead of going to PyPI."
msgstr ""

#: ../source/guides/index-mirrors-and-caches.rst:36
msgid "A variation on the above which pre-builds the installation files for the requirements using `python -m pip wheel <https://pip.readthedocs.io/en/latest/reference/pip_wheel.html>`_::"
msgstr ""

#: ../source/guides/index-mirrors-and-caches.rst:45
msgid "Caching with devpi"
msgstr ""

#: ../source/guides/index-mirrors-and-caches.rst:47
msgid "devpi is a caching proxy server which you run on your laptop, or some other machine you know will always be available to you. See the `devpi documentation for getting started`__."
msgstr ""

#: ../source/guides/index-mirrors-and-caches.rst:55
msgid "Complete mirror with bandersnatch"
msgstr ""

#: ../source/guides/index-mirrors-and-caches.rst:57
msgid "bandersnatch will set up a complete local mirror of all PyPI :term:`packages <Distribution Package>` (externally-hosted packages are not mirrored). See the `bandersnatch documentation for getting that going`__."
msgstr ""

#: ../source/guides/index-mirrors-and-caches.rst:63
msgid "A benefit of devpi is that it will create a mirror which includes :term:`packages <Distribution Package>` that are external to PyPI, unlike bandersnatch which will only cache :term:`packages <Distribution Package>` hosted on PyPI."
msgstr ""

#: ../source/guides/installing-scientific-packages.rst:5
msgid "Installing scientific packages"
msgstr ""

#: ../source/guides/installing-scientific-packages.rst:11
msgid "Scientific software tends to have more complex dependencies than most, and it will often have multiple build options to take advantage of different kinds of hardware, or to interoperate with different pieces of external software."
msgstr ""

#: ../source/guides/installing-scientific-packages.rst:16
msgid "In particular, `NumPy <http://www.numpy.org/>`__, which provides the basis for most of the software in the `scientific Python stack <http://www.scipy.org/stackspec.html#stackspec>`__ can be configured to interoperate with different FORTRAN libraries, and can take advantage of different levels of vectorised instructions available in modern CPUs."
msgstr ""

#: ../source/guides/installing-scientific-packages.rst:22
msgid "Starting with version 1.10.4 of NumPy and version 1.0.0 of SciPy, pre-built 32-bit and 64-bit binaries in the ``wheel`` format are available for all major operating systems (Windows, macOS, and Linux) on PyPI. Note, however, that on Windows, NumPy binaries are linked against the `ATLAS <http://www.netlib.org/atlas/>`__ BLAS/LAPACK library, restricted to SSE2 instructions, so they may not provide optimal linear algebra performance."
msgstr ""

#: ../source/guides/installing-scientific-packages.rst:29
msgid "There are a number of alternative options for obtaining scientific Python libraries (or any other Python libraries that require a compilation environment to install from source and don't provide pre-built wheel files on PyPI)."
msgstr ""

#: ../source/guides/installing-scientific-packages.rst:35
msgid "Building from source"
msgstr ""

#: ../source/guides/installing-scientific-packages.rst:37
msgid "The same complexity which makes it difficult to distribute NumPy (and many of the projects that depend on it) as wheel files also make them difficult to build from source yourself. However, for intrepid folks that are willing to spend the time wrangling compilers and linkers for both C and FORTRAN, building from source is always an option."
msgstr ""

#: ../source/guides/installing-scientific-packages.rst:45
msgid "Linux distribution packages"
msgstr ""

#: ../source/guides/installing-scientific-packages.rst:47
msgid "For Linux users, the system package manager will often have pre-compiled versions of various pieces of scientific software, including NumPy and other parts of the scientific Python stack."
msgstr ""

#: ../source/guides/installing-scientific-packages.rst:51
msgid "If using versions which may be several months old is acceptable, then this is likely to be a good option (just make sure to allow access to distributions installed into the system Python when using virtual environments)."
msgstr ""

#: ../source/guides/installing-scientific-packages.rst:57
msgid "Windows installers"
msgstr ""

#: ../source/guides/installing-scientific-packages.rst:59
msgid "Many Python projects that don't (or can't) currently publish wheel files at least publish Windows installers, either on PyPI or on their project download page. Using these installers allows users to avoid the need to set up a suitable environment to build extensions locally."
msgstr ""

#: ../source/guides/installing-scientific-packages.rst:64
msgid "The extensions provided in these installers are typically compatible with the CPython Windows installers published on python.org."
msgstr ""

#: ../source/guides/installing-scientific-packages.rst:67
msgid "For projects which don't provide their own Windows installers (and even some which do), Christoph Gohlke at the University of California provides a `collection of Windows installers <http://www.lfd.uci.edu/~gohlke/pythonlibs/>`__. Many Python users on Windows have reported a positive experience with these prebuilt versions."
msgstr ""

#: ../source/guides/installing-scientific-packages.rst:73
msgid "As with Linux system packages, the Windows installers will only install into a system Python installation - they do not support installation in virtual environments. Allowing access to distributions installed into the system Python when using virtual environments is a common approach to working around this limitation."
msgstr ""

#: ../source/guides/installing-scientific-packages.rst:79
msgid "The :term:`Wheel` project also provides a :command:`wheel convert` subcommand that can convert a Windows :command:`bdist_wininst` installer to a wheel."
msgstr ""

#: ../source/guides/installing-scientific-packages.rst:86
msgid "macOS installers and package managers"
msgstr ""

#: ../source/guides/installing-scientific-packages.rst:88
msgid "Similar to the situation on Windows, many projects (including NumPy) publish macOS installers that are compatible with the macOS CPython binaries published on python.org."
msgstr ""

#: ../source/guides/installing-scientific-packages.rst:92
msgid "macOS users also have access to Linux distribution style package managers such as ``MacPorts``. The SciPy site has more details on using MacPorts to install the `scientific Python stack <http://www.scipy.org/install.html#mac-packages>`__"
msgstr ""

#: ../source/guides/installing-scientific-packages.rst:99
msgid "SciPy distributions"
msgstr ""

#: ../source/guides/installing-scientific-packages.rst:101
msgid "The SciPy site lists `several distributions <http://www.scipy.org/install.html>`__ that provide the full SciPy stack to end users in an easy to use and update format."
msgstr ""

#: ../source/guides/installing-scientific-packages.rst:105
msgid "Some of these distributions may not be compatible with the standard ``pip`` and ``virtualenv`` based toolchain."
msgstr ""

#: ../source/guides/installing-scientific-packages.rst:109
#: ../source/key_projects.rst:596
msgid "Spack"
msgstr ""

#: ../source/guides/installing-scientific-packages.rst:110
msgid "`Spack <https://github.com/LLNL/spack/>`_ is a flexible package manager designed to support multiple versions, configurations, platforms, and compilers. It was built to support the needs of large supercomputing centers and scientific application teams, who must often build software many different ways. Spack is not limited to Python; it can install packages for ``C``, ``C++``, ``Fortran``, ``R``, and other languages.  It is non-destructive; installing a new version of one package does not break existing installations, so many configurations can coexist on the same system."
msgstr ""

#: ../source/guides/installing-scientific-packages.rst:119
msgid "Spack offers a simple but powerful syntax that allows users to specify versions and configuration options concisely. Package files are written in pure Python, and they are templated so that it is easy to swap compilers, dependency implementations (like MPI), versions, and build options with a single package file.  Spack also generates *module* files so that packages can be loaded and unloaded from the user's environment."
msgstr ""

#: ../source/guides/installing-scientific-packages.rst:128
msgid "The conda cross-platform package manager"
msgstr ""

#: ../source/guides/installing-scientific-packages.rst:130
msgid "`Anaconda <https://www.anaconda.com/download/>`_ is a Python distribution published by Anaconda, Inc. It is a stable collection of Open Source packages for big data and scientific use.  As of the 5.0 release of Anaconda, about 200 packages are installed by default, and a total of 400-500 can be installed and updated from the Anaconda repository."
msgstr ""

#: ../source/guides/installing-scientific-packages.rst:136
msgid "``conda`` is an open source (BSD licensed) package management system and environment management system included in Anaconda that allows users to install multiple versions of binary software packages and their dependencies, and easily switch between them. It is a cross-platform tool working on Windows, macOS, and Linux. Conda can be used to package up and distribute all kinds of packages, it is not limited to just Python packages. It has full support for native virtual environments. Conda makes environments first-class citizens, making it easy to create independent environments even for C libraries. It is written in Python, but is Python-agnostic. Conda manages Python itself as a package, so that :command:`conda update python` is possible, in contrast to pip, which only manages Python packages. Conda is available in Anaconda and Miniconda (an easy-to-install download with just Python and conda)."
msgstr ""

#: ../source/guides/installing-stand-alone-command-line-tools.rst:2
msgid "Installing stand alone command line tools"
msgstr ""

#: ../source/guides/installing-stand-alone-command-line-tools.rst:4
msgid "Many packages have command line entry points. Examples of this type of application are `mypy <https://github.com/python/mypy>`_, `flake8 <https://github.com/PyCQA/flake8>`_, :ref:`pipenv`,and `black <https://github.com/ambv/black>`_."
msgstr ""

#: ../source/guides/installing-stand-alone-command-line-tools.rst:10
msgid "Usually you want to be able to access these from anywhere, but installing packages and their dependencies to the same global environment can cause version conflicts and break dependencies the operating system has on Python packages."
msgstr ""

#: ../source/guides/installing-stand-alone-command-line-tools.rst:15
msgid ":ref:`pipx` solves this by creating a virtual environment for each package, while also ensuring that package's applications are accessible through a directory that is on your ``$PATH``. This allows each package to be upgraded or uninstalled without causing conflicts with other packages, and allows you to safely run the program from anywhere."
msgstr ""

#: ../source/guides/installing-stand-alone-command-line-tools.rst:21
msgid "pipx only works with Python 3.6+."
msgstr ""

#: ../source/guides/installing-stand-alone-command-line-tools.rst:23
msgid "``pipx`` is installed with ``pip``:"
msgstr ""

#: ../source/guides/installing-stand-alone-command-line-tools.rst:30
msgid "You may need to restart your terminal for the path updates to take effect."
msgstr ""

#: ../source/guides/installing-stand-alone-command-line-tools.rst:32
msgid "Now you can install packages with ``pipx install`` and access the package's entry point(s) from anywhere."
msgstr ""

#: ../source/guides/installing-stand-alone-command-line-tools.rst:39
#: ../source/guides/installing-stand-alone-command-line-tools.rst:100
msgid "For example"
msgstr ""

#: ../source/guides/installing-stand-alone-command-line-tools.rst:59
msgid "To see a list of packages installed with pipx and which CLI applications are available, use ``pipx list``."
msgstr ""

#: ../source/guides/installing-stand-alone-command-line-tools.rst:79
msgid "To upgrade or uninstall the package"
msgstr ""

#: ../source/guides/installing-stand-alone-command-line-tools.rst:86
msgid "``pipx`` can be upgraded or uninstalled with pip"
msgstr ""

#: ../source/guides/installing-stand-alone-command-line-tools.rst:93
msgid "``pipx`` also allows you to install and run the latest version of a cli tool in a temporary, ephemeral environment."
msgstr ""

#: ../source/guides/installing-stand-alone-command-line-tools.rst:106
msgid "To see the full list of commands ``pipx`` offers, run"
msgstr ""

#: ../source/guides/installing-stand-alone-command-line-tools.rst:112
msgid "You can learn more about ``pipx`` at its homepage, https://github.com/pypa/pipx."
msgstr ""

#: ../source/guides/installing-using-linux-tools.rst:5
msgid "Installing pip/setuptools/wheel with Linux Package Managers"
msgstr ""

#: ../source/guides/installing-using-linux-tools.rst:8
msgid "2015-09-17"
msgstr ""

#: ../source/guides/installing-using-linux-tools.rst:11
msgid "This section covers how to install :ref:`pip`, :ref:`setuptools`, and :ref:`wheel` using Linux package managers."
msgstr ""

#: ../source/guides/installing-using-linux-tools.rst:14
msgid "If you're using a Python that was downloaded from `python.org <https://www.python.org>`_, then this section does not apply.  See the :ref:`installing_requirements` section instead."
msgstr ""

#: ../source/guides/installing-using-linux-tools.rst:18
msgid "Note that it's common for the versions of :ref:`pip`, :ref:`setuptools`, and :ref:`wheel` supported by a specific Linux Distribution to be outdated by the time it's released to the public, and updates generally only occur for security reasons, not for feature updates.  For certain Distributions, there are additional repositories that can be enabled to provide newer versions.  The repositories we know about are explained below."
msgstr ""

#: ../source/guides/installing-using-linux-tools.rst:25
msgid "Also note that it's somewhat common for Distributions to apply patches for the sake of security and normalization to their own standards.  In some cases, this can lead to bugs or unexpected behaviors that vary from the original unpatched versions.  When this is known, we will make note of it below."
msgstr ""

#: ../source/guides/installing-using-linux-tools.rst:32
msgid "Fedora"
msgstr ""

#: ../source/guides/installing-using-linux-tools.rst:34
msgid "Fedora 21:"
msgstr ""

#: ../source/guides/installing-using-linux-tools.rst:36
#: ../source/guides/installing-using-linux-tools.rst:45
#: ../source/guides/installing-using-linux-tools.rst:124
#: ../source/guides/installing-using-linux-tools.rst:138
#: ../source/guides/installing-using-linux-tools.rst:158
msgid "Python 2::"
msgstr ""

#: ../source/guides/installing-using-linux-tools.rst:41
msgid "Python 3: ``sudo yum install python3 python3-wheel``"
msgstr ""

#: ../source/guides/installing-using-linux-tools.rst:43
msgid "Fedora 22:"
msgstr ""

#: ../source/guides/installing-using-linux-tools.rst:50
msgid "Python 3: ``sudo dnf install python3 python3-wheel``"
msgstr ""

#: ../source/guides/installing-using-linux-tools.rst:53
msgid "To get newer versions of pip, setuptools, and wheel for Python 2, you can enable the `PyPA Copr Repo <https://copr.fedoraproject.org/coprs/pypa/pypa/>`_ using the `Copr Repo instructions <https://fedorahosted.org/copr/wiki/HowToEnableRepo>`__, and then run::"
msgstr ""

#: ../source/guides/installing-using-linux-tools.rst:63
msgid "CentOS/RHEL"
msgstr ""

#: ../source/guides/installing-using-linux-tools.rst:65
msgid "CentOS and RHEL don't offer :ref:`pip` or :ref:`wheel` in their core repositories, although :ref:`setuptools` is installed by default."
msgstr ""

#: ../source/guides/installing-using-linux-tools.rst:68
msgid "To install pip and wheel for the system Python, there are two options:"
msgstr ""

#: ../source/guides/installing-using-linux-tools.rst:70
msgid "Enable the `EPEL repository <https://fedoraproject.org/wiki/EPEL>`_ using `these instructions <https://fedoraproject.org/wiki/EPEL#How_can_I_use_these_extra_packages.3F>`__. On EPEL 6 and EPEL7, you can install pip like so::"
msgstr ""

#: ../source/guides/installing-using-linux-tools.rst:77
msgid "On EPEL 7 (but not EPEL 6), you can install wheel like so::"
msgstr ""

#: ../source/guides/installing-using-linux-tools.rst:81
msgid "Since EPEL only offers extra, non-conflicting packages, EPEL does not offer setuptools, since it's in the core repository."
msgstr ""

#: ../source/guides/installing-using-linux-tools.rst:85
msgid "Enable the `PyPA Copr Repo <https://copr.fedoraproject.org/coprs/pypa/pypa/>`_ using `these instructions <https://fedorahosted.org/copr/wiki/HowToEnableRepo>`__ [1]_. You can install pip and wheel like so::"
msgstr ""

#: ../source/guides/installing-using-linux-tools.rst:92
msgid "To additionally upgrade setuptools, run::"
msgstr ""

#: ../source/guides/installing-using-linux-tools.rst:97
msgid "To install pip, wheel, and setuptools, in a parallel, non-system environment (using yum) then there are two options:"
msgstr ""

#: ../source/guides/installing-using-linux-tools.rst:101
msgid "Use the \"Software Collections\" feature to enable a parallel collection that includes pip, setuptools, and wheel."
msgstr ""

#: ../source/guides/installing-using-linux-tools.rst:104
msgid "For Redhat, see here: http://developers.redhat.com/products/softwarecollections/overview/"
msgstr ""

#: ../source/guides/installing-using-linux-tools.rst:106
msgid "For CentOS, see here: https://www.softwarecollections.org/en/"
msgstr ""

#: ../source/guides/installing-using-linux-tools.rst:108
msgid "Be aware that collections may not contain the most recent versions."
msgstr ""

#: ../source/guides/installing-using-linux-tools.rst:110
msgid "Enable the `IUS repository <https://ius.io/GettingStarted/>`_ and install one of the `parallel-installable <https://ius.io/SafeRepo/#parallel-installable-package>`_ Pythons, along with pip, setuptools, and wheel, which are kept fairly up to date."
msgstr ""

#: ../source/guides/installing-using-linux-tools.rst:116
msgid "For example, for Python 3.4 on CentOS7/RHEL7::"
msgstr ""

#: ../source/guides/installing-using-linux-tools.rst:122
msgid "openSUSE"
msgstr ""

#: ../source/guides/installing-using-linux-tools.rst:129
#: ../source/guides/installing-using-linux-tools.rst:143
#: ../source/guides/installing-using-linux-tools.rst:162
msgid "Python 3::"
msgstr ""

#: ../source/guides/installing-using-linux-tools.rst:135
msgid "Debian/Ubuntu"
msgstr ""

#: ../source/guides/installing-using-linux-tools.rst:150
msgid "Recent Debian/Ubuntu versions have modified pip to use the `\"User Scheme\" <https://pip.pypa.io/en/stable/user_guide/#user-installs>`_ by default, which is a significant behavior change that can be surprising to some users."
msgstr ""

#: ../source/guides/installing-using-linux-tools.rst:156
msgid "Arch Linux"
msgstr ""

#: ../source/guides/installing-using-linux-tools.rst:168
msgid "Currently, there is no \"copr\" yum plugin available for CentOS/RHEL, so the only option is to manually place the repo files as described."
msgstr ""

#: ../source/guides/installing-using-pip-and-virtual-environments.rst:2
msgid "Installing packages using pip and virtual environments"
msgstr ""

#: ../source/guides/installing-using-pip-and-virtual-environments.rst:4
msgid "This guide discusses how to install packages using :ref:`pip` and a virtual environment manager: either :ref:`venv` for Python 3 or :ref:`virtualenv` for Python 2. These are the lowest-level tools for managing Python packages and are recommended if higher-level tools do not suit your needs."
msgstr ""

#: ../source/guides/installing-using-pip-and-virtual-environments.rst:9
msgid "This doc uses the term **package** to refer to a :term:`Distribution Package`  which is different from an :term:`Import Package` that which is used to import modules in your Python source code."
msgstr ""

#: ../source/guides/installing-using-pip-and-virtual-environments.rst:15
msgid "Installing pip"
msgstr ""

#: ../source/guides/installing-using-pip-and-virtual-environments.rst:17
msgid ":ref:`pip` is the reference Python package manager. It's used to install and update packages. You'll need to make sure you have the latest version of pip installed."
msgstr ""

#: ../source/guides/installing-using-pip-and-virtual-environments.rst:24
msgid "Debian and most other distributions include a `python-pip`_ package, if you want to use the Linux distribution-provided versions of pip see :doc:`/guides/installing-using-linux-tools`."
msgstr ""

#: ../source/guides/installing-using-pip-and-virtual-environments.rst:28
msgid "You can also install pip yourself to ensure you have the latest version. It's recommended to use the system pip to bootstrap a user installation of pip:"
msgstr ""

#: ../source/guides/installing-using-pip-and-virtual-environments.rst:35
msgid "Afterwards, you should have the newest pip installed in your user site:"
msgstr ""

#: ../source/guides/installing-using-pip-and-virtual-environments.rst:46
msgid "The Python installers for Windows include pip. You should be able to access pip using:"
msgstr ""

#: ../source/guides/installing-using-pip-and-virtual-environments.rst:54
msgid "You can make sure that pip is up-to-date by running:"
msgstr ""

#: ../source/guides/installing-using-pip-and-virtual-environments.rst:62
msgid "Installing virtualenv"
msgstr ""

#: ../source/guides/installing-using-pip-and-virtual-environments.rst:64
msgid "If you are using Python 3.3 or newer, the :mod:`venv` module is the preferred way to create and manage virtual environments. venv is included in the Python standard library and requires no additional installation. If you are using venv, you may skip this section."
msgstr ""

#: ../source/guides/installing-using-pip-and-virtual-environments.rst:70
msgid ":ref:`virtualenv` is used to manage Python packages for different projects. Using virtualenv allows you to avoid installing Python packages globally which could break system tools or other projects. You can install virtualenv using pip."
msgstr ""

#: ../source/guides/installing-using-pip-and-virtual-environments.rst:91
msgid "Creating a virtual environment"
msgstr ""

#: ../source/guides/installing-using-pip-and-virtual-environments.rst:93
msgid ":ref:`venv` (for Python 3) and :ref:`virtualenv` (for Python 2) allow you to manage separate package installations for different projects. They essentially allow you to create a \"virtual\" isolated Python installation and install packages into that virtual installation. When you switch projects, you can simply create a new virtual environment and not have to worry about breaking the packages installed in the other environments. It is always recommended to use a virtual environment while developing Python applications."
msgstr ""

#: ../source/guides/installing-using-pip-and-virtual-environments.rst:102
msgid "To create a virtual environment, go to your project's directory and run venv. If you are using Python 2, replace ``venv`` with ``virtualenv`` in the below commands."
msgstr ""

#: ../source/guides/installing-using-pip-and-virtual-environments.rst:118
msgid "The second argument is the location to create the virtual environment. Generally, you can just create this in your project and call it ``env``."
msgstr ""

#: ../source/guides/installing-using-pip-and-virtual-environments.rst:121
msgid "venv will create a virtual Python installation in the ``env`` folder."
msgstr ""

#: ../source/guides/installing-using-pip-and-virtual-environments.rst:123
msgid "You should exclude your virtual environment directory from your version control system using ``.gitignore`` or similar."
msgstr ""

#: ../source/guides/installing-using-pip-and-virtual-environments.rst:128
msgid "Activating a virtual environment"
msgstr ""

#: ../source/guides/installing-using-pip-and-virtual-environments.rst:130
msgid "Before you can start installing or using packages in your virtual environment you'll need to *activate* it. Activating a virtual environment will put the virtual environment-specific ``python`` and ``pip`` executables into your shell's ``PATH``."
msgstr ""

#: ../source/guides/installing-using-pip-and-virtual-environments.rst:147
msgid "You can confirm you're in the virtual environment by checking the location of your Python interpreter, it should point to the ``env`` directory."
msgstr ""

#: ../source/guides/installing-using-pip-and-virtual-environments.rst:164
msgid "As long as your virtual environment is activated pip will install packages into that specific environment and you'll be able to import and use packages in your Python application."
msgstr ""

#: ../source/guides/installing-using-pip-and-virtual-environments.rst:170
msgid "Leaving the virtual environment"
msgstr ""

#: ../source/guides/installing-using-pip-and-virtual-environments.rst:172
msgid "If you want to switch projects or otherwise leave your virtual environment, simply run:"
msgstr ""

#: ../source/guides/installing-using-pip-and-virtual-environments.rst:178
msgid "If you want to re-enter the virtual environment just follow the same instructions above about activating a virtual environment. There's no need to re-create the virtual environment."
msgstr ""

#: ../source/guides/installing-using-pip-and-virtual-environments.rst:183
msgid "Installing packages"
msgstr ""

#: ../source/guides/installing-using-pip-and-virtual-environments.rst:185
msgid "Now that you're in your virtual environment you can install packages. Let's install the `Requests`_ library from the :term:`Python Package Index (PyPI)`:"
msgstr ""

#: ../source/guides/installing-using-pip-and-virtual-environments.rst:200
msgid "pip should download requests and all of its dependencies and install them:"
msgstr ""

#: ../source/guides/installing-using-pip-and-virtual-environments.rst:221
msgid "Installing specific versions"
msgstr ""

#: ../source/guides/installing-using-pip-and-virtual-environments.rst:223
msgid "pip allows you to specify which version of a package to install using :term:`version specifiers <Version Specifier>`. For example, to install a specific version of ``requests``:"
msgstr ""

#: ../source/guides/installing-using-pip-and-virtual-environments.rst:239
msgid "To install the latest ``2.x`` release of requests:"
msgstr ""

#: ../source/guides/installing-using-pip-and-virtual-environments.rst:253
msgid "To install pre-release versions of packages, use the ``--pre`` flag:"
msgstr ""

#: ../source/guides/installing-using-pip-and-virtual-environments.rst:269
msgid "Installing extras"
msgstr ""

#: ../source/guides/installing-using-pip-and-virtual-environments.rst:271
msgid "Some packages have optional `extras`_. You can tell pip to install these by specifying the extra in brackets:"
msgstr ""

#: ../source/guides/installing-using-pip-and-virtual-environments.rst:291
msgid "Installing from source"
msgstr ""

#: ../source/guides/installing-using-pip-and-virtual-environments.rst:293
msgid "pip can install a package directly from source, for example:"
msgstr ""

#: ../source/guides/installing-using-pip-and-virtual-environments.rst:309
msgid "Additionally, pip can install packages from source in `development mode`_, meaning that changes to the source directory will immediately affect the installed package without needing to re-install:"
msgstr ""

#: ../source/guides/installing-using-pip-and-virtual-environments.rst:330
msgid "Installing from version control systems"
msgstr ""

#: ../source/guides/installing-using-pip-and-virtual-environments.rst:332
msgid "pip can install packages directly from their version control system. For example, you can install directly from a git repository:"
msgstr ""

#: ../source/guides/installing-using-pip-and-virtual-environments.rst:339
msgid "For more information on supported version control systems and syntax, see pip's documentation on :ref:`VCS Support <pip:VCS Support>`."
msgstr ""

#: ../source/guides/installing-using-pip-and-virtual-environments.rst:344
#: ../source/tutorials/installing-packages.rst:569
msgid "Installing from local archives"
msgstr ""

#: ../source/guides/installing-using-pip-and-virtual-environments.rst:346
msgid "If you have a local copy of a :term:`Distribution Package`'s archive (a zip, wheel, or tar file) you can install it directly with pip:"
msgstr ""

#: ../source/guides/installing-using-pip-and-virtual-environments.rst:361
msgid "If you have a directory containing archives of multiple packages, you can tell pip to look for packages there and not to use the :term:`Python Package Index (PyPI)` at all:"
msgstr ""

#: ../source/guides/installing-using-pip-and-virtual-environments.rst:377
msgid "This is useful if you are installing packages on a system with limited connectivity or if you want to strictly control the origin of distribution packages."
msgstr ""

#: ../source/guides/installing-using-pip-and-virtual-environments.rst:383
msgid "Using other package indexes"
msgstr ""

#: ../source/guides/installing-using-pip-and-virtual-environments.rst:385
msgid "If you want to download packages from a different index than the :term:`Python Package Index (PyPI)`, you can use the ``--index-url`` flag:"
msgstr ""

#: ../source/guides/installing-using-pip-and-virtual-environments.rst:400
msgid "If you want to allow packages from both the :term:`Python Package Index (PyPI)` and a separate index, you can use the ``--extra-index-url`` flag instead:"
msgstr ""

#: ../source/guides/installing-using-pip-and-virtual-environments.rst:417
#: ../source/tutorials/installing-packages.rst:389
msgid "Upgrading packages"
msgstr ""

#: ../source/guides/installing-using-pip-and-virtual-environments.rst:419
msgid "pip can upgrade packages in-place using the ``--upgrade`` flag. For example, to install the latest version of ``requests`` and all of its dependencies:"
msgstr ""

#: ../source/guides/installing-using-pip-and-virtual-environments.rst:435
msgid "Using requirements files"
msgstr ""

#: ../source/guides/installing-using-pip-and-virtual-environments.rst:437
msgid "Instead of installing packages individually, pip allows you to declare all dependencies in a :ref:`Requirements File <pip:Requirements Files>`. For example you could create a :file:`requirements.txt` file containing:"
msgstr ""

#: ../source/guides/installing-using-pip-and-virtual-environments.rst:446
msgid "And tell pip to install all of the packages in this file using the ``-r`` flag:"
msgstr ""

#: ../source/guides/installing-using-pip-and-virtual-environments.rst:461
msgid "Freezing dependencies"
msgstr ""

#: ../source/guides/installing-using-pip-and-virtual-environments.rst:463
msgid "Pip can export a list of all installed packages and their versions using the ``freeze`` command:"
msgstr ""

#: ../source/guides/installing-using-pip-and-virtual-environments.rst:478
msgid "Which will output a list of package specifiers such as:"
msgstr ""

#: ../source/guides/installing-using-pip-and-virtual-environments.rst:494
msgid "This is useful for creating :ref:`pip:Requirements Files` that can re-create the exact versions of all packages installed in an environment."
msgstr ""

#: ../source/guides/making-a-pypi-friendly-readme.rst:2
msgid "Making a PyPI-friendly README"
msgstr ""

#: ../source/guides/making-a-pypi-friendly-readme.rst:4
msgid "README files can help your users understand your project and can be used to set your project's description on PyPI. This guide helps you create a README in a PyPI-friendly format and include your README in your package so it appears on PyPI."
msgstr ""

#: ../source/guides/making-a-pypi-friendly-readme.rst:9
msgid "Creating a README file"
msgstr ""

#: ../source/guides/making-a-pypi-friendly-readme.rst:11
msgid "README files for Python projects are often named ``README``, ``README.txt``, ``README.rst``, or ``README.md``."
msgstr ""

#: ../source/guides/making-a-pypi-friendly-readme.rst:13
msgid "For your README to display properly on PyPI, choose a markup language supported by PyPI. Formats supported by `PyPI's README renderer <https://github.com/pypa/readme_renderer>`_ are:"
msgstr ""

#: ../source/guides/making-a-pypi-friendly-readme.rst:16
msgid "plain text"
msgstr ""

#: ../source/guides/making-a-pypi-friendly-readme.rst:17
msgid "`reStructuredText <http://docutils.sourceforge.net/rst.html>`_ (without Sphinx extensions)"
msgstr ""

#: ../source/guides/making-a-pypi-friendly-readme.rst:18
msgid "Markdown (`GitHub Flavored Markdown <https://github.github.com/gfm/>`_ by default, or `CommonMark <http://commonmark.org/>`_)"
msgstr ""

#: ../source/guides/making-a-pypi-friendly-readme.rst:21
msgid "It's customary to save your README file in the root of your project, in the same directory as your :file:`setup.py` file."
msgstr ""

#: ../source/guides/making-a-pypi-friendly-readme.rst:25
msgid "Including your README in your package's metadata"
msgstr ""

#: ../source/guides/making-a-pypi-friendly-readme.rst:27
msgid "To include your README's contents as your package description, set your project's ``Description`` and ``Description-Content-Type`` metadata, typically in your project's :file:`setup.py` file."
msgstr ""

#: ../source/guides/making-a-pypi-friendly-readme.rst:33
msgid ":ref:`description-optional`"
msgstr ""

#: ../source/guides/making-a-pypi-friendly-readme.rst:34
msgid ":ref:`description-content-type-optional`"
msgstr ""

#: ../source/guides/making-a-pypi-friendly-readme.rst:36
msgid "For example, to set these values in a package's :file:`setup.py` file, use ``setup()``'s ``long_description`` and ``long_description_content_type``."
msgstr ""

#: ../source/guides/making-a-pypi-friendly-readme.rst:39
msgid "Set the value of ``long_description`` to the contents (not the path) of the README file itself. Set the ``long_description_content_type`` to an accepted ``Content-Type``-style value for your README file's markup, such as ``text/plain``, ``text/x-rst`` (for reStructuredText), or ``text/markdown``."
msgstr ""

#: ../source/guides/making-a-pypi-friendly-readme.rst:45
msgid "If you're using GitHub-flavored Markdown to write a project's description, ensure you upgrade the following tools:"
msgstr ""

#: ../source/guides/making-a-pypi-friendly-readme.rst:60
msgid "The minimum required versions of the respective tools are:"
msgstr ""

#: ../source/guides/making-a-pypi-friendly-readme.rst:62
msgid "``setuptools >= 38.6.0``"
msgstr ""

#: ../source/guides/making-a-pypi-friendly-readme.rst:63
msgid "``wheel >= 0.31.0``"
msgstr ""

#: ../source/guides/making-a-pypi-friendly-readme.rst:64
msgid "``twine >= 1.11.0``"
msgstr ""

#: ../source/guides/making-a-pypi-friendly-readme.rst:66
msgid "It's recommended that you use ``twine`` to upload the project's distribution packages:"
msgstr ""

#: ../source/guides/making-a-pypi-friendly-readme.rst:72
msgid "For example, see this :file:`setup.py` file, which reads the contents of :file:`README.md` as ``long_description`` and identifies the markup as GitHub-flavored Markdown:"
msgstr ""

#: ../source/guides/making-a-pypi-friendly-readme.rst:95
msgid "Validating reStructuredText markup"
msgstr ""

#: ../source/guides/making-a-pypi-friendly-readme.rst:97
msgid "If your README is written in reStructuredText, any invalid markup will prevent it from rendering, causing PyPI to instead just show the README's raw source."
msgstr ""

#: ../source/guides/making-a-pypi-friendly-readme.rst:100
msgid "Note that Sphinx extensions used in docstrings, such as `directives and roles <http://www.sphinx-doc.org/en/master/usage/restructuredtext/index.html>`_ (e.g., \"``:py:func:`getattr```\" or \"``:ref:`my-reference-label```\"), are not allowed here and will result in error messages like \"``Error: Unknown interpreted text role \"py:func\".``\"."
msgstr ""

#: ../source/guides/making-a-pypi-friendly-readme.rst:105
msgid "You can check your README for markup errors before uploading as follows:"
msgstr ""

#: ../source/guides/making-a-pypi-friendly-readme.rst:107
msgid "Install the latest version of `twine <https://github.com/pypa/twine>`_; version 1.12.0 or higher is required:"
msgstr ""

#: ../source/guides/making-a-pypi-friendly-readme.rst:122
msgid "Build the sdist and wheel for your project as described under :ref:`Packaging Your Project`."
msgstr ""

#: ../source/guides/making-a-pypi-friendly-readme.rst:125
msgid "Run ``twine check`` on the sdist and wheel::"
msgstr ""

#: ../source/guides/making-a-pypi-friendly-readme.rst:129
msgid "This command will report any problems rendering your README.  If your markup renders fine, the command will output ``Checking distribution FILENAME: Passed``."
msgstr ""

#: ../source/guides/migrating-to-pypi-org.rst:4
msgid "Migrating to PyPI.org"
msgstr ""

#: ../source/guides/migrating-to-pypi-org.rst:6
msgid ":term:`pypi.org` is the new, rewritten version of PyPI that has replaced the legacy PyPI code base. It is the default version of PyPI that people are expected to use. These are the tools and processes that people will need to interact with ``PyPI.org``."
msgstr ""

#: ../source/guides/migrating-to-pypi-org.rst:12
msgid "Publishing releases"
msgstr ""

#: ../source/guides/migrating-to-pypi-org.rst:14
msgid "``pypi.org`` is the default upload platform as of September 2016."
msgstr ""

#: ../source/guides/migrating-to-pypi-org.rst:16
msgid "Uploads through ``pypi.python.org`` were *switched off* on **July 3, 2017**. As of April 13th, 2018, ``pypi.org`` is the URL for PyPI."
msgstr ""

#: ../source/guides/migrating-to-pypi-org.rst:19
msgid "The recommended way to migrate to PyPI.org for uploading is to ensure that you are using a new enough version of your upload tool."
msgstr ""

#: ../source/guides/migrating-to-pypi-org.rst:22
msgid "The default upload settings switched to ``pypi.org`` in the following versions:"
msgstr ""

#: ../source/guides/migrating-to-pypi-org.rst:24
msgid "``twine`` 1.8.0"
msgstr ""

#: ../source/guides/migrating-to-pypi-org.rst:25
msgid "``setuptools`` 27.0.0"
msgstr ""

#: ../source/guides/migrating-to-pypi-org.rst:26
msgid "Python 2.7.13 (``distutils`` update)"
msgstr ""

#: ../source/guides/migrating-to-pypi-org.rst:27
msgid "Python 3.4.6 (``distutils`` update)"
msgstr ""

#: ../source/guides/migrating-to-pypi-org.rst:28
msgid "Python 3.5.3 (``distutils`` update)"
msgstr ""

#: ../source/guides/migrating-to-pypi-org.rst:29
msgid "Python 3.6.0 (``distutils`` update)"
msgstr ""

#: ../source/guides/migrating-to-pypi-org.rst:31
msgid "In addition to ensuring you're on a new enough version of the tool for the tool's default to have switched, you must also make sure that you have not configured the tool to override its default upload URL. Typically this is configured in a file located at :file:`$HOME/.pypirc`. If you see a file like:"
msgstr ""

#: ../source/guides/migrating-to-pypi-org.rst:48
msgid "Then simply delete the line starting with ``repository`` and you will use your upload tool's default URL."
msgstr ""

#: ../source/guides/migrating-to-pypi-org.rst:51
msgid "If for some reason you're unable to upgrade the version of your tool to a version that defaults to using PyPI.org, then you may edit :file:`$HOME/.pypirc` and include the ``repository:`` line, but use the value ``https://upload.pypi.org/legacy/`` instead:"
msgstr ""

#: ../source/guides/migrating-to-pypi-org.rst:67
msgid "(``legacy`` in this URL refers to the fact that this is the new server implementation's emulation of the legacy server implementation's upload API.)"
msgstr ""

#: ../source/guides/migrating-to-pypi-org.rst:73
msgid "Registering package names & metadata"
msgstr ""

#: ../source/guides/migrating-to-pypi-org.rst:75
msgid "Explicit pre-registration of package names with the ``setup.py register`` command prior to the first upload is no longer required, and is not currently supported by the legacy upload API emulation on PyPI.org."
msgstr ""

#: ../source/guides/migrating-to-pypi-org.rst:79
msgid "As a result, attempting explicit registration after switching to using PyPI.org for uploads will give the following error message::"
msgstr ""

#: ../source/guides/migrating-to-pypi-org.rst:84
msgid "The solution is to skip the registration step, and proceed directly to uploading artifacts."
msgstr ""

#: ../source/guides/migrating-to-pypi-org.rst:89
#: ../source/guides/using-testpypi.rst:5
msgid "Using TestPyPI"
msgstr ""

#: ../source/guides/migrating-to-pypi-org.rst:91
msgid "Legacy TestPyPI (testpypi.python.org) is no longer available; use `test.pypi.org <https://test.pypi.org>`_ instead. If you use TestPyPI, you must update your :file:`$HOME/.pypirc` to handle TestPyPI's new location, by replacing ``https://testpypi.python.org/pypi`` with ``https://test.pypi.org/legacy/``, for example:"
msgstr ""

#: ../source/guides/migrating-to-pypi-org.rst:113
msgid "Registering new user accounts"
msgstr ""

#: ../source/guides/migrating-to-pypi-org.rst:115
msgid "In order to help mitigate spam attacks against PyPI, new user registration through ``pypi.python.org`` was *switched off* on **February 20, 2018**. New user registrations at ``pypi.org`` are open."
msgstr ""

#: ../source/guides/migrating-to-pypi-org.rst:121
msgid "Browsing packages"
msgstr ""

#: ../source/guides/migrating-to-pypi-org.rst:123
msgid "While ``pypi.python.org`` is may still be used in links from other PyPA documentation, etc, the default interface for browsing packages is ``pypi.org``. The domain pypi.python.org now redirects to pypi.org, and may be disabled sometime in the future."
msgstr ""

#: ../source/guides/migrating-to-pypi-org.rst:130
msgid "Downloading packages"
msgstr ""

#: ../source/guides/migrating-to-pypi-org.rst:132
msgid "``pypi.org`` is the default host for downloading packages."
msgstr ""

#: ../source/guides/migrating-to-pypi-org.rst:135
msgid "Managing published packages and releases"
msgstr ""

#: ../source/guides/migrating-to-pypi-org.rst:137
msgid "``pypi.org`` provides a fully functional interface for logged in users to manage their published packages and releases."
msgstr ""

#: ../source/guides/multi-version-installs.rst:5
msgid "Multi-version installs"
msgstr ""

#: ../source/guides/multi-version-installs.rst:8
msgid "easy_install allows simultaneous installation of different versions of the same project into a single environment shared by multiple programs which must ``require`` the appropriate version of the project at run time (using ``pkg_resources``)."
msgstr ""

#: ../source/guides/multi-version-installs.rst:13
msgid "For many use cases, virtual environments address this need without the complication of the ``require`` directive. However, the advantage of parallel installations within the same environment is that it works for an environment shared by multiple applications, such as the system Python in a Linux distribution."
msgstr ""

#: ../source/guides/multi-version-installs.rst:19
msgid "The major limitation of ``pkg_resources`` based parallel installation is that as soon as you import ``pkg_resources`` it locks in the *default* version of everything which is already available on sys.path. This can cause problems, since ``setuptools`` created command line scripts use ``pkg_resources`` to find the entry point to execute. This means that, for example, you can't use ``require`` tests invoked through ``nose`` or a WSGI application invoked through ``gunicorn`` if your application needs a non-default version of anything that is available on the standard ``sys.path`` - the script wrapper for the main application will lock in the version that is available by default, so the subsequent ``require`` call in your own code fails with a spurious version conflict."
msgstr ""

#: ../source/guides/multi-version-installs.rst:31
msgid "This can be worked around by setting all dependencies in ``__main__.__requires__`` before importing ``pkg_resources`` for the first time, but that approach does mean that standard command line invocations of the affected tools can't be used - it's necessary to write a custom wrapper script or use ``python -c '<command>'`` to invoke the application's main entry point directly."
msgstr ""

#: ../source/guides/multi-version-installs.rst:38
msgid "Refer to the `pkg_resources documentation <https://setuptools.readthedocs.io/en/latest/pkg_resources.html#workingset-objects>`__ for more details."
msgstr ""

#: ../source/guides/packaging-binary-extensions.rst:5
msgid "Packaging binary extensions"
msgstr ""

#: ../source/guides/packaging-binary-extensions.rst:8
msgid "2013-12-08"
msgstr ""

#: ../source/guides/packaging-binary-extensions.rst:10
msgid "One of the features of the CPython reference interpreter is that, in addition to allowing the execution of Python code, it also exposes a rich C API for use by other software. One of the most common uses of this C API is to create importable C extensions that allow things which aren't always easy to achieve in pure Python code."
msgstr ""

#: ../source/guides/packaging-binary-extensions.rst:20
msgid "An overview of binary extensions"
msgstr ""

#: ../source/guides/packaging-binary-extensions.rst:23
msgid "Use cases"
msgstr ""

#: ../source/guides/packaging-binary-extensions.rst:25
msgid "The typical use cases for binary extensions break down into just three conventional categories:"
msgstr ""

#: ../source/guides/packaging-binary-extensions.rst:28
msgid "**accelerator modules**: these modules are completely self-contained, and are created solely to run faster than the equivalent pure Python code runs in CPython. Ideally, accelerator modules will always have a pure Python equivalent to use as a fallback if the accelerated version isn't available on a given system. The CPython standard library makes extensive use of accelerator modules. *Example*: When importing ``datetime``, Python falls back to the `datetime.py <https://github.com/python/cpython/blob/master/Lib/datetime.py>`_ module if the C implementation ( `_datetimemodule.c <https://github.com/python/cpython/blob/master/Modules/_datetimemodule.c>`_) is not available."
msgstr ""

#: ../source/guides/packaging-binary-extensions.rst:39
msgid "**wrapper modules**: these modules are created to expose existing C interfaces to Python code. They may either expose the underlying C interface directly, or else expose a more \"Pythonic\" API that makes use of Python language features to make the API easier to use. The CPython standard library makes extensive use of wrapper modules. *Example*: `functools.py <https://github.com/python/cpython/blob/master/Lib/functools.py>`_ is a Python module wrapper for `_functoolsmodule.c <https://github.com/python/cpython/blob/master/Modules/_functoolsmodule.c>`_."
msgstr ""

#: ../source/guides/packaging-binary-extensions.rst:47
msgid "**low-level system access**: these modules are created to access lower level features of the CPython runtime, the operating system, or the underlying hardware. Through platform specific code, extension modules may achieve things that aren't possible in pure Python code. A number of CPython standard library modules are written in C in order to access interpreter internals that aren't exposed at the language level. *Example*: ``sys``, which comes from `sysmodule.c <https://github.com/python/cpython/blob/master/Python/sysmodule.c>`_."
msgstr ""

#: ../source/guides/packaging-binary-extensions.rst:56
msgid "One particularly notable feature of C extensions is that, when they don't need to call back into the interpreter runtime, they can release CPython's global interpreter lock around long-running operations (regardless of whether those operations are CPU or IO bound)."
msgstr ""

#: ../source/guides/packaging-binary-extensions.rst:61
msgid "Not all extension modules will fit neatly into the above categories. The extension modules included with NumPy, for example, span all three use cases - they move inner loops to C for speed reasons, wrap external libraries written in C, FORTRAN and other languages, and use low level system interfaces for both CPython and the underlying operation system to support concurrent execution of vectorised operations and to tightly control the exact memory layout of created objects."
msgstr ""

#: ../source/guides/packaging-binary-extensions.rst:71
msgid "Disadvantages"
msgstr ""

#: ../source/guides/packaging-binary-extensions.rst:73
msgid "The main disadvantage of using binary extensions is the fact that it makes subsequent distribution of the software more difficult. One of the advantages of using Python is that it is largely cross platform, and the languages used to write extension modules (typically C or C++, but really any language that can bind to the CPython C API) typically require that custom binaries be created for different platforms."
msgstr ""

#: ../source/guides/packaging-binary-extensions.rst:80
msgid "This means that binary extensions:"
msgstr ""

#: ../source/guides/packaging-binary-extensions.rst:82
msgid "require that end users be able to either build them from source, or else that someone publish pre-built binaries for common platforms"
msgstr ""

#: ../source/guides/packaging-binary-extensions.rst:85
msgid "may not be compatible with different builds of the CPython reference interpreter"
msgstr ""

#: ../source/guides/packaging-binary-extensions.rst:88
msgid "often will not work correctly with alternative interpreters such as PyPy, IronPython or Jython"
msgstr ""

#: ../source/guides/packaging-binary-extensions.rst:91
msgid "if handcoded, make maintenance more difficult by requiring that maintainers be familiar not only with Python, but also with the language used to create the binary extension, as well as with the details of the CPython C API."
msgstr ""

#: ../source/guides/packaging-binary-extensions.rst:96
msgid "if a pure Python fallback implementation is provided, make maintenance more difficult by requiring that changes be implemented in two places, and introducing additional complexity in the test suite to ensure both versions are always executed."
msgstr ""

#: ../source/guides/packaging-binary-extensions.rst:101
msgid "Another disadvantage of relying on binary extensions is that alternative import mechanisms (such as the ability to import modules directly from zipfiles) often won't work for extension modules (as the dynamic loading mechanisms on most platforms can only load libraries from disk)."
msgstr ""

#: ../source/guides/packaging-binary-extensions.rst:108
msgid "Alternatives to handcoded accelerator modules"
msgstr ""

#: ../source/guides/packaging-binary-extensions.rst:110
msgid "When extension modules are just being used to make code run faster (after profiling has identified the code where the speed increase is worth additional maintenance effort), a number of other alternatives should also be considered:"
msgstr ""

#: ../source/guides/packaging-binary-extensions.rst:115
msgid "look for existing optimised alternatives. The CPython standard library includes a number of optimised data structures and algorithms (especially in the builtins and the ``collections`` and ``itertools`` modules). The Python Package Index also offers additional alternatives. Sometimes, the appropriate choice of standard library or third party module can avoid the need to create your own accelerator module."
msgstr ""

#: ../source/guides/packaging-binary-extensions.rst:122
msgid "for long running applications, the JIT compiled `PyPy interpreter <http://pypy.org/>`__ may offer a suitable alternative to the standard CPython runtime. The main barrier to adopting PyPy is typically reliance on other binary extension modules - while PyPy does emulate the CPython C API, modules that rely on that cause problems for the PyPy JIT, and the emulation layer can often expose latent defects in extension modules that CPython currently tolerates (frequently around reference counting errors - an object having one live reference instead of two often won't break anything, but no references instead of one is a major problem)."
msgstr ""

#: ../source/guides/packaging-binary-extensions.rst:132
msgid "`Cython <http://cython.org/>`__ is a mature static compiler that can compile most Python code to C extension modules. The initial compilation provides some speed increases (by bypassing the CPython interpreter layer), and Cython's optional static typing features can offer additional opportunities for speed increases. Using Cython still has the disadvantage of increasing the complexity of distributing the resulting application, but has the benefit of having a reduced barrier to entry for Python programmers (relative to other languages like C or C++)."
msgstr ""

#: ../source/guides/packaging-binary-extensions.rst:141
msgid "`Numba <http://numba.pydata.org/>`__ is a newer tool, created by members of the scientific Python community, that aims to leverage LLVM to allow selective compilation of pieces of a Python application to native machine code at runtime. It requires that LLVM be available on the system where the code is running, but can provide significant speed increases, especially for operations that are amenable to vectorisation."
msgstr ""

#: ../source/guides/packaging-binary-extensions.rst:150
msgid "Alternatives to handcoded wrapper modules"
msgstr ""

#: ../source/guides/packaging-binary-extensions.rst:152
msgid "The C ABI (Application Binary Interface) is a common standard for sharing functionality between multiple applications. One of the strengths of the CPython C API (Application Programming Interface) is allowing Python users to tap into that functionality. However, wrapping modules by hand is quite tedious, so a number of other alternative approaches should be considered."
msgstr ""

#: ../source/guides/packaging-binary-extensions.rst:158
msgid "The approaches described below don't simplify the distribution case at all, but they *can* significantly reduce the maintenance burden of keeping wrapper modules up to date."
msgstr ""

#: ../source/guides/packaging-binary-extensions.rst:162
msgid "In addition to being useful for the creation of accelerator modules, `Cython <http://cython.org/>`__ is also useful for creating wrapper modules for C or C++. It still involves wrapping the interfaces by hand, however, and is very repetitive, so may not be a good choice for wrapping large APIs."
msgstr ""

#: ../source/guides/packaging-binary-extensions.rst:168
msgid "`pybind11 <https://pybind11.readthedocs.io>`__ is a pure C++11 library that provides a clean C++ interface to the CPython (and PyPy) C API. It does not require a pre-processing step; it is written entirely in templated C++. Helpers are included for Setuptools or CMake builds. It was based on `Boost.Python <https://www.boost.org/doc/libs/1_76_0/libs/python/doc/html/index.html>`__, but doesn't require the Boost libraries or BJam."
msgstr ""

#: ../source/guides/packaging-binary-extensions.rst:175
msgid "`cffi <https://cffi.readthedocs.io/>`__ is a project created by some of the PyPy developers to make it straightforward for developers that already know both Python and C to expose their C modules to Python applications. It also makes it relatively straightforward to wrap a C module based on its header files, even if you don't know C yourself."
msgstr ""

#: ../source/guides/packaging-binary-extensions.rst:181
msgid "One of the key advantages of ``cffi`` is that it is compatible with the PyPy JIT, allowing CFFI wrapper modules to participate fully in PyPy's tracing JIT optimisations."
msgstr ""

#: ../source/guides/packaging-binary-extensions.rst:185
msgid "`SWIG <http://www.swig.org/>`__ is a wrapper interface generator that allows a variety of programming languages, including Python, to interface with C and C++ code."
msgstr ""

#: ../source/guides/packaging-binary-extensions.rst:189
msgid "The standard library's ``ctypes`` module, while useful for getting access to C level interfaces when header information isn't available, suffers from the fact that it operates solely at the C ABI level, and thus has no automatic consistency checking between the interface actually being exported by the library and the one declared in the Python code. By contrast, the above alternatives are all able to operate at the C *API* level, using C header files to ensure consistency between the interface exported by the library being wrapped and the one expected by the Python wrapper module. While ``cffi`` *can* operate directly at the C ABI level, it suffers from the same interface inconsistency problems as ``ctypes`` when it is used that way."
msgstr ""

#: ../source/guides/packaging-binary-extensions.rst:203
msgid "Alternatives for low level system access"
msgstr ""

#: ../source/guides/packaging-binary-extensions.rst:205
msgid "For applications that need low level system access (regardless of the reason), a binary extension module often *is* the best way to go about it. This is particularly true for low level access to the CPython runtime itself, since some operations (like releasing the Global Interpreter Lock) are simply invalid when the interpreter is running code, even if a module like ``ctypes`` or ``cffi`` is used to obtain access to the relevant C API interfaces."
msgstr ""

#: ../source/guides/packaging-binary-extensions.rst:213
msgid "For cases where the extension module is manipulating the underlying operating system or hardware (rather than the CPython runtime), it may sometimes be better to just write an ordinary C library (or a library in another systems programming language like C++ or Rust that can export a C compatible ABI), and then use one of the wrapping techniques described above to make the interface available as an importable Python module."
msgstr ""

#: ../source/guides/packaging-binary-extensions.rst:222
msgid "Implementing binary extensions"
msgstr ""

#: ../source/guides/packaging-binary-extensions.rst:224
msgid "The CPython `Extending and Embedding <https://docs.python.org/3/extending/>`_ guide includes an introduction to writing a `custom extension module in C <https://docs.python.org/3/extending/extending.html>`_."
msgstr ""

#: ../source/guides/packaging-binary-extensions.rst:241
msgid "Building binary extensions"
msgstr ""

#: ../source/guides/packaging-binary-extensions.rst:244
msgid "Building extensions for multiple platforms"
msgstr ""

#: ../source/guides/packaging-binary-extensions.rst:246
msgid "If you plan to distribute your extension, you should provide :term:`wheels <Wheel>` for all the platforms you intend to support. For most extensions, this is at least one package per Python version times the number of OS and architectures you support.  These are usually built on continuous integration (CI) systems. There are tools to help you build highly redistributable binaries from CI; these include :ref:`cibuildwheel` and :ref:`multibuild`."
msgstr ""

#: ../source/guides/packaging-binary-extensions.rst:256
msgid "Binary extensions for Windows"
msgstr ""

#: ../source/guides/packaging-binary-extensions.rst:258
msgid "Before it is possible to build a binary extension, it is necessary to ensure that you have a suitable compiler available. On Windows, Visual C is used to build the official CPython interpreter, and should be used to build compatible binary extensions."
msgstr ""

#: ../source/guides/packaging-binary-extensions.rst:263
msgid "Python 2.7 used Visual Studio 2008, Python 3.3 and 3.4 used Visual Studio 2010, and Python 3.5+ uses Visual Studio 2015 or later. Unfortunately, older versions of Visual Studio are no longer easily available from Microsoft, so for versions of Python prior to 3.5, the compilers must be obtained differently if you do not already have a copy of the relevant version of Visual Studio."
msgstr ""

#: ../source/guides/packaging-binary-extensions.rst:269
msgid "To set up a build environment for binary extensions, the steps are as follows:"
msgstr ""

#: ../source/guides/packaging-binary-extensions.rst:271
msgid "For Python 2.7"
msgstr ""

#: ../source/guides/packaging-binary-extensions.rst:273
msgid "Install \"Visual C++ Compiler Package for Python 2.7\", which is available from `Microsoft's website <https://www.microsoft.com/en-gb/download/details.aspx?id=44266>`__."
msgstr ""

#: ../source/guides/packaging-binary-extensions.rst:276
msgid "Use (a recent version of) setuptools in your setup.py (pip will do this for you, in any case)."
msgstr ""

#: ../source/guides/packaging-binary-extensions.rst:278
#: ../source/guides/packaging-binary-extensions.rst:288
#: ../source/guides/packaging-binary-extensions.rst:295
msgid "Done."
msgstr ""

#: ../source/guides/packaging-binary-extensions.rst:280
msgid "For Python 3.4"
msgstr ""

#: ../source/guides/packaging-binary-extensions.rst:282
msgid "Install \"Windows SDK for Windows 7 and .NET Framework 4\" (v7.1), which is available from `Microsoft's website <https://www.microsoft.com/en-gb/download/details.aspx?id=8279>`__."
msgstr ""

#: ../source/guides/packaging-binary-extensions.rst:285
msgid "Work from an SDK command prompt (with the environment variables set, and the SDK on PATH)."
msgstr ""

#: ../source/guides/packaging-binary-extensions.rst:287
msgid "Set DISTUTILS_USE_SDK=1"
msgstr ""

#: ../source/guides/packaging-binary-extensions.rst:290
msgid "For Python 3.5"
msgstr ""

#: ../source/guides/packaging-binary-extensions.rst:292
msgid "Install `Visual Studio 2015 Community Edition <https://www.visualstudio.com/en-us/downloads/download-visual-studio-vs.aspx>`__ (or any later version, when these are released)."
msgstr ""

#: ../source/guides/packaging-binary-extensions.rst:297
msgid "Note that from Python 3.5 onwards, Visual Studio works in a backward compatible way, which means that any future version of Visual Studio will be able to build Python extensions for all Python versions from 3.5 onwards."
msgstr ""

#: ../source/guides/packaging-binary-extensions.rst:301
msgid "Building with the recommended compiler on Windows ensures that a compatible C library is used throughout the Python process."
msgstr ""

#: ../source/guides/packaging-binary-extensions.rst:305
msgid "Binary extensions for Linux"
msgstr ""

#: ../source/guides/packaging-binary-extensions.rst:307
msgid "Linux binaries must use a sufficiently old glibc to be compatible with older distributions. The `manylinux <https://github.com/pypa/manylinux>`_ Docker images provide a build environment with a glibc old enough to support most current Linux distributions on common architectures."
msgstr ""

#: ../source/guides/packaging-binary-extensions.rst:313
msgid "Binary extensions for macOS"
msgstr ""

#: ../source/guides/packaging-binary-extensions.rst:315
msgid "Binary compatibility on macOS is determined by the target minimum deployment system, e.g. *10.9*, which is often specified with the ``MACOSX_DEPLOYMENT_TARGET`` environmental variable when building binaries on macOS. When building with setuptools / distutils, the deployment target is specified with the flag ``--plat-name``, e.g. ``macosx-10.9-x86_64``. For common deployment targets for macOS Python distributions, see the `MacPython Spinning Wheels wiki <https://github.com/MacPython/wiki/wiki/Spinning-wheels>`_."
msgstr ""

#: ../source/guides/packaging-binary-extensions.rst:325
msgid "Publishing binary extensions"
msgstr ""

#: ../source/guides/packaging-binary-extensions.rst:327
msgid "For interim guidance on this topic, see the discussion in `this issue <https://github.com/pypa/python-packaging-user-guide/issues/284>`_."
msgstr ""

#: ../source/guides/packaging-binary-extensions.rst:343
msgid "Additional resources"
msgstr ""

#: ../source/guides/packaging-binary-extensions.rst:345
msgid "Cross-platform development and distribution of extension modules is a complex topic, so this guide focuses primarily on providing pointers to various tools that automate dealing with the underlying technical challenges. The additional resources in this section are instead intended for developers looking to understand more about the underlying binary interfaces that those systems rely on at runtime."
msgstr ""

#: ../source/guides/packaging-binary-extensions.rst:352
msgid "Cross-platform wheel generation with scikit-build"
msgstr ""

#: ../source/guides/packaging-binary-extensions.rst:354
msgid "The `scikit-build <https://scikit-build.readthedocs.io/en/latest/>`_ package helps abstract cross-platform build operations and provides additional capabilities when creating binary extension packages. Additional documentation is also available on the `C runtime, compiler, and build system generator <https://scikit-build.readthedocs.io/en/latest/generators.html>`_ for Python binary extension modules."
msgstr ""

#: ../source/guides/packaging-binary-extensions.rst:362
msgid "Introduction to C/C++ extension modules"
msgstr ""

#: ../source/guides/packaging-binary-extensions.rst:364
msgid "For a more in depth explanation of how extension modules are used by CPython on a Debian system, see the following articles:"
msgstr ""

#: ../source/guides/packaging-binary-extensions.rst:367
msgid "`What are (c)python extension modules? <https://thomasnyberg.com/what_are_extension_modules.html>`_"
msgstr ""

#: ../source/guides/packaging-binary-extensions.rst:368
msgid "`Releasing the gil <https://thomasnyberg.com/releasing_the_gil.html>`_"
msgstr ""

#: ../source/guides/packaging-binary-extensions.rst:369
msgid "`Writing cpython extension modules using C++ <https://thomasnyberg.com/cpp_extension_modules.html>`_"
msgstr ""

#: ../source/guides/packaging-namespace-packages.rst:3
msgid "Packaging namespace packages"
msgstr ""

#: ../source/guides/packaging-namespace-packages.rst:5
msgid "Namespace packages allow you to split the sub-packages and modules within a single :term:`package <Import Package>` across multiple, separate :term:`distribution packages <Distribution Package>` (referred to as **distributions** in this document to avoid ambiguity). For example, if you have the following package structure:"
msgstr ""

#: ../source/guides/packaging-namespace-packages.rst:24
msgid "And you use this package in your code like so::"
msgstr ""

#: ../source/guides/packaging-namespace-packages.rst:29
msgid "Then you can break these sub-packages into two separate distributions:"
msgstr ""

#: ../source/guides/packaging-namespace-packages.rst:46
msgid "Each sub-package can now be separately installed, used, and versioned."
msgstr ""

#: ../source/guides/packaging-namespace-packages.rst:48
msgid "Namespace packages can be useful for a large collection of loosely-related packages (such as a large corpus of client libraries for multiple products from a single company). However, namespace packages come with several caveats and are not appropriate in all cases. A simple alternative is to use a prefix on all of your distributions such as ``import mynamespace_subpackage_a`` (you could even use ``import mynamespace_subpackage_a as subpackage_a`` to keep the import object short)."
msgstr ""

#: ../source/guides/packaging-namespace-packages.rst:58
msgid "Creating a namespace package"
msgstr ""

#: ../source/guides/packaging-namespace-packages.rst:60
msgid "There are currently three different approaches to creating namespace packages:"
msgstr ""

#: ../source/guides/packaging-namespace-packages.rst:62
msgid "Use `native namespace packages`_. This type of namespace package is defined in :pep:`420` and is available in Python 3.3 and later. This is recommended if packages in your namespace only ever need to support Python 3 and installation via ``pip``."
msgstr ""

#: ../source/guides/packaging-namespace-packages.rst:66
msgid "Use `pkgutil-style namespace packages`_. This is recommended for new packages that need to support Python 2 and 3 and installation via both ``pip`` and ``python setup.py install``."
msgstr ""

#: ../source/guides/packaging-namespace-packages.rst:69
msgid "Use `pkg_resources-style namespace packages`_. This method is recommended if you need compatibility with packages already using this method or if your package needs to be zip-safe."
msgstr ""

#: ../source/guides/packaging-namespace-packages.rst:73
msgid "While native namespace packages and pkgutil-style namespace packages are largely compatible, pkg_resources-style namespace packages are not compatible with the other methods. It's inadvisable to use different methods in different distributions that provide packages to the same namespace."
msgstr ""

#: ../source/guides/packaging-namespace-packages.rst:80
msgid "Native namespace packages"
msgstr ""

#: ../source/guides/packaging-namespace-packages.rst:82
msgid "Python 3.3 added **implicit** namespace packages from :pep:`420`. All that is required to create a native namespace package is that you just omit :file:`__init__.py` from the namespace package directory. An example file structure:"
msgstr ""

#: ../source/guides/packaging-namespace-packages.rst:97
msgid "It is extremely important that every distribution that uses the namespace package omits the :file:`__init__.py` or uses a pkgutil-style :file:`__init__.py`. If any distribution does not, it will cause the namespace logic to fail and the other sub-packages will not be importable."
msgstr ""

#: ../source/guides/packaging-namespace-packages.rst:102
msgid "Because ``mynamespace`` doesn't contain an :file:`__init__.py`, :func:`setuptools.find_packages` won't find the sub-package. You must use :func:`setuptools.find_namespace_packages` instead or explicitly list all packages in your :file:`setup.py`. For example:"
msgstr ""

#: ../source/guides/packaging-namespace-packages.rst:117
msgid "A complete working example of two native namespace packages can be found in the `native namespace package example project`_."
msgstr ""

#: ../source/guides/packaging-namespace-packages.rst:123
msgid "Because native and pkgutil-style namespace packages are largely compatible, you can use native namespace packages in the distributions that only support Python 3 and pkgutil-style namespace packages in the distributions that need to support Python 2 and 3."
msgstr ""

#: ../source/guides/packaging-namespace-packages.rst:129
msgid "pkgutil-style namespace packages"
msgstr ""

#: ../source/guides/packaging-namespace-packages.rst:131
msgid "Python 2.3 introduced the `pkgutil`_ module and the `extend_path`_ function. This can be used to declare namespace packages that need to be compatible with both Python 2.3+ and Python 3. This is the recommended approach for the highest level of compatibility."
msgstr ""

#: ../source/guides/packaging-namespace-packages.rst:136
msgid "To create a pkgutil-style namespace package, you need to provide an :file:`__init__.py` file for the namespace package:"
msgstr ""

#: ../source/guides/packaging-namespace-packages.rst:148
#: ../source/guides/packaging-namespace-packages.rst:194
msgid "The :file:`__init__.py` file for the namespace package needs to contain **only** the following:"
msgstr ""

#: ../source/guides/packaging-namespace-packages.rst:155
#: ../source/guides/packaging-namespace-packages.rst:201
msgid "**Every** distribution that uses the namespace package must include an identical :file:`__init__.py`. If any distribution does not, it will cause the namespace logic to fail and the other sub-packages will not be importable.  Any additional code in :file:`__init__.py` will be inaccessible."
msgstr ""

#: ../source/guides/packaging-namespace-packages.rst:160
msgid "A complete working example of two pkgutil-style namespace packages can be found in the `pkgutil namespace example project`_."
msgstr ""

#: ../source/guides/packaging-namespace-packages.rst:171
msgid "pkg_resources-style namespace packages"
msgstr ""

#: ../source/guides/packaging-namespace-packages.rst:173
msgid "`Setuptools`_ provides the `pkg_resources.declare_namespace`_ function and the ``namespace_packages`` argument to :func:`~setuptools.setup`. Together these can be used to declare namespace packages. While this approach is no longer recommended, it is widely present in most existing namespace packages. If you are creating a new distribution within an existing namespace package that uses this method then it's recommended to continue using this as the different methods are not cross-compatible and it's not advisable to try to migrate an existing package."
msgstr ""

#: ../source/guides/packaging-namespace-packages.rst:182
msgid "To create a pkg_resources-style namespace package, you need to provide an :file:`__init__.py` file for the namespace package:"
msgstr ""

#: ../source/guides/packaging-namespace-packages.rst:206
msgid "Some older recommendations advise the following in the namespace package :file:`__init__.py`:"
msgstr ""

#: ../source/guides/packaging-namespace-packages.rst:216
msgid "The idea behind this was that in the rare case that setuptools isn't available packages would fall-back to the pkgutil-style packages. This isn't advisable because pkgutil and pkg_resources-style namespace packages are not cross-compatible. If the presence of setuptools is a concern then the package should just explicitly depend on setuptools via ``install_requires``."
msgstr ""

#: ../source/guides/packaging-namespace-packages.rst:223
msgid "Finally, every distribution must provide the ``namespace_packages`` argument to :func:`~setuptools.setup` in :file:`setup.py`. For example:"
msgstr ""

#: ../source/guides/packaging-namespace-packages.rst:237
msgid "A complete working example of two pkg_resources-style namespace packages can be found in the `pkg_resources namespace example project`_."
msgstr ""

#: ../source/guides/publishing-package-distribution-releases-using-github-actions-ci-cd-workflows.rst:3
msgid "Publishing package distribution releases using GitHub Actions CI/CD workflows"
msgstr ""

#: ../source/guides/publishing-package-distribution-releases-using-github-actions-ci-cd-workflows.rst:5
msgid "`GitHub Actions CI/CD`_ allows you to run a series of commands whenever an event occurs on the GitHub platform. One popular choice is having a workflow that's triggered by a ``push`` event. This guide shows you how to publish a Python distribution whenever a tagged commit is pushed. It will use the `pypa/gh-action-pypi-publish GitHub Action`_."
msgstr ""

#: ../source/guides/publishing-package-distribution-releases-using-github-actions-ci-cd-workflows.rst:15
msgid "This guide *assumes* that you already have a project that you know how to build distributions for and *it lives on GitHub*."
msgstr ""

#: ../source/guides/publishing-package-distribution-releases-using-github-actions-ci-cd-workflows.rst:19
msgid "Saving credentials on GitHub"
msgstr ""

#: ../source/guides/publishing-package-distribution-releases-using-github-actions-ci-cd-workflows.rst:21
msgid "In this guide, we'll demonstrate uploading to both PyPI and TestPyPI, meaning that we'll have two separate sets of credentials. And we'll need to save them in the GitHub repository settings."
msgstr ""

#: ../source/guides/publishing-package-distribution-releases-using-github-actions-ci-cd-workflows.rst:26
msgid "Let's begin! 🚀"
msgstr ""

#: ../source/guides/publishing-package-distribution-releases-using-github-actions-ci-cd-workflows.rst:28
msgid "Go to https://pypi.org/manage/account/#api-tokens and create a new `API token`_. If you have the project on PyPI already, limit the token scope to just that project. You can call it something like ``GitHub Actions CI/CD — project-org/project-repo`` in order for it to be easily distinguishable in the token list. **Don't close the page just yet — you won't see that token again.**"
msgstr ""

#: ../source/guides/publishing-package-distribution-releases-using-github-actions-ci-cd-workflows.rst:37
msgid "In a separate browser tab or window, go to the ``Settings`` tab of your target repository and then click on `Secrets`_ in the left sidebar."
msgstr ""

#: ../source/guides/publishing-package-distribution-releases-using-github-actions-ci-cd-workflows.rst:40
msgid "Create a new secret called ``PYPI_API_TOKEN`` and copy-paste the token from the first step."
msgstr ""

#: ../source/guides/publishing-package-distribution-releases-using-github-actions-ci-cd-workflows.rst:42
msgid "Now, go to https://test.pypi.org/manage/account/#api-tokens and repeat the steps. Save that TestPyPI token on GitHub as ``TEST_PYPI_API_TOKEN``."
msgstr ""

#: ../source/guides/publishing-package-distribution-releases-using-github-actions-ci-cd-workflows.rst:48
msgid "If you don't have a TestPyPI account, you'll need to create it. It's not the same as a regular PyPI account."
msgstr ""

#: ../source/guides/publishing-package-distribution-releases-using-github-actions-ci-cd-workflows.rst:53
msgid "Creating a workflow definition"
msgstr ""

#: ../source/guides/publishing-package-distribution-releases-using-github-actions-ci-cd-workflows.rst:55
msgid "GitHub CI/CD workflows are declared in YAML files stored in the ``.github/workflows/`` directory of your repository."
msgstr ""

#: ../source/guides/publishing-package-distribution-releases-using-github-actions-ci-cd-workflows.rst:58
msgid "Let's create a ``.github/workflows/publish-to-test-pypi.yml`` file."
msgstr ""

#: ../source/guides/publishing-package-distribution-releases-using-github-actions-ci-cd-workflows.rst:61
msgid "Start it with a meaningful name and define the event that should make GitHub run this workflow:"
msgstr ""

#: ../source/guides/publishing-package-distribution-releases-using-github-actions-ci-cd-workflows.rst:70
msgid "Defining a workflow job environment"
msgstr ""

#: ../source/guides/publishing-package-distribution-releases-using-github-actions-ci-cd-workflows.rst:72
msgid "Now, let's add initial setup for our job. It's a process that will execute commands that we'll define later. In this guide, we'll use Ubuntu 18.04:"
msgstr ""

#: ../source/guides/publishing-package-distribution-releases-using-github-actions-ci-cd-workflows.rst:83
msgid "Checking out the project and building distributions"
msgstr ""

#: ../source/guides/publishing-package-distribution-releases-using-github-actions-ci-cd-workflows.rst:85
msgid "Then, add the following under the ``build-n-publish`` section:"
msgstr ""

#: ../source/guides/publishing-package-distribution-releases-using-github-actions-ci-cd-workflows.rst:92
msgid "This will download your repository into the CI runner and then install and activate Python 3.7."
msgstr ""

#: ../source/guides/publishing-package-distribution-releases-using-github-actions-ci-cd-workflows.rst:95
msgid "And now we can build dists from source. In this example, we'll use ``build`` package, assuming that your project has a ``pyproject.toml`` properly set up (see :pep:`517`/:pep:`518`)."
msgstr ""

#: ../source/guides/publishing-package-distribution-releases-using-github-actions-ci-cd-workflows.rst:102
msgid "You can use any other method for building distributions as long as it produces ready-to-upload artifacts saved into the ``dist/`` folder."
msgstr ""

#: ../source/guides/publishing-package-distribution-releases-using-github-actions-ci-cd-workflows.rst:106
msgid "So add this to the steps list:"
msgstr ""

#: ../source/guides/publishing-package-distribution-releases-using-github-actions-ci-cd-workflows.rst:115
msgid "Publishing the distribution to PyPI and TestPyPI"
msgstr ""

#: ../source/guides/publishing-package-distribution-releases-using-github-actions-ci-cd-workflows.rst:117
msgid "Finally, add the following steps at the end:"
msgstr ""

#: ../source/guides/publishing-package-distribution-releases-using-github-actions-ci-cd-workflows.rst:123
msgid "These two steps use the `pypa/gh-action-pypi-publish`_ GitHub Action: the first one uploads contents of the ``dist/`` folder into TestPyPI unconditionally and the second does that to PyPI, but only if the current commit is tagged."
msgstr ""

#: ../source/guides/publishing-package-distribution-releases-using-github-actions-ci-cd-workflows.rst:130
msgid "That's all, folks!"
msgstr ""

#: ../source/guides/publishing-package-distribution-releases-using-github-actions-ci-cd-workflows.rst:132
msgid "Now, whenever you push a tagged commit to your Git repository remote on GitHub, this workflow will publish it to PyPI. And it'll publish any push to TestPyPI which is useful for providing test builds to your alpha users as well as making sure that your release pipeline remains healthy!"
msgstr ""

#: ../source/guides/single-sourcing-package-version.rst:5
msgid "Single-sourcing the package version"
msgstr ""

#: ../source/guides/single-sourcing-package-version.rst:8
msgid "There are many techniques to maintain a single source of truth for the version number of your project:"
msgstr ""

#: ../source/guides/single-sourcing-package-version.rst:11
msgid "Read the file in :file:`setup.py` and get the version. Example (from `pip setup.py <https://github.com/pypa/pip/blob/master/setup.py#L11>`_)::"
msgstr ""

#: ../source/guides/single-sourcing-package-version.rst:38
msgid "As of the release of setuptools 46.4.0, one can accomplish the same thing by instead placing the following in the project's ``setup.cfg`` file (replacing \"package\" with the import name of the package):"
msgstr ""

#: ../source/guides/single-sourcing-package-version.rst:47
msgid "Earlier versions of setuptools implemented the ``attr:`` directive by importing the module, but setuptools 46.4.0 added rudimentary AST analysis so that ``attr:`` can function without having to import any of the package's dependencies."
msgstr ""

#: ../source/guides/single-sourcing-package-version.rst:52
msgid "Also, please be aware that declarative config indicators, including the ``attr:`` directive, are not supported in parameters to ``setup.py``."
msgstr ""

#: ../source/guides/single-sourcing-package-version.rst:55
msgid "Use an external build tool that either manages updating both locations, or offers an API that both locations can use."
msgstr ""

#: ../source/guides/single-sourcing-package-version.rst:58
msgid "Few tools you could use, in no particular order, and not necessarily complete: `bump2version <https://pypi.org/project/bump2version>`_, `changes <https://pypi.org/project/changes>`_, `commitizen <https://pypi.org/project/commitizen>`_, `zest.releaser <https://pypi.org/project/zest.releaser>`_."
msgstr ""

#: ../source/guides/single-sourcing-package-version.rst:65
msgid "Set the value to a ``__version__`` global variable in a dedicated module in your project (e.g. :file:`version.py`), then have :file:`setup.py` read and ``exec`` the value into a variable."
msgstr ""

#: ../source/guides/single-sourcing-package-version.rst:76
msgid "Example using this technique: `warehouse <https://github.com/pypa/warehouse/blob/64ca42e42d5613c8339b3ec5e1cb7765c6b23083/warehouse/__about__.py>`_."
msgstr ""

#: ../source/guides/single-sourcing-package-version.rst:78
msgid "Place the value in a simple ``VERSION`` text file and have both :file:`setup.py` and the project code read it."
msgstr ""

#: ../source/guides/single-sourcing-package-version.rst:86
msgid "An advantage with this technique is that it's not specific to Python.  Any tool can read the version."
msgstr ""

#: ../source/guides/single-sourcing-package-version.rst:91
msgid "With this approach you must make sure that the ``VERSION`` file is included in all your source and binary distributions (e.g. add ``include VERSION`` to your :file:`MANIFEST.in`)."
msgstr ""

#: ../source/guides/single-sourcing-package-version.rst:95
msgid "Set the value in :file:`setup.py`, and have the project code use the ``importlib.metadata`` API to fetch the value at runtime. (``importlib.metadata`` was introduced in Python 3.8 and is available to older versions as the ``importlib-metadata`` project.)  An installed project's version can be fetched with the API as follows::"
msgstr ""

#: ../source/guides/single-sourcing-package-version.rst:110
msgid "Be aware that the ``importlib.metadata`` API only knows about what's in the installation metadata, which is not necessarily the code that's currently imported."
msgstr ""

#: ../source/guides/single-sourcing-package-version.rst:114
msgid "If a project uses this method to fetch its version at runtime, then its ``install_requires`` value needs to be edited to install ``importlib-metadata`` on pre-3.8 versions of Python like so::"
msgstr ""

#: ../source/guides/single-sourcing-package-version.rst:128
msgid "An older (and less efficient) alternative to ``importlib.metadata`` is the ``pkg_resources`` API provided by ``setuptools``::"
msgstr ""

#: ../source/guides/single-sourcing-package-version.rst:134
msgid "If a project uses ``pkg_resources`` to fetch its own version at runtime, then ``setuptools`` must be added to the project's ``install_requires`` list."
msgstr ""

#: ../source/guides/single-sourcing-package-version.rst:138
msgid "Example using this technique: `setuptools <https://github.com/pypa/setuptools/blob/master/setuptools/version.py>`_."
msgstr ""

#: ../source/guides/single-sourcing-package-version.rst:141
msgid "Set the value to ``__version__`` in ``sample/__init__.py`` and import ``sample`` in :file:`setup.py`."
msgstr ""

#: ../source/guides/single-sourcing-package-version.rst:155
msgid "Although this technique is common, beware that it will fail if ``sample/__init__.py`` imports packages from ``install_requires`` dependencies, which will very likely not be installed yet when :file:`setup.py` is run."
msgstr ""

#: ../source/guides/single-sourcing-package-version.rst:161
msgid "Keep the version number in the tags of a version control system (Git, Mercurial, etc) instead of in the code, and automatically extract it from there using `setuptools_scm <https://pypi.org/project/setuptools_scm>`_."
msgstr ""

#: ../source/guides/supporting-multiple-python-versions.rst:5
msgid "Supporting multiple Python versions"
msgstr ""

#: ../source/guides/supporting-multiple-python-versions.rst:37
msgid "In addition to the work required to create a Python package, it is often necessary that the package must be made available on different versions of Python.  Different Python versions may contain different (or renamed) standard library packages, and the changes between Python versions 2.x and 3.x include changes in the language syntax."
msgstr ""

#: ../source/guides/supporting-multiple-python-versions.rst:43
msgid "Performed manually, all the testing required to ensure that the package works correctly on all the target Python versions (and OSs!) could be very time-consuming. Fortunately, several tools are available for dealing with this, and these will briefly be discussed here."
msgstr ""

#: ../source/guides/supporting-multiple-python-versions.rst:49
msgid "Automated testing and continuous integration"
msgstr ""

#: ../source/guides/supporting-multiple-python-versions.rst:51
msgid "Several hosted services for automated testing are available. These services will typically monitor your source code repository (e.g. at `Github <https://github.com>`_ or `Bitbucket <https://bitbucket.org>`_) and run your project's test suite every time a new commit is made."
msgstr ""

#: ../source/guides/supporting-multiple-python-versions.rst:56
msgid "These services also offer facilities to run your project's test suite on *multiple versions of Python*, giving rapid feedback about whether the code will work, without the developer having to perform such tests themselves."
msgstr ""

#: ../source/guides/supporting-multiple-python-versions.rst:60
msgid "Wikipedia has an extensive `comparison <http://en.wikipedia.org/wiki/Comparison_of_continuous_integration_software>`_ of many continuous-integration systems. There are two hosted services which when used in conjunction provide automated testing across Linux, Mac and Windows:"
msgstr ""

#: ../source/guides/supporting-multiple-python-versions.rst:66
msgid "`Travis CI <https://travis-ci.org>`_ provides both a Linux and a macOS environment. The Linux environment is Ubuntu 12.04 LTS Server Edition 64 bit while the macOS is 10.9.2 at the time of writing."
msgstr ""

#: ../source/guides/supporting-multiple-python-versions.rst:69
msgid "`Appveyor <http://www.appveyor.com>`_ provides a Windows environment (Windows Server 2012)."
msgstr ""

#: ../source/guides/supporting-multiple-python-versions.rst:80
msgid "Both `Travis CI`_ and Appveyor_ require a `YAML <http://www.yaml.org>`_-formatted file as specification for the instructions for testing. If any tests fail, the output log for that specific configuration can be inspected."
msgstr ""

#: ../source/guides/supporting-multiple-python-versions.rst:85
msgid "For Python projects that are intended to be deployed on both Python 2 and 3 with a single-source strategy, there are a number of options."
msgstr ""

#: ../source/guides/supporting-multiple-python-versions.rst:89
msgid "Tools for single-source Python packages"
msgstr ""

#: ../source/guides/supporting-multiple-python-versions.rst:91
msgid "`six <http://pythonhosted.org/six/>`_ is a tool developed by Benjamin Peterson for wrapping over the differences between Python 2 and Python 3. The six_ package has enjoyed widespread use and may be regarded as a reliable way to write a single-source Python module that can be use in both Python 2 and 3. The six_ module can be used from as early as Python 2.5. A tool called `modernize <https://pypi.org/project/modernize>`_, developed by Armin Ronacher, can be used to automatically apply the code modifications provided by six_."
msgstr ""

#: ../source/guides/supporting-multiple-python-versions.rst:100
msgid "Similar to six_, `python-future <http://python-future.org/overview.html>`_ is a package that provides a compatibility layer between Python 2 and Python 3 source code; however, unlike six_, this package aims to provide interoperability between Python 2 and Python 3 with a language syntax that matches one of the two Python versions: one may use"
msgstr ""

#: ../source/guides/supporting-multiple-python-versions.rst:107
msgid "a Python 2 (by syntax) module in a Python 3 project."
msgstr ""

#: ../source/guides/supporting-multiple-python-versions.rst:108
msgid "a Python 3 (by syntax) module in a *Python 2* project."
msgstr ""

#: ../source/guides/supporting-multiple-python-versions.rst:110
msgid "Because of the bi-directionality, python-future_ offers a pathway to converting a Python 2 package to Python 3 syntax module-by-module. However, in contrast to six_, python-future_ is supported only from Python 2.6. Similar to modernize_ for six_, python-future_ comes with two scripts called ``futurize`` and ``pasteurize`` that can be applied to either a Python 2 module or a Python 3 module respectively."
msgstr ""

#: ../source/guides/supporting-multiple-python-versions.rst:117
msgid "Use of six_ or python-future_ adds an additional runtime dependency to your package: with python-future_, the ``futurize`` script can be called with the ``--stage1`` option to apply only the changes that Python 2.6+ already provides for forward-compatibility to Python 3. Any remaining compatibility problems would require manual changes."
msgstr ""

#: ../source/guides/supporting-multiple-python-versions.rst:124
msgid "What's in which Python?"
msgstr ""

#: ../source/guides/supporting-multiple-python-versions.rst:126
msgid "Ned Batchelder provides a list of changes in each Python release for `Python 2 <https://nedbatchelder.com/blog/201109/whats_in_which_python.html>`__, `Python 3.0-3.3 <https://nedbatchelder.com/blog/201310/whats_in_which_python_3.html>`__ and `Python 3.4-3.6 <https://nedbatchelder.com/blog/201803/whats_in_which_python_3436.html>`__. These lists may be used to check whether any changes between Python versions may affect your package."
msgstr ""

#: ../source/guides/supporting-windows-using-appveyor.rst:3
msgid "Supporting Windows using Appveyor"
msgstr ""

#: ../source/guides/supporting-windows-using-appveyor.rst:6
msgid "2015-12-03"
msgstr ""

#: ../source/guides/supporting-windows-using-appveyor.rst:8
msgid "This section covers how to use the free `Appveyor`_ continuous integration service to provide Windows support for your project. This includes testing the code on Windows, and building Windows-targeted binaries for projects that use C extensions."
msgstr ""

#: ../source/guides/supporting-windows-using-appveyor.rst:20
msgid "Many projects are developed on Unix by default, and providing Windows support can be a challenge, because setting up a suitable Windows test environment is non-trivial, and may require buying software licenses."
msgstr ""

#: ../source/guides/supporting-windows-using-appveyor.rst:24
msgid "The Appveyor service is a continuous integration service, much like the better-known `Travis`_ service that is commonly used for testing by projects hosted on `Github`_. However, unlike Travis, the build workers on Appveyor are Windows hosts and have the necessary compilers installed to build Python extensions."
msgstr ""

#: ../source/guides/supporting-windows-using-appveyor.rst:30
msgid "Windows users typically do not have access to a C compiler, and therefore are reliant on projects that use C extensions distributing binary wheels on PyPI in order for the distribution to be installable via ``python -m pip install <dist>``. By using Appveyor as a build service (even if not using it for testing) it is possible for projects without a dedicated Windows environment to provide Windows-targeted binaries."
msgstr ""

#: ../source/guides/supporting-windows-using-appveyor.rst:38
msgid "Setting up"
msgstr ""

#: ../source/guides/supporting-windows-using-appveyor.rst:40
msgid "In order to use Appveyor to build Windows wheels for your project, you must have an account on the service. Instructions on setting up an account are given in `the Appveyor documentation <http://www.appveyor.com/docs>`__. The free tier of account is perfectly adequate for open source projects."
msgstr ""

#: ../source/guides/supporting-windows-using-appveyor.rst:45
msgid "Appveyor provides integration with `Github`_ and `Bitbucket`_, so as long as your project is hosted on one of those two services, setting up Appveyor integration is straightforward."
msgstr ""

#: ../source/guides/supporting-windows-using-appveyor.rst:49
msgid "Once you have set up your Appveyor account and added your project, Appveyor will automatically build your project each time a commit occurs. This behaviour will be familiar to users of Travis."
msgstr ""

#: ../source/guides/supporting-windows-using-appveyor.rst:54
msgid "Adding Appveyor support to your project"
msgstr ""

#: ../source/guides/supporting-windows-using-appveyor.rst:56
msgid "In order to define how Appveyor should build your project, you need to add an :file:`appveyor.yml` file to your project. The full details of what can be included in the file are covered in the Appveyor documentation. This guide will provide the details necessary to set up wheel builds."
msgstr ""

#: ../source/guides/supporting-windows-using-appveyor.rst:61
msgid "Appveyor includes by default all of the compiler toolchains needed to build extensions for Python. For Python 2.7, 3.5+ and 32-bit versions of 3.3 and 3.4, the tools work out of the box. But for 64-bit versions of Python 3.3 and 3.4, there is a small amount of additional configuration needed to let distutils know where to find the 64-bit compilers. (From 3.5 onwards, the version of Visual Studio used includes 64-bit compilers with no additional setup)."
msgstr ""

#: ../source/guides/supporting-windows-using-appveyor.rst:69
msgid "appveyor.yml"
msgstr ""

#: ../source/guides/supporting-windows-using-appveyor.rst:75
msgid "This file can be downloaded from `here <https://raw.githubusercontent.com/pypa/python-packaging-user-guide/master/source/guides/appveyor-sample/appveyor.yml>`__."
msgstr ""

#: ../source/guides/supporting-windows-using-appveyor.rst:77
msgid "The :file:`appveyor.yml` file must be located in the root directory of your project. It is in ``YAML`` format, and consists of a number of sections."
msgstr ""

#: ../source/guides/supporting-windows-using-appveyor.rst:80
msgid "The ``environment`` section is the key to defining the Python versions for which your wheels will be created. Appveyor comes with Python 2.6, 2.7, 3.3, 3.4 and 3.5 installed, in both 32-bit and 64-bit builds. The example file builds for all of these environments except Python 2.6. Installing for Python 2.6 is more complex, as it does not come with pip included. We don't support 2.6 in this document (as Windows users still using Python 2 are generally able to move to Python 2.7 without too much difficulty)."
msgstr ""

#: ../source/guides/supporting-windows-using-appveyor.rst:88
msgid "The ``install`` section uses pip to install any additional software that the project may require. The only requirement for building wheels is the ``wheel`` project, but projects may wish to customise this code in certain circumstances (for example, to install additional build packages such as ``Cython``, or test tools such as ``tox``)."
msgstr ""

#: ../source/guides/supporting-windows-using-appveyor.rst:94
msgid "The ``build`` section simply switches off builds - there is no build step needed for Python, unlike languages like ``C#``."
msgstr ""

#: ../source/guides/supporting-windows-using-appveyor.rst:97
msgid "The main sections that will need to be tailored to your project are ``test_script`` and ``after_test``."
msgstr ""

#: ../source/guides/supporting-windows-using-appveyor.rst:100
msgid "The ``test_script`` section is where you will run your project's tests. The supplied file runs your test suite using ``setup.py test``. If you are only interested in building wheels, and not in running your tests on Windows, you can replace this section with a dummy command such as ``echo Skipped Tests``. You may wish to use another test tool, such as ``nose`` or :file:`py.test`.  Or you may wish to use a test driver like ``tox`` - however if you are using ``tox`` there are some additional configuration changes you will need to consider, which are described below."
msgstr ""

#: ../source/guides/supporting-windows-using-appveyor.rst:109
msgid "The ``after_test`` runs once your tests have completed, and so is where the wheels should be built. Assuming your project uses the recommended tools (specifically, ``setuptools``) then the ``setup.py bdist_wheel`` command will build your wheels."
msgstr ""

#: ../source/guides/supporting-windows-using-appveyor.rst:114
msgid "Note that wheels will only be built if your tests succeed. If you expect your tests to fail on Windows, you can skip them as described above."
msgstr ""

#: ../source/guides/supporting-windows-using-appveyor.rst:119
msgid "Support script"
msgstr ""

#: ../source/guides/supporting-windows-using-appveyor.rst:121
msgid "The :file:`appveyor.yml` file relies on a single support script, which sets up the environment to use the SDK compiler for 64-bit builds on Python 3.3 and 3.4.  For projects which do not need a compiler, or which don't support 3.3 or 3.4 on 64-bit Windows, only the :file:`appveyor.yml` file is needed."
msgstr ""

#: ../source/guides/supporting-windows-using-appveyor.rst:126
msgid "`build.cmd <https://raw.githubusercontent.com/pypa/python-packaging-user-guide/master/source/guides/appveyor-sample/build.cmd>`__ is a Windows batch script that runs a single command in an environment with the appropriate compiler for the selected Python version. All you need to do is to set the single environment variable ``DISTUTILS_USE_SDK`` to a value of ``1`` and the script does the rest. It sets up the SDK needed for 64-bit builds of Python 3.3 or 3.4, so don't set the environment variable for any other builds."
msgstr ""

#: ../source/guides/supporting-windows-using-appveyor.rst:133
msgid "You can simply download the batch file and include it in your project unchanged."
msgstr ""

#: ../source/guides/supporting-windows-using-appveyor.rst:137
msgid "Access to the built wheels"
msgstr ""

#: ../source/guides/supporting-windows-using-appveyor.rst:139
msgid "When your build completes, the built wheels will be available from the Appveyor control panel for your project. They can be found by going to the build status page for each build in turn. At the top of the build output there is a series of links, one of which is \"Artifacts\". That page will include a list of links to the wheels for that Python version / architecture. You can download those wheels and upload them to PyPI as part of your release process."
msgstr ""

#: ../source/guides/supporting-windows-using-appveyor.rst:147
msgid "Additional notes"
msgstr ""

#: ../source/guides/supporting-windows-using-appveyor.rst:150
msgid "Testing with tox"
msgstr ""

#: ../source/guides/supporting-windows-using-appveyor.rst:152
msgid "Many projects use the `Tox`_ tool to run their tests. It ensures that tests are run in an isolated environment using the exact files that will be distributed by the project."
msgstr ""

#: ../source/guides/supporting-windows-using-appveyor.rst:156
msgid "In order to use ``tox`` on Appveyor there are a couple of additional considerations (in actual fact, these issues are not specific to Appveyor, and may well affect other CI systems)."
msgstr ""

#: ../source/guides/supporting-windows-using-appveyor.rst:160
msgid "By default, ``tox`` only passes a chosen subset of environment variables to the test processes. Because ``distutils`` uses environment variables to control the compiler, this \"test isolation\" feature will cause the tests to use the wrong compiler by default."
msgstr ""

#: ../source/guides/supporting-windows-using-appveyor.rst:165
msgid "To force ``tox`` to pass the necessary environment variables to the subprocess, you need to set the ``tox`` configuration option ``passenv`` to list the additional environment variables to be passed to the subprocess. For the SDK compilers, you need"
msgstr ""

#: ../source/guides/supporting-windows-using-appveyor.rst:170
msgid "``DISTUTILS_USE_SDK``"
msgstr ""

#: ../source/guides/supporting-windows-using-appveyor.rst:171
msgid "``MSSdk``"
msgstr ""

#: ../source/guides/supporting-windows-using-appveyor.rst:172
msgid "``INCLUDE``"
msgstr ""

#: ../source/guides/supporting-windows-using-appveyor.rst:173
msgid "``LIB``"
msgstr ""

#: ../source/guides/supporting-windows-using-appveyor.rst:175
msgid "The ``passenv`` option can be set in your :file:`tox.ini`, or if you prefer to avoid adding Windows-specific settings to your general project files, it can be set by setting the ``TOX_TESTENV_PASSENV`` environment variable. The supplied :file:`build.cmd` script does this by default whenever ``DISTUTILS_USE_SDK`` is set."
msgstr ""

#: ../source/guides/supporting-windows-using-appveyor.rst:181
msgid "When used interactively, ``tox`` allows you to run your tests against multiple environments (often, this means multiple Python versions). This feature is not as useful in a CI environment like Travis or Appveyor, where all tests are run in isolated environments for each configuration. As a result, projects often supply an argument ``-e ENVNAME`` to ``tox`` to specify which environment to use (there are default environments for most versions of Python)."
msgstr ""

#: ../source/guides/supporting-windows-using-appveyor.rst:188
msgid "However, this does *not* work well with a Windows CI system like Appveyor, where there are (for example) two installations of Python 3.4 (32-bit and 64-bit) available, but only one ``py34`` environment in ``tox``."
msgstr ""

#: ../source/guides/supporting-windows-using-appveyor.rst:192
msgid "In order to run tests using ``tox``, therefore, projects should probably use the default ``py`` environment in ``tox``, which uses the Python interpreter that was used to run ``tox``. This will ensure that when Appveyor runs the tests, they will be run with the configured interpreter."
msgstr ""

#: ../source/guides/supporting-windows-using-appveyor.rst:197
msgid "In order to support running under the ``py`` environment, it is possible that projects with complex ``tox`` configurations might need to modify their :file:`tox.ini` file. Doing so is, however, outside the scope of this document."
msgstr ""

#: ../source/guides/supporting-windows-using-appveyor.rst:203
msgid "Automatically uploading wheels"
msgstr ""

#: ../source/guides/supporting-windows-using-appveyor.rst:205
msgid "It is possible to request Appveyor to automatically upload wheels. There is a ``deployment`` step available in :file:`appveyor.yml` that can be used to (for example) copy the built artifacts to a FTP site, or an Amazon S3 instance. Documentation on how to do this is included in the Appveyor guides."
msgstr ""

#: ../source/guides/supporting-windows-using-appveyor.rst:210
msgid "Alternatively, it would be possible to add a ``twine upload`` step to the build.  The supplied :file:`appveyor.yml` does not do this, as it is not clear that uploading new wheels after every commit is desirable (although some projects may wish to do this)."
msgstr ""

#: ../source/guides/supporting-windows-using-appveyor.rst:216
msgid "External dependencies"
msgstr ""

#: ../source/guides/supporting-windows-using-appveyor.rst:218
msgid "The supplied scripts will successfully build any distribution that does not rely on 3rd party external libraries for the build."
msgstr ""

#: ../source/guides/supporting-windows-using-appveyor.rst:221
msgid "It is possible to add steps to the :file:`appveyor.yml` configuration (typically in the \"install\" section) to download and/or build external libraries needed by the distribution. And if needed, it is possible to add extra configuration for the build to supply the location of these libraries to the compiler. However, this level of configuration is beyond the scope of this document."
msgstr ""

#: ../source/guides/supporting-windows-using-appveyor.rst:230
msgid "Support scripts"
msgstr ""

#: ../source/guides/supporting-windows-using-appveyor.rst:232
msgid "For reference, the SDK setup support script is listed here:"
msgstr ""

#: ../source/guides/supporting-windows-using-appveyor.rst:234
msgid "``appveyor-sample/build.cmd``"
msgstr ""

#: ../source/guides/tool-recommendations.rst:5
msgid "Tool recommendations"
msgstr ""

#: ../source/guides/tool-recommendations.rst:7
msgid "If you're familiar with Python packaging and installation, and just want to know what tools are currently recommended, then here it is."
msgstr ""

#: ../source/guides/tool-recommendations.rst:12
msgid "Application dependency management"
msgstr ""

#: ../source/guides/tool-recommendations.rst:14
msgid "Use :ref:`pipenv` to manage library dependencies when developing Python applications. See :doc:`../tutorials/managing-dependencies` for more details on using ``pipenv``."
msgstr ""

#: ../source/guides/tool-recommendations.rst:18
msgid "When ``pipenv`` does not meet your use case, consider other tools like:"
msgstr ""

#: ../source/guides/tool-recommendations.rst:20
msgid ":ref:`pip`"
msgstr ""

#: ../source/guides/tool-recommendations.rst:22
msgid "`pip-tools <https://github.com/jazzband/pip-tools>`_"
msgstr ""

#: ../source/guides/tool-recommendations.rst:24
msgid "`Poetry <https://python-poetry.org/>`_"
msgstr ""

#: ../source/guides/tool-recommendations.rst:27
msgid "Installation tool recommendations"
msgstr ""

#: ../source/guides/tool-recommendations.rst:29
msgid "Use :ref:`pip` to install Python :term:`packages <Distribution Package>` from :term:`PyPI <Python Package Index (PyPI)>`. [1]_ [2]_ Depending on how :ref:`pip` is installed, you may need to also install :ref:`wheel` to get the benefit of wheel caching. [3]_"
msgstr ""

#: ../source/guides/tool-recommendations.rst:34
msgid "Use :ref:`virtualenv`, or `venv`_ to isolate application specific dependencies from a shared Python installation. [4]_"
msgstr ""

#: ../source/guides/tool-recommendations.rst:37
msgid "If you're looking for management of fully integrated cross-platform software stacks, consider:"
msgstr ""

#: ../source/guides/tool-recommendations.rst:40
msgid ":ref:`buildout`: primarily focused on the web development community"
msgstr ""

#: ../source/guides/tool-recommendations.rst:42
msgid ":ref:`spack`, :ref:`hashdist`, or :ref:`conda`: primarily focused on the scientific community."
msgstr ""

#: ../source/guides/tool-recommendations.rst:47
msgid "Packaging tool recommendations"
msgstr ""

#: ../source/guides/tool-recommendations.rst:49
msgid "Use :ref:`setuptools` to define projects and create :term:`Source Distributions <Source Distribution (or \"sdist\")>`. [5]_ [6]_"
msgstr ""

#: ../source/guides/tool-recommendations.rst:52
msgid "Use the ``bdist_wheel`` :ref:`setuptools` extension available from the :ref:`wheel project <wheel>` to create :term:`wheels <Wheel>`.  This is especially beneficial, if your project contains binary extensions."
msgstr ""

#: ../source/guides/tool-recommendations.rst:56
msgid "Use `twine <https://pypi.org/project/twine>`_ for uploading distributions to :term:`PyPI <Python Package Index (PyPI)>`."
msgstr ""

#: ../source/guides/tool-recommendations.rst:61
msgid "Publishing platform migration"
msgstr ""

#: ../source/guides/tool-recommendations.rst:63
msgid "The original Python Package Index implementation (previously hosted at `pypi.python.org <https://pypi.python.org>`_) has been phased out in favour of an updated implementation hosted at `pypi.org <https://pypi.org>`_."
msgstr ""

#: ../source/guides/tool-recommendations.rst:67
msgid "See :ref:`Migrating to PyPI.org` for more information on the status of the migration, and what settings to change in your clients."
msgstr ""

#: ../source/guides/tool-recommendations.rst:72
msgid "There are some cases where you might choose to use ``easy_install`` (from :ref:`setuptools`), e.g. if you need to install from :term:`Eggs <Egg>` (which pip doesn't support).  For a detailed breakdown, see :ref:`pip vs easy_install`."
msgstr ""

#: ../source/guides/tool-recommendations.rst:77
msgid "The acceptance of :pep:`453` means that :ref:`pip` will be available by default in most installations of Python 3.4 or later.  See the :pep:`rationale section <453#rationale>` from :pep:`453` as for why pip was chosen."
msgstr ""

#: ../source/guides/tool-recommendations.rst:82
msgid "`get-pip.py <https://github.com/pypa/get-pip/#readme>`_ and :ref:`virtualenv` install :ref:`wheel`, whereas :ref:`ensurepip` and :ref:`venv <venv>` do not currently.  Also, the common \"python-pip\" package that's found in various linux distros, does not depend on \"python-wheel\" currently."
msgstr ""

#: ../source/guides/tool-recommendations.rst:88
msgid "Beginning with Python 3.4, ``venv`` will create virtualenv environments with ``pip`` installed, thereby making it an equal alternative to :ref:`virtualenv`. However, using :ref:`virtualenv` will still be recommended for users that need cross-version consistency."
msgstr ""

#: ../source/guides/tool-recommendations.rst:93
msgid "Although you can use pure ``distutils`` for many projects, it does not support defining dependencies on other projects and is missing several convenience utilities for automatically populating distribution metadata correctly that are provided by ``setuptools``. Being outside the standard library, ``setuptools`` also offers a more consistent feature set across different versions of Python, and (unlike ``distutils``), recent versions of ``setuptools`` support all of the modern metadata fields described in :ref:`core-metadata`."
msgstr ""

#: ../source/guides/tool-recommendations.rst:102
msgid "Even for projects that do choose to use ``distutils``, when :ref:`pip` installs such projects directly from source (rather than installing from a prebuilt :term:`wheel <Wheel>` file), it will actually build your project using :ref:`setuptools` instead."
msgstr ""

#: ../source/guides/tool-recommendations.rst:107
msgid "`distribute`_ (a fork of setuptools) was merged back into :ref:`setuptools` in June 2013, thereby making setuptools the default choice for packaging."
msgstr ""

#: ../source/guides/using-manifest-in.rst:5
msgid "Including files in source distributions with ``MANIFEST.in``"
msgstr ""

#: ../source/guides/using-manifest-in.rst:7
msgid "When building a :term:`source distribution <Source Distribution (or \"sdist\")>` for your package, by default only a minimal set of files are included.  You may find yourself wanting to include extra files in the source distribution, such as an authors/contributors file, a :file:`docs/` directory, or a directory of data files used for testing purposes.  There may even be extra files that you *need* to include; for example, if your :file:`setup.py` computes your project's ``long_description`` by reading from both a README and a changelog file, you'll need to include both those files in the sdist so that people that build or install from the sdist get the correct results."
msgstr ""

#: ../source/guides/using-manifest-in.rst:17
msgid "Adding & removing files to & from the source distribution is done by writing a :file:`MANIFEST.in` file at the project root."
msgstr ""

#: ../source/guides/using-manifest-in.rst:22
msgid "How files are included in an sdist"
msgstr ""

#: ../source/guides/using-manifest-in.rst:24
msgid "The following files are included in a source distribution by default:"
msgstr ""

#: ../source/guides/using-manifest-in.rst:26
msgid "all Python source files implied by the ``py_modules`` and ``packages`` ``setup()`` arguments"
msgstr ""

#: ../source/guides/using-manifest-in.rst:28
msgid "all C source files mentioned in the ``ext_modules`` or ``libraries`` ``setup()`` arguments"
msgstr ""

#: ../source/guides/using-manifest-in.rst:30
msgid "scripts specified by the ``scripts`` ``setup()`` argument"
msgstr ""

#: ../source/guides/using-manifest-in.rst:31
msgid "all files specified by the ``package_data`` and ``data_files`` ``setup()`` arguments"
msgstr ""

#: ../source/guides/using-manifest-in.rst:33
msgid "the file specified by the ``license_file`` option in :file:`setup.cfg` (setuptools 40.8.0+)"
msgstr ""

#: ../source/guides/using-manifest-in.rst:35
msgid "all files specified by the ``license_files`` option in :file:`setup.cfg` (setuptools 42.0.0+)"
msgstr ""

#: ../source/guides/using-manifest-in.rst:37
msgid "all files matching the pattern :file:`test/test*.py`"
msgstr ""

#: ../source/guides/using-manifest-in.rst:38
msgid ":file:`setup.py` (or whatever you called your setup script)"
msgstr ""

#: ../source/guides/using-manifest-in.rst:39
msgid ":file:`setup.cfg`"
msgstr ""

#: ../source/guides/using-manifest-in.rst:40
msgid ":file:`README`"
msgstr ""

#: ../source/guides/using-manifest-in.rst:41
msgid ":file:`README.txt`"
msgstr ""

#: ../source/guides/using-manifest-in.rst:42
msgid ":file:`README.rst` (Python 3.7+ or setuptools 0.6.27+)"
msgstr ""

#: ../source/guides/using-manifest-in.rst:43
msgid ":file:`README.md` (setuptools 36.4.0+)"
msgstr ""

#: ../source/guides/using-manifest-in.rst:44
msgid ":file:`pyproject.toml` (setuptools 43.0.0+)"
msgstr ""

#: ../source/guides/using-manifest-in.rst:45
msgid ":file:`MANIFEST.in`"
msgstr ""

#: ../source/guides/using-manifest-in.rst:47
msgid "After adding the above files to the sdist, the commands in :file:`MANIFEST.in` (if such a file exists) are executed in order to add and remove further files to & from the sdist.  Default files can even be removed from the sdist with the appropriate :file:`MANIFEST.in` command."
msgstr ""

#: ../source/guides/using-manifest-in.rst:52
msgid "After processing the :file:`MANIFEST.in` file, setuptools removes the :file:`build/` directory as well as any directories named :file:`RCS`, :file:`CVS`, or :file:`.svn` from the sdist, and it adds a :file:`PKG-INFO` file and an :file:`*.egg-info` directory.  This behavior cannot be changed with :file:`MANIFEST.in`."
msgstr ""

#: ../source/guides/using-manifest-in.rst:60
msgid ":file:`MANIFEST.in` commands"
msgstr ""

#: ../source/guides/using-manifest-in.rst:62
msgid "A :file:`MANIFEST.in` file consists of commands, one per line, instructing setuptools to add or remove some set of files from the sdist.  The commands are:"
msgstr ""

#: ../source/guides/using-manifest-in.rst:67
msgid "Command"
msgstr ""

#: ../source/guides/using-manifest-in.rst:69
msgid ":samp:`include {pat1} {pat2} ...`"
msgstr ""

#: ../source/guides/using-manifest-in.rst:69
msgid "Add all files matching any of the listed patterns"
msgstr ""

#: ../source/guides/using-manifest-in.rst:70
msgid ":samp:`exclude {pat1} {pat2} ...`"
msgstr ""

#: ../source/guides/using-manifest-in.rst:70
msgid "Remove all files matching any of the listed patterns"
msgstr ""

#: ../source/guides/using-manifest-in.rst:71
msgid ":samp:`recursive-include {dir-pattern} {pat1} {pat2} ...`"
msgstr ""

#: ../source/guides/using-manifest-in.rst:71
msgid "Add all files under directories matching ``dir-pattern`` that match any of the listed patterns"
msgstr ""

#: ../source/guides/using-manifest-in.rst:72
msgid ":samp:`recursive-exclude {dir-pattern} {pat1} {pat2} ...`"
msgstr ""

#: ../source/guides/using-manifest-in.rst:72
msgid "Remove all files under directories matching ``dir-pattern`` that match any of the listed patterns"
msgstr ""

#: ../source/guides/using-manifest-in.rst:73
msgid ":samp:`global-include {pat1} {pat2} ...`"
msgstr ""

#: ../source/guides/using-manifest-in.rst:73
msgid "Add all files anywhere in the source tree matching any of the listed patterns"
msgstr ""

#: ../source/guides/using-manifest-in.rst:74
msgid ":samp:`global-exclude {pat1} {pat2} ...`"
msgstr ""

#: ../source/guides/using-manifest-in.rst:74
msgid "Remove all files anywhere in the source tree matching any of the listed patterns"
msgstr ""

#: ../source/guides/using-manifest-in.rst:75
msgid ":samp:`graft {dir-pattern}`"
msgstr ""

#: ../source/guides/using-manifest-in.rst:75
msgid "Add all files under directories matching ``dir-pattern``"
msgstr ""

#: ../source/guides/using-manifest-in.rst:76
msgid ":samp:`prune {dir-pattern}`"
msgstr ""

#: ../source/guides/using-manifest-in.rst:76
msgid "Remove all files under directories matching ``dir-pattern``"
msgstr ""

#: ../source/guides/using-manifest-in.rst:79
msgid "The patterns here are glob-style patterns: ``*`` matches zero or more regular filename characters (on Unix, everything except forward slash; on Windows, everything except backslash and colon); ``?`` matches a single regular filename character, and ``[chars]`` matches any one of the characters between the square brackets (which may contain character ranges, e.g., ``[a-z]`` or ``[a-fA-F0-9]``).  Setuptools also has undocumented support for ``**`` matching zero or more characters including forward slash, backslash, and colon."
msgstr ""

#: ../source/guides/using-manifest-in.rst:87
msgid "Directory patterns are relative to the root of the project directory; e.g., ``graft example*`` will include a directory named :file:`examples` in the project root but will not include :file:`docs/examples/`."
msgstr ""

#: ../source/guides/using-manifest-in.rst:91
msgid "File & directory names in :file:`MANIFEST.in` should be ``/``-separated; setuptools will automatically convert the slashes to the local platform's appropriate directory separator."
msgstr ""

#: ../source/guides/using-manifest-in.rst:95
msgid "Commands are processed in the order they appear in the :file:`MANIFEST.in` file.  For example, given the commands::"
msgstr ""

#: ../source/guides/using-manifest-in.rst:101
msgid "the contents of the directory tree :file:`tests` will first be added to the sdist, and then after that all files in the sdist with a ``.pyc``, ``.pyo``, or ``.pyd`` extension will be removed from the sdist.  If the commands were in the opposite order, then ``*.pyc`` files etc. would be only be removed from what was already in the sdist before adding :file:`tests`, and if :file:`tests` happened to contain any ``*.pyc`` files, they would end up included in the sdist because the exclusion happened before they were included."
msgstr ""

#: ../source/guides/using-testpypi.rst:7
msgid "``TestPyPI`` is a separate instance of the :term:`Python Package Index (PyPI)` that allows you to try out the distribution tools and process without worrying about affecting the real index. TestPyPI is hosted at `test.pypi.org <https://test.pypi.org>`_"
msgstr ""

#: ../source/guides/using-testpypi.rst:13
msgid "Registering your account"
msgstr ""

#: ../source/guides/using-testpypi.rst:15
msgid "Because TestPyPI has a separate database from the live PyPI, you'll need a separate user account for specifically for TestPyPI. Go to https://test.pypi.org/account/register/ to register your account."
msgstr ""

#: ../source/guides/using-testpypi.rst:19
msgid "The database for TestPyPI may be periodically pruned, so it is not unusual for user accounts to be deleted."
msgstr ""

#: ../source/guides/using-testpypi.rst:24
msgid "Using TestPyPI with Twine"
msgstr ""

#: ../source/guides/using-testpypi.rst:26
msgid "You can upload your distributions to TestPyPI using :ref:`twine` by specifying the ``--repository`` flag"
msgstr ""

#: ../source/guides/using-testpypi.rst:33
msgid "You can see if your package has successfully uploaded by navigating to the URL ``https://test.pypi.org/project/<sampleproject>`` where ``sampleproject`` is the name of your project that you uploaded. It may take a minute or two for your project to appear on the site."
msgstr ""

#: ../source/guides/using-testpypi.rst:39
msgid "Using TestPyPI with pip"
msgstr ""

#: ../source/guides/using-testpypi.rst:41
msgid "You can tell pip to download packages from TestPyPI instead of PyPI by specifying the ``--index-url`` flag"
msgstr ""

#: ../source/guides/using-testpypi.rst:56
msgid "If you want to allow pip to also pull other packages from PyPI you can specify ``--extra-index-url`` to point to PyPI. This is useful when the package you're testing has dependencies:"
msgstr ""

#: ../source/guides/using-testpypi.rst:73
msgid "Setting up TestPyPI in :file:`.pypirc`"
msgstr ""

#: ../source/guides/using-testpypi.rst:75
msgid "If you want to avoid entering your username, you can configure TestPyPI in your :file:`$HOME/.pypirc`:"
msgstr ""

#: ../source/index.rst:3
#: ../source/key_projects.rst:181
msgid "Python Packaging User Guide"
msgstr ""

#: ../source/index.rst:5
msgid "The Python Packaging User Guide (PyPUG) is a collection of tutorials and guides for packaging Python software."
msgstr ""

#: ../source/index.rst:5
msgid "python, packaging, guide, tutorial"
msgstr ""

#: ../source/index.rst:24
msgid "Welcome to the *Python Packaging User Guide*, a collection of tutorials and references to help you distribute and install Python packages with modern tools."
msgstr ""

#: ../source/index.rst:28
msgid "This guide is maintained on `GitHub`_ by the `Python Packaging Authority`_. We happily accept any :doc:`contributions and feedback <contribute>`. 😊"
msgstr ""

#: ../source/index.rst:36
msgid "Get started"
msgstr ""

#: ../source/index.rst:38
msgid "Essential tools and concepts for working within the Python development ecosystem are covered in our :doc:`tutorials/index` section:"
msgstr ""

#: ../source/index.rst:41
msgid "To learn how to install packages, see the :doc:`tutorial on installing packages <tutorials/installing-packages>`"
msgstr ""

#: ../source/index.rst:43
msgid "To learn how to manage dependencies in a version controlled project, see the :doc:`tutorial on managing application dependencies <tutorials/managing-dependencies>`"
msgstr ""

#: ../source/index.rst:45
msgid "To learn how to package and distribute your projects, see the :doc:`tutorial on packaging and distributing <tutorials/packaging-projects>`"
msgstr ""

#: ../source/index.rst:47
msgid "To get an overview of packaging options for Python libraries and applications, see the :doc:`Overview of Python Packaging <overview>`"
msgstr ""

#: ../source/index.rst:52
msgid "Learn more"
msgstr ""

#: ../source/index.rst:54
msgid "Beyond our :doc:`tutorials/index`, this guide has several other resources:"
msgstr ""

#: ../source/index.rst:56
msgid "The :doc:`guides/index` section for walk throughs, such as :doc:`guides/installing-using-linux-tools` or :doc:`guides/packaging-binary-extensions`."
msgstr ""

#: ../source/index.rst:58
msgid "The :doc:`discussions/index` section for in-depth references on topics such as :doc:`discussions/deploying-python-applications` or :doc:`discussions/pip-vs-easy-install`."
msgstr ""

#: ../source/index.rst:60
msgid "The :doc:`specifications/index` section for packaging interoperability specifications."
msgstr ""

#: ../source/index.rst:62
msgid "Additionally, there is a list of :doc:`other projects <key_projects>` maintained by members of the Python Packaging Authority."
msgstr ""

#: ../source/key_projects.rst:6
msgid "Project Summaries"
msgstr ""

#: ../source/key_projects.rst:8
msgid "Summaries and links for the most relevant projects in the space of Python installation and packaging."
msgstr ""

#: ../source/key_projects.rst:14
msgid "PyPA Projects"
msgstr ""

#: ../source/key_projects.rst:19
msgid "bandersnatch"
msgstr ""

#: ../source/key_projects.rst:21
msgid "`Issues <https://github.com/pypa/bandersnatch/issues>`__ | `GitHub <https://github.com/pypa/bandersnatch>`__ | `PyPI <https://pypi.org/project/bandersnatch>`__"
msgstr ""

#: ../source/key_projects.rst:25
msgid "``bandersnatch`` is a PyPI mirroring client designed to efficiently create a complete mirror of the contents of PyPI. Organizations thus save bandwidth and latency on package downloads (especially in the context of automated tests) and to prevent heavily loading PyPI's Content Delivery Network (CDN)."
msgstr ""

#: ../source/key_projects.rst:35
msgid "build"
msgstr ""

#: ../source/key_projects.rst:37
msgid "`Docs <https://pypa-build.readthedocs.io/>`__ | `Issues <https://github.com/pypa/build/issues>`__ | `GitHub <https://github.com/pypa/build>`__ | `PyPI <https://pypi.org/project/build>`__"
msgstr ""

#: ../source/key_projects.rst:42
msgid "``build`` is a :pep:`517` compatible Python package builder. It provides a CLI to build packages, as well as a Python API."
msgstr ""

#: ../source/key_projects.rst:49
msgid "cibuildwheel"
msgstr ""

#: ../source/key_projects.rst:51
msgid "`Docs <https://cibuildwheel.readthedocs.io/>`__ | `Issues <https://github.com/pypa/cibuildwheel/issues>`__ | `GitHub <https://github.com/pypa/cibuildwheel>`__ | `PyPI <https://pypi.org/project/cibuildwheel>`__ | `Discussions <https://github.com/pypa/cibuildwheel/discussions>`__ | `Discord #cibuildwheel <https://discord.com/invite/pypa>`__"
msgstr ""

#: ../source/key_projects.rst:58
msgid "``cibuildwheel`` is a Python package that builds :term:`wheels <Wheel>` for all common platforms and Python versions on most CI systems. Also see :ref:`multibuild`."
msgstr ""

#: ../source/key_projects.rst:64
msgid "distlib"
msgstr ""

#: ../source/key_projects.rst:66
msgid "`Docs <http://pythonhosted.org/distlib/>`__ | `Issues <https://bitbucket.org/pypa/distlib/issues?status=new&status=open>`__ | `Bitbucket <https://bitbucket.org/pypa/distlib>`__ | `PyPI <https://pypi.org/project/distlib>`__"
msgstr ""

#: ../source/key_projects.rst:71
msgid "``distlib`` is a library which implements low-level functions that relate to packaging and distribution of Python software.  ``distlib`` implements several relevant PEPs (Python Enhancement Proposal standards) and is useful for developers of third-party packaging tools to make and upload binary and source :term:`distributions <Distribution Package>`, achieve interoperability, resolve dependencies, manage package resources, and do other similar functions."
msgstr ""

#: ../source/key_projects.rst:80
msgid "Unlike the stricter :ref:`packaging` project (below), which specifically implements modern Python packaging interoperability standards, ``distlib`` also attempts to provide reasonable fallback behaviours when asked to handle legacy packages and metadata that predate the modern interoperability standards and fall into the subset of packages that are incompatible with those standards."
msgstr ""

#: ../source/key_projects.rst:90
msgid "packaging"
msgstr ""

#: ../source/key_projects.rst:92
msgid "`Docs <https://packaging.pypa.io>`__ | `Issues <https://github.com/pypa/packaging/issues>`__ | `GitHub <https://github.com/pypa/packaging>`__ | `PyPI <https://pypi.org/project/packaging>`__"
msgstr ""

#: ../source/key_projects.rst:97
msgid "Core utilities for Python packaging used by :ref:`pip` and :ref:`setuptools`."
msgstr ""

#: ../source/key_projects.rst:99
msgid "The core utilities in the packaging library handle version handling, specifiers, markers, requirements, tags, and similar attributes and tasks for Python packages. Most Python users rely on this library without needing to explicitly call it; developers of the other Python packaging, distribution, and installation tools listed here often use its functionality to parse, discover, and otherwise handle dependency attributes."
msgstr ""

#: ../source/key_projects.rst:107
msgid "This project specifically focuses on implementing the modern Python packaging interoperability standards defined at :ref:`packaging-specifications`, and will report errors for sufficiently old legacy packages that are incompatible with those standards. In contrast, the :ref:`distlib` project is a more permissive library that attempts to provide a plausible reading of ambiguous metadata in cases where :ref:`packaging` will instead report on error."
msgstr ""

#: ../source/key_projects.rst:119
#: ../source/specifications/platform-compatibility-tags.rst:85
msgid "pip"
msgstr ""

#: ../source/key_projects.rst:121
msgid "`Docs <https://pip.pypa.io/en/stable/>`__ | `Issues <https://github.com/pypa/pip/issues>`__ | `GitHub <https://github.com/pypa/pip>`__ | `PyPI <https://pypi.org/project/pip/>`__"
msgstr ""

#: ../source/key_projects.rst:126
msgid "The most popular tool for installing Python packages, and the one included with modern versions of Python."
msgstr ""

#: ../source/key_projects.rst:129
msgid "It provides the essential core features for finding, downloading, and installing packages from PyPI and other Python package indexes, and can be incorporated into a wide range of development workflows via its command-line interface (CLI)."
msgstr ""

#: ../source/key_projects.rst:137
msgid "Pipenv"
msgstr ""

#: ../source/key_projects.rst:139
msgid "`Docs <https://pipenv.pypa.io/>`__ | `Source <https://github.com/pypa/pipenv>`__ | `Issues <https://github.com/pypa/pipenv/issues>`__ | `PyPI <https://pypi.org/project/pipenv>`__"
msgstr ""

#: ../source/key_projects.rst:144
msgid "Pipenv is a project that aims to bring the best of all packaging worlds to the Python world. It harnesses :ref:`Pipfile`, :ref:`pip`, and :ref:`virtualenv` into one single toolchain. It features very pretty terminal colors."
msgstr ""

#: ../source/key_projects.rst:148
msgid "Pipenv aims to help users manage environments, dependencies, and imported packages on the command line. It also works well on Windows (which other tools often underserve), makes and checkes file hashes, to ensure compliance with hash-locked dependency specifiers, and eases uninstallation of packages and dependencies. It is used by Python users and system administrators, but has been less maintained since late 2018."
msgstr ""

#: ../source/key_projects.rst:159
msgid "Pipfile"
msgstr ""

#: ../source/key_projects.rst:161
msgid "`Source <https://github.com/pypa/pipfile>`__"
msgstr ""

#: ../source/key_projects.rst:163
msgid ":file:`Pipfile` and its sister :file:`Pipfile.lock` are a higher-level application-centric alternative to :ref:`pip`'s lower-level :file:`requirements.txt` file."
msgstr ""

#: ../source/key_projects.rst:170
msgid "pipx"
msgstr ""

#: ../source/key_projects.rst:172
msgid "`Docs <https://pypa.github.io/pipx/>`__ | `GitHub <https://github.com/pypa/pipx>`__ | `PyPI <https://pypi.org/project/pipx/>`__"
msgstr ""

#: ../source/key_projects.rst:176
msgid "pipx is a tool to install and run Python command-line applications without causing dependency conflicts with other packages installed on the system."
msgstr ""

#: ../source/key_projects.rst:183
msgid "`Docs <https://packaging.python.org/en/latest/>`__ | `Issues <https://github.com/pypa/python-packaging-user-guide/issues>`__ | `GitHub <https://github.com/pypa/python-packaging-user-guide>`__"
msgstr ""

#: ../source/key_projects.rst:187
msgid "This guide!"
msgstr ""

#: ../source/key_projects.rst:192
msgid "readme_renderer"
msgstr ""

#: ../source/key_projects.rst:194
msgid "`GitHub and docs <https://github.com/pypa/readme_renderer/>`__ | `PyPI <https://pypi.org/project/readme_renderer/>`__"
msgstr ""

#: ../source/key_projects.rst:197
msgid "``readme_renderer`` is a library that package developers use to render their user documentation (README) files into HTML from markup languages such as Markdown or reStructuredText. Developers call it on its own or via :ref:`twine`, as part of their release management process, to check that their package descriptions will properly display on PyPI."
msgstr ""

#: ../source/key_projects.rst:208
msgid "setuptools"
msgstr ""

#: ../source/key_projects.rst:210
msgid "`Docs <https://setuptools.readthedocs.io/en/latest/>`__ | `Issues <https://github.com/pypa/setuptools/issues>`__ | `GitHub <https://github.com/pypa/setuptools>`__ | `PyPI <https://pypi.org/project/setuptools>`__"
msgstr ""

#: ../source/key_projects.rst:215
msgid "setuptools (which includes ``easy_install``) is a collection of enhancements to the Python distutils that allow you to more easily build and distribute Python :term:`distributions <Distribution Package>`, especially ones that have dependencies on other packages."
msgstr ""

#: ../source/key_projects.rst:220
msgid "`distribute`_ was a fork of setuptools that was merged back into setuptools (in v0.7), thereby making setuptools the primary choice for Python packaging."
msgstr ""

#: ../source/key_projects.rst:227
msgid "trove-classifiers"
msgstr ""

#: ../source/key_projects.rst:229
msgid "`Issues <https://github.com/pypa/trove-classifiers/issues>`__ | `GitHub <https://github.com/pypa/trove-classifiers>`__ | `PyPI <https://pypi.org/project/trove-classifiers/>`__"
msgstr ""

#: ../source/key_projects.rst:233
msgid "trove-classifiers is the canonical source for `classifiers on PyPI <https://pypi.org/classifiers/>`_, which project maintainers use to `systematically describe their projects <https://packaging.python.org/specifications/core-metadata/#classifier-multiple-use>`_ so that users can better find projects that match their needs on the PyPI."
msgstr ""

#: ../source/key_projects.rst:239
msgid "The trove-classifiers package contains a list of valid classifiers and deprecated classifiers (which are paired with the classifiers that replace them).  Use this package to validate classifiers used in packages intended for uploading to PyPI. As this list of classifiers is published as code, you can install and import it, giving you a more convenient workflow compared to referring to the `list published on PyPI <https://pypi.org/classifiers/>`_. The `issue tracker <https://github.com/pypa/trove-classifiers/issues>`_ for the project hosts discussions on proposed classifiers and requests for new classifiers."
msgstr ""

#: ../source/key_projects.rst:253
msgid "twine"
msgstr ""

#: ../source/key_projects.rst:255
msgid "`Docs <https://twine.readthedocs.io/en/latest/>`__ | `Issues <https://github.com/pypa/twine/issues>`__ | `GitHub <https://github.com/pypa/twine>`__ | `PyPI <https://pypi.org/project/twine>`__"
msgstr ""

#: ../source/key_projects.rst:260
msgid "Twine is the primary tool developers use to upload packages to the Python Package Index or other Python package indexes. It is a command-line program that passes program files and metadata to a web API. Developers use it because it's the official PyPI upload tool, it's fast and secure, it's maintained, and it reliably works."
msgstr ""

#: ../source/key_projects.rst:270
#: ../source/overview.rst:415
msgid "virtualenv"
msgstr ""

#: ../source/key_projects.rst:272
msgid "`Docs <https://virtualenv.pypa.io/en/stable/>`__ | `Issues <https://github.com/pypa/virtualenv/issues>`__ | `GitHub <https://github.com/pypa/virtualenv>`__ | `PyPI <https://pypi.org/project/virtualenv/>`__"
msgstr ""

#: ../source/key_projects.rst:277
msgid "virtualenv is a tool which uses the command-line path environment variable to create isolated Python :term:`Virtual Environments <Virtual Environment>`, much as :ref:`venv` does. virtualenv provides additional functionality, compared to :ref:`venv`, by supporting Python 2.7 and by providing convenient features for configuring, maintaining, duplicating, and troubleshooting the virtual environments. For more information, see the section on :ref:`Creating and using Virtual Environments`."
msgstr ""

#: ../source/key_projects.rst:290
msgid "Warehouse"
msgstr ""

#: ../source/key_projects.rst:292
msgid "`Docs <https://warehouse.pypa.io/>`__ | `Issues <https://github.com/pypa/warehouse/issues>`__ | `GitHub <https://github.com/pypa/warehouse>`__"
msgstr ""

#: ../source/key_projects.rst:296
msgid "The current codebase powering the :term:`Python Package Index (PyPI)`. It is hosted at `pypi.org <https://pypi.org/>`_. The default source for :ref:`pip` downloads."
msgstr ""

#: ../source/key_projects.rst:304
msgid "wheel"
msgstr ""

#: ../source/key_projects.rst:306
msgid "`Docs <https://wheel.readthedocs.io/en/latest/>`__ | `Issues <https://github.com/pypa/wheel/issues>`__ | `GitHub <https://github.com/pypa/wheel>`__ | `PyPI <https://pypi.org/project/wheel>`__"
msgstr ""

#: ../source/key_projects.rst:311
msgid "Primarily, the wheel project offers the ``bdist_wheel`` :ref:`setuptools` extension for creating :term:`wheel distributions <Wheel>`.  Additionally, it offers its own command line utility for creating and installing wheels."
msgstr ""

#: ../source/key_projects.rst:315
msgid "See also `auditwheel <https://github.com/pypa/auditwheel>`__, a tool that package developers use to check and fix Python packages they are making in the binary wheel format. It provides functionality to discover dependencies, check metadata for compliance, and repair the wheel and metadata to properly link and include external shared libraries in a package."
msgstr ""

#: ../source/key_projects.rst:324
msgid "Non-PyPA Projects"
msgstr ""

#: ../source/key_projects.rst:329
msgid "bento"
msgstr ""

#: ../source/key_projects.rst:331
msgid "`Docs <http://cournape.github.io/Bento/>`__ | `Issues <https://github.com/cournape/Bento/issues>`__ | `GitHub <https://github.com/cournape/Bento>`__ | `PyPI <https://pypi.org/project/bento>`__"
msgstr ""

#: ../source/key_projects.rst:336
msgid "Bento is a packaging tool solution for Python software, targeted as an alternative to :ref:`distutils`, :ref:`setuptools`, etc....  Bento's philosophy is reproducibility, extensibility and simplicity (in that order)."
msgstr ""

#: ../source/key_projects.rst:344
msgid "buildout"
msgstr ""

#: ../source/key_projects.rst:346
msgid "`Docs <http://www.buildout.org/en/latest/>`__ | `Issues <https://bugs.launchpad.net/zc.buildout>`__ | `PyPI <https://pypi.org/project/zc.buildout>`__ | `GitHub <https://github.com/buildout/buildout/>`__"
msgstr ""

#: ../source/key_projects.rst:351
msgid "Buildout is a Python-based build system for creating, assembling and deploying applications from multiple parts, some of which may be non-Python-based.  It lets you create a buildout configuration and reproduce the same software later."
msgstr ""

#: ../source/key_projects.rst:358
msgid "conda"
msgstr ""

#: ../source/key_projects.rst:360
msgid "`Docs <http://conda.pydata.org/docs/>`__"
msgstr ""

#: ../source/key_projects.rst:362
msgid "conda is the package management tool for `Anaconda <https://docs.anaconda.com/anaconda/>`__ Python installations. Anaconda Python is a distribution from `Anaconda, Inc <https://www.anaconda.com/download>`__ specifically aimed at the scientific community, and in particular on Windows where the installation of binary extensions is often difficult."
msgstr ""

#: ../source/key_projects.rst:369
msgid "Conda is a completely separate tool from :ref:`pip`, virtualenv and wheel, but provides many of their combined features in terms of package management, virtual environment management and deployment of binary extensions."
msgstr ""

#: ../source/key_projects.rst:373
msgid "Conda does not install packages from PyPI and can install only from the official Anaconda repositories, or anaconda.org (a place for user-contributed *conda* packages), or a local (e.g. intranet) package server.  However, note that :ref:`pip` can be installed into, and work side-by-side with conda for managing :term:`distributions <Distribution Package>` from PyPI. Also, `conda skeleton <https://docs.conda.io/projects/conda-build/en/latest/user-guide/tutorials/build-pkgs-skeleton.html>`__ is a tool to make Python packages installable by conda by first fetching them from PyPI and modifying their metadata."
msgstr ""

#: ../source/key_projects.rst:386
msgid "devpi"
msgstr ""

#: ../source/key_projects.rst:388
msgid "`Docs <http://doc.devpi.net/latest/>`__ | `Issues <https://bitbucket.org/hpk42/devpi/issues>`__ | `PyPI <https://pypi.org/project/devpi>`__"
msgstr ""

#: ../source/key_projects.rst:392
msgid "devpi features a powerful PyPI-compatible server and PyPI proxy cache with a complementary command line tool to drive packaging, testing and release activities with Python. devpi also provides a browsable and searchable web interface."
msgstr ""

#: ../source/key_projects.rst:401
msgid "flit"
msgstr ""

#: ../source/key_projects.rst:403
msgid "`Docs <https://flit.readthedocs.io/en/latest/>`__ | `Issues <https://github.com/takluyver/flit/issues>`__ | `PyPI <https://pypi.org/project/flit>`__"
msgstr ""

#: ../source/key_projects.rst:407
msgid "Flit provides a simple way to upload pure Python packages and modules to PyPI. It focuses on `making the easy things easy <flit-rationale_>`_ for packaging. Flit can generate a configuration file to quickly set up a simple project, build source distributions and wheels, and upload them to PyPI."
msgstr ""

#: ../source/key_projects.rst:412
msgid "Flit uses ``pyproject.toml`` to configure a project. Flit does not rely on tools such as :ref:`setuptools` to build distributions, or :ref:`twine` to upload them to PyPI. Flit requires Python 3, but you can use it to distribute modules for Python 2, so long as they can be imported on Python 3."
msgstr ""

#: ../source/key_projects.rst:422
msgid "enscons"
msgstr ""

#: ../source/key_projects.rst:424
msgid "`Source <https://bitbucket.org/dholth/enscons/src>`__ | `Issues <https://bitbucket.org/dholth/enscons/issues>`__ | `PyPI <https://pypi.org/project/enscons>`__"
msgstr ""

#: ../source/key_projects.rst:428
msgid "Enscons is a Python packaging tool based on `SCons`_. It builds :ref:`pip`-compatible source distributions and wheels without using distutils or setuptools, including distributions with C extensions. Enscons has a different architecture and philosophy than :ref:`distutils`. Rather than adding build features to a Python packaging system, enscons adds Python packaging to a general purpose build system. Enscons helps you to build sdists that can be automatically built by :ref:`pip`, and wheels that are independent of enscons."
msgstr ""

#: ../source/key_projects.rst:443
msgid "Hashdist"
msgstr ""

#: ../source/key_projects.rst:445
msgid "`Docs <https://hashdist.readthedocs.io/en/latest/>`__ | `GitHub <https://github.com/hashdist/hashdist/>`__"
msgstr ""

#: ../source/key_projects.rst:448
msgid "Hashdist is a library for building non-root software distributions. Hashdist is trying to be “the Debian of choice for cases where Debian technology doesn’t work”. The best way for Pythonistas to think about Hashdist may be a more powerful hybrid of :ref:`virtualenv` and :ref:`buildout`. It is aimed at solving the problem of installing scientific software, and making package distribution stateless, cached, and branchable. It is used by some researchers but has been lacking in maintenance since 2016."
msgstr ""

#: ../source/key_projects.rst:460
msgid "hatch"
msgstr ""

#: ../source/key_projects.rst:462
msgid "`GitHub and Docs <https://github.com/ofek/hatch>`__ | `PyPI <https://pypi.org/project/hatch>`__"
msgstr ""

#: ../source/key_projects.rst:465
msgid "Hatch is a unified command-line tool meant to conveniently manage dependencies and environment isolation for Python developers. Python package developers use Hatch to configure, version, specify dependencies for, and publish packages to PyPI. Under the hood, it uses :ref:`twine` to upload packages to PyPI, and :ref:`pip` to download and install packages."
msgstr ""

#: ../source/key_projects.rst:475
msgid "multibuild"
msgstr ""

#: ../source/key_projects.rst:477
msgid "`GitHub <https://github.com/matthew-brett/multibuild>`__"
msgstr ""

#: ../source/key_projects.rst:479
msgid "Multibuild is a set of CI scripts for building and testing Python :term:`wheels <Wheel>` for Linux, macOS, and (less flexibly) Windows. Also see :ref:`cibuildwheel`."
msgstr ""

#: ../source/key_projects.rst:485
msgid "pex"
msgstr ""

#: ../source/key_projects.rst:487
msgid "`Docs <https://pex.readthedocs.io/en/latest/>`__ | `GitHub <https://github.com/pantsbuild/pex/>`__ | `PyPI <https://pypi.org/project/pex>`__"
msgstr ""

#: ../source/key_projects.rst:491
msgid "pex is both a library and tool for generating :file:`.pex` (Python EXecutable) files, standalone Python environments in the spirit of :ref:`virtualenv`. :file:`.pex` files are just carefully constructed zip files with a ``#!/usr/bin/env python`` and special :file:`__main__.py`, and are designed to make deployment of Python applications as simple as ``cp``."
msgstr ""

#: ../source/key_projects.rst:500
msgid "pip-tools"
msgstr ""

#: ../source/key_projects.rst:502
msgid "`GitHub and Docs <https://github.com/jazzband/pip-tools/>`__ | `PyPI <https://pypi.org/project/pip-tools/>`__"
msgstr ""

#: ../source/key_projects.rst:505
msgid "pip-tools is a suite of tools meant for Python system administrators and release managers who particularly want to keep their builds deterministic yet stay up to date with new versions of their dependencies. Users can specify particular release of their dependencies via hash, conveniently make a properly formatted list of requirements from information in other parts of their program, update all dependencies (a feature :ref:`pip` currently does not provide), and create layers of constraints for the program to obey."
msgstr ""

#: ../source/key_projects.rst:517
msgid "piwheels"
msgstr ""

#: ../source/key_projects.rst:519
msgid "`Website <https://www.piwheels.org/>`__ | `Docs <https://piwheels.readthedocs.io/>`__ | `GitHub <https://github.com/piwheels/piwheels/>`__"
msgstr ""

#: ../source/key_projects.rst:523
msgid "piwheels is a website, and software underpinning it, that fetches source code distribution packages from PyPI and compiles them into binary wheels that are optimized for installation onto Raspberry Pi computers. Raspberry Pi OS pre-configures pip to use piwheels.org as an additional index to PyPI."
msgstr ""

#: ../source/key_projects.rst:532
msgid "poetry"
msgstr ""

#: ../source/key_projects.rst:534
msgid "`Docs <https://python-poetry.org/>`__ | `GitHub <https://github.com/python-poetry/poetry>`__ | `PyPI <https://pypi.org/project/poetry/>`__"
msgstr ""

#: ../source/key_projects.rst:538
msgid "poetry is a command-line tool to handle dependency installation and isolation as well as building and packaging of Python packages. It uses ``pyproject.toml`` and, instead of depending on the resolver functionality within :ref:`pip`, provides its own dependency resolver. It attempts to speed users' experience of installation and dependency resolution by locally caching metadata about dependencies."
msgstr ""

#: ../source/key_projects.rst:548
msgid "pypiserver"
msgstr ""

#: ../source/key_projects.rst:550
msgid "`Docs <https://github.com/pypiserver/pypiserver/blob/master/README.rst>`__ | `GitHub <https://github.com/pypiserver/pypiserver>`__ | `PyPI <https://pypi.org/project/pypiserver/>`__"
msgstr ""

#: ../source/key_projects.rst:554
msgid "pypiserver is a minimalist application that serves as a private Python package index within organizations, implementing a simple API and browser interface. You can upload private packages using standard upload tools, and users can download and install them with :ref:`pip`, without publishing them publicly. Organizations who use pypiserver usually download packages both from pypiserver and from PyPI."
msgstr ""

#: ../source/key_projects.rst:564
msgid "scikit-build"
msgstr ""

#: ../source/key_projects.rst:566
msgid "`Docs <https://scikit-build.readthedocs.io/en/latest/>`__ | `GitHub <https://github.com/scikit-build/scikit-build/>`__ | `PyPI <https://pypi.org/project/scikit-build>`__"
msgstr ""

#: ../source/key_projects.rst:570
msgid "Scikit-build is an improved build system generator for CPython C/C++/Fortran/Cython extensions that integrates with :ref:`setuptools`, :ref:`wheel` and :ref:`pip`. It internally uses `cmake <https://pypi.org/project/cmake>`__ (available on PyPI) to provide better support for additional compilers, build systems, cross compilation, and locating dependencies and their associated build requirements. To speed up and parallelize the build of large projects, the user can install `ninja <https://pypi.org/project/ninja>`__ (also available on PyPI)."
msgstr ""

#: ../source/key_projects.rst:582
msgid "shiv"
msgstr ""

#: ../source/key_projects.rst:584
msgid "`Docs <https://shiv.readthedocs.io/en/latest/>`__ | `GitHub <https://github.com/linkedin/shiv>`__ | `PyPI <https://pypi.org/project/shiv/>`__"
msgstr ""

#: ../source/key_projects.rst:588
msgid "shiv is a command line utility for building fully self contained Python zipapps as outlined in :pep:`441`, but with all their dependencies included. Its primary goal is making distributing Python applications and command line tools fast & easy."
msgstr ""

#: ../source/key_projects.rst:598
msgid "`Docs <https://spack.readthedocs.io/>`__ | `GitHub <https://github.com/llnl/spack/>`__ | `Paper <http://www.computer.org/csdl/proceedings/sc/2015/3723/00/2807623.pdf>`__ | `Slides <https://tgamblin.github.io/files/Gamblin-Spack-SC15-Talk.pdf>`__"
msgstr ""

#: ../source/key_projects.rst:603
msgid "A flexible package manager designed to support multiple versions, configurations, platforms, and compilers.  Spack is like Homebrew, but packages are written in Python and parameterized to allow easy swapping of compilers, library versions, build options, etc. Arbitrarily many versions of packages can coexist on the same system. Spack was designed for rapidly building high performance scientific applications on clusters and supercomputers."
msgstr ""

#: ../source/key_projects.rst:611
msgid "Spack is not in PyPI (yet), but it requires no installation and can be used immediately after cloning from GitHub."
msgstr ""

#: ../source/key_projects.rst:617
msgid "zest.releaser"
msgstr ""

#: ../source/key_projects.rst:619
msgid "`Docs <https://zestreleaser.readthedocs.io/en/latest/>`__ | `GitHub <https://github.com/zestsoftware/zest.releaser/>`__ | `PyPI <https://pypi.org/project/zest.releaser/>`__"
msgstr ""

#: ../source/key_projects.rst:623
msgid "``zest.releaser`` is a Python package release tool providing an abstraction layer on top of :ref:`twine`. Python developers use ``zest.releaser`` to automate incrementing package version numbers, updating changelogs, tagging releases in source control, and uploading new packages to PyPI."
msgstr ""

#: ../source/key_projects.rst:630
msgid "Standard Library Projects"
msgstr ""

#: ../source/key_projects.rst:635
msgid "ensurepip"
msgstr ""

#: ../source/key_projects.rst:637
msgid "`Docs <https://docs.python.org/3/library/ensurepip.html>`__ | `Issues <http://bugs.python.org>`__"
msgstr ""

#: ../source/key_projects.rst:640
msgid "A package in the Python Standard Library that provides support for bootstrapping :ref:`pip` into an existing Python installation or virtual environment.  In most cases, end users won't use this module, but rather it will be used during the build of the Python distribution."
msgstr ""

#: ../source/key_projects.rst:649
msgid "distutils"
msgstr ""

#: ../source/key_projects.rst:651
msgid "`Docs <https://docs.python.org/3/library/distutils.html>`__ | `Issues <http://bugs.python.org>`__"
msgstr ""

#: ../source/key_projects.rst:654
msgid "The original Python packaging system, added to the standard library in Python 2.0."
msgstr ""

#: ../source/key_projects.rst:657
msgid "Due to the challenges of maintaining a packaging system where feature updates are tightly coupled to language runtime updates, direct usage of :ref:`distutils` is now actively discouraged, with :ref:`Setuptools` being the preferred replacement. :ref:`Setuptools` not only provides features that plain :ref:`distutils` doesn't offer (such as dependency declarations and entry point declarations), it also provides a consistent build interface and feature set across all supported Python versions."
msgstr ""

#: ../source/key_projects.rst:670
msgid "venv"
msgstr ""

#: ../source/key_projects.rst:672
msgid "`Docs <https://docs.python.org/3/library/venv.html>`__ | `Issues <http://bugs.python.org>`__"
msgstr ""

#: ../source/key_projects.rst:675
msgid "A package in the Python Standard Library (starting with Python 3.3) for creating :term:`Virtual Environments <Virtual Environment>`.  For more information, see the section on :ref:`Creating and using Virtual Environments`."
msgstr ""

#: ../source/news.rst:2
msgid "News"
msgstr ""

#: ../source/news.rst:5
msgid "September 2019"
msgstr ""

#: ../source/news.rst:6
msgid "Added a guide about publishing dists via GitHub Actions. (:pr:`647`)"
msgstr ""

#: ../source/news.rst:9
msgid "August 2019"
msgstr ""

#: ../source/news.rst:10
msgid "Updated to use :file:`python3 -m` when installing pipx. (:pr:`631`)"
msgstr ""

#: ../source/news.rst:13
msgid "July 2019"
msgstr ""

#: ../source/news.rst:14
msgid "Marked all PEP numbers with the :pep: role. (:pr:`629`)"
msgstr ""

#: ../source/news.rst:15
msgid "Upgraded Sphinx version and removed pypa.io intersphinx. (:pr:`625`)"
msgstr ""

#: ../source/news.rst:16
msgid "Mentioned :file:`find_namespace_packages`. (:pr:`622`)"
msgstr ""

#: ../source/news.rst:17
msgid "Updated directory layout examples for consistency. (:pr:`611`)"
msgstr ""

#: ../source/news.rst:18
msgid "Updated Bandersnatch link to GitHub. (:pr:`623`)"
msgstr ""

#: ../source/news.rst:21
msgid "June 2019"
msgstr ""

#: ../source/news.rst:22
msgid "Fixed some typos. (:pr:`620`)"
msgstr ""

#: ../source/news.rst:25
msgid "May 2019"
msgstr ""

#: ../source/news.rst:26
msgid "Added :file:`python_requires` usage to packaging tutorial. (:pr:`613`)"
msgstr ""

#: ../source/news.rst:27
msgid "Added a MANIFEST.in guide page. (:pr:`609`)"
msgstr ""

#: ../source/news.rst:30
msgid "April 2019"
msgstr ""

#: ../source/news.rst:31
msgid "Added a mention for :file:`shiv` in the key projects section. (:pr:`608`)"
msgstr ""

#: ../source/news.rst:32
msgid "Reduced emphasis on virtualenv. (:pr:`606`)"
msgstr ""

#: ../source/news.rst:35
msgid "March 2019"
msgstr ""

#: ../source/news.rst:36
msgid "Moved single-sourcing guide version option to Python 3. (:pr:`605`)"
msgstr ""

#: ../source/news.rst:37
msgid "Covered RTD details for contributing. (:pr:`600`)"
msgstr ""

#: ../source/news.rst:40
msgid "February 2019"
msgstr ""

#: ../source/news.rst:41
msgid "Elaborate upon the differences between the tutorial and the real packaging process. (:pr:`602`)"
msgstr ""

#: ../source/news.rst:42
msgid "Added instructions to install Python CLI applications. (:pr:`594`)"
msgstr ""

#: ../source/news.rst:45
msgid "January 2019"
msgstr ""

#: ../source/news.rst:46
msgid "Added :file:`--no-deps` to the packaging tutorial. (:pr:`593`)"
msgstr ""

#: ../source/news.rst:47
msgid "Updated Sphinx and Nox. (:pr:`591`)"
msgstr ""

#: ../source/news.rst:48
msgid "Referenced Twine from Python3. (:pr:`581`)"
msgstr ""

#: ../source/news.rst:51
msgid "December 2018"
msgstr ""

#: ../source/news.rst:52
msgid "No programmers in the office!"
msgstr ""

#: ../source/news.rst:55
msgid "November 2018"
msgstr ""

#: ../source/news.rst:56
msgid "Removed landing page link to PyPI migration guide. (:pr:`575`)"
msgstr ""

#: ../source/news.rst:57
msgid "Changed bumpversion to bump2version. (:pr:`572`)"
msgstr ""

#: ../source/news.rst:58
msgid "Added single-sourcing package version example. (:pr:`573`)"
msgstr ""

#: ../source/news.rst:59
msgid "Added a guide for creating documentation. (:pr:`568`)"
msgstr ""

#: ../source/news.rst:62
msgid "October 2018"
msgstr ""

#: ../source/news.rst:63
msgid "Updated Nox package name. (:pr:`566`)"
msgstr ""

#: ../source/news.rst:64
msgid "Mentioned Sphinx extensions in guides. (:pr:`562`)"
msgstr ""

#: ../source/news.rst:67
msgid "September 2018"
msgstr ""

#: ../source/news.rst:68
msgid "Added a section on checking RST markup. (:pr:`554`)"
msgstr ""

#: ../source/news.rst:69
msgid "Updated user installs page. (:pr:`558`)"
msgstr ""

#: ../source/news.rst:70
msgid "Updated Google BigQuery urls. (:pr:`556`)"
msgstr ""

#: ../source/news.rst:71
msgid "Replaced tar command with working command. (:pr:`552`)"
msgstr ""

#: ../source/news.rst:72
msgid "Changed to double quotes in the pip install SomeProject==1.4. (:pr:`550`)"
msgstr ""

#: ../source/news.rst:75
msgid "August 2018"
msgstr ""

#: ../source/news.rst:76
msgid "Removed the recommendation to store passwords in cleartext. (:pr:`546`)"
msgstr ""

#: ../source/news.rst:77
msgid "Moved the Overview to a task based lead in along with the others. (:pr:`540`)"
msgstr ""

#: ../source/news.rst:78
msgid "Updated Python version supported by virtualenv. (:pr:`538`)"
msgstr ""

#: ../source/news.rst:79
msgid "Added outline/rough draft of new Overview page. (:pr:`519`)"
msgstr ""

#: ../source/news.rst:82
msgid "July 2018"
msgstr ""

#: ../source/news.rst:84
msgid "Improved binary extension docs. (:pr:`531`)"
msgstr ""

#: ../source/news.rst:85
msgid "Added scikit-build to key projects. (:pr:`530`)"
msgstr ""

#: ../source/news.rst:88
msgid "June 2018"
msgstr ""

#: ../source/news.rst:90
msgid "Fixed categories of interop PEP for pypa.io. (:pr:`527`)"
msgstr ""

#: ../source/news.rst:91
msgid "Updated Markdown descriptions explanation. (:pr:`522`)"
msgstr ""

#: ../source/news.rst:94
msgid "May 2018"
msgstr ""

#: ../source/news.rst:96
msgid "Noted issues with Provides-Dist and Obsoletes-Dist. (:pr:`513`)"
msgstr ""

#: ../source/news.rst:97
msgid "Removed outdated warning about Python version mixing with Pipenv. (:pr:`501`)"
msgstr ""

#: ../source/news.rst:98
msgid "Simplified packaging tutorial. (:pr:`498`)"
msgstr ""

#: ../source/news.rst:99
msgid "Updated Windows users instructions for clarity. (:pr:`493`)"
msgstr ""

#: ../source/news.rst:100
msgid "Updated the license section description for completeness. (:pr:`492`)"
msgstr ""

#: ../source/news.rst:101
msgid "Added specification-style document to contributing section. (:pr:`489`)"
msgstr ""

#: ../source/news.rst:102
msgid "Added documentation types to contributing guide. (:pr:`485`)"
msgstr ""

#: ../source/news.rst:105
msgid "April 2018"
msgstr ""

#: ../source/news.rst:107
msgid "Added README guide. (:pr:`461`)"
msgstr ""

#: ../source/news.rst:108
msgid "Updated instructions and status for PyPI launch. (:pr:`475`)"
msgstr ""

#: ../source/news.rst:109
msgid "Added instructions for Warehouse. (:pr:`471`)"
msgstr ""

#: ../source/news.rst:110
msgid "Removed GPG references from publishing tutorial. (:pr:`466`)"
msgstr ""

#: ../source/news.rst:111
msgid "Added 'What’s in which Python 3.4–3.6?'. (:pr:`468`)"
msgstr ""

#: ../source/news.rst:112
msgid "Added a guide for phasing out Python versions. (:pr:`459`)"
msgstr ""

#: ../source/news.rst:113
msgid "Made default Description-Content-Type variant GFM. (:pr:`462`)"
msgstr ""

#: ../source/news.rst:116
msgid "March 2018"
msgstr ""

#: ../source/news.rst:118
msgid "Updated \"installing scientific packages\". (:pr:`455`)"
msgstr ""

#: ../source/news.rst:119
msgid "Added :file:`long_description_content_type` to follow PEP 556. (:pr:`457`)"
msgstr ""

#: ../source/news.rst:120
msgid "Clarified a long description classifier on pypi.org. (:pr:`456`)"
msgstr ""

#: ../source/news.rst:121
msgid "Updated Core Metadata spec to follw PEP 556. (:pr:`412`)"
msgstr ""

#: ../source/news.rst:124
msgid "February 2018"
msgstr ""

#: ../source/news.rst:126
msgid "Added python3-venv and python3-pip to Debian installation instructions. (:pr:`445`)"
msgstr ""

#: ../source/news.rst:127
msgid "Updated PyPI migration info. (:pr:`439`)"
msgstr ""

#: ../source/news.rst:128
msgid "Added a warning about managing multiple versions with pipenv. (:pr:`430`)"
msgstr ""

#: ../source/news.rst:129
msgid "Added example of multiple emails to Core Metadata. (:pr:`429`)"
msgstr ""

#: ../source/news.rst:130
msgid "Added explanation of \"legacy\" in test.pypi.org/legacy. (:pr:`426`)"
msgstr ""

#: ../source/news.rst:133
msgid "January 2018"
msgstr ""

#: ../source/news.rst:135
msgid "Added a link to PyPI's list of classifiers. (:pr:`425`)"
msgstr ""

#: ../source/news.rst:136
msgid "Updated README.rst explanation. (:pr:`419`)"
msgstr ""

#: ../source/news.rst:139
msgid "December 2017"
msgstr ""

#: ../source/news.rst:141
msgid "Replaced :file:`~` with :file:`$HOME` in guides and tutorials.  (:pr:`418`)"
msgstr ""

#: ../source/news.rst:142
msgid "Noted which fields can be used with environment markers. (:pr:`416`)"
msgstr ""

#: ../source/news.rst:143
msgid "Updated Requires-Python section. (:pr:`414`)"
msgstr ""

#: ../source/news.rst:144
msgid "Added news page. (:pr:`404`)"
msgstr ""

#: ../source/news.rst:147
msgid "November 2017"
msgstr ""

#: ../source/news.rst:149
msgid "Introduced a new dependency management tutorial based on Pipenv. (:pr:`402`)"
msgstr ""

#: ../source/news.rst:150
msgid "Updated the *Single Sourcing Package Version* tutorial to reflect pip's current strategy. (:pr:`400`)"
msgstr ""

#: ../source/news.rst:152
msgid "Added documentation about the ``py_modules`` argument to ``setup``. (:pr:`398`)"
msgstr ""

#: ../source/news.rst:153
msgid "Simplified the wording for the :file:`manifest.in` section. (:pr:`395`)"
msgstr ""

#: ../source/news.rst:156
msgid "October 2017"
msgstr ""

#: ../source/news.rst:158
msgid "Added a specification for the :file:`entry_points.txt` file. (:pr:`398`)"
msgstr ""

#: ../source/news.rst:159
msgid "Created a new guide for managing packages using ``pip`` and ``virtualenv``. (:pr:`385`)"
msgstr ""

#: ../source/news.rst:160
msgid "Split the specifications page into multiple pages. (:pr:`386`)"
msgstr ""

#: ../source/news.rst:163
msgid "September 2017"
msgstr ""

#: ../source/news.rst:165
msgid "Encouraged using ``readme_renderer`` to validate :file:`README.rst`. (:pr:`379`)"
msgstr ""

#: ../source/news.rst:167
msgid "Recommended using the ``--user-base`` option. (:pr:`374`)"
msgstr ""

#: ../source/news.rst:170
msgid "August 2017"
msgstr ""

#: ../source/news.rst:172
msgid "Added a new, experimental tutorial on installing packages using ``Pipenv``. (:pr:`369`)"
msgstr ""

#: ../source/news.rst:173
msgid "Added a new guide on how to use ``TestPyPI``. (:pr:`366`)"
msgstr ""

#: ../source/news.rst:174
msgid "Added :file:`pypi.org` as a term. (:pr:`365`)"
msgstr ""

#: ../source/news.rst:177
msgid "July 2017"
msgstr ""

#: ../source/news.rst:179
msgid "Added ``flit`` to the key projects list. (:pr:`358`)"
msgstr ""

#: ../source/news.rst:180
msgid "Added ``enscons`` to the list of key projects. (:pr:`357`)"
msgstr ""

#: ../source/news.rst:181
msgid "Updated this guide's ``readme`` with instructions on how to build the guide locally. (:pr:`356`)"
msgstr ""

#: ../source/news.rst:182
msgid "Made the new ``TestPyPI`` URL more visible, adding note to homepage about pypi.org. (:pr:`354`)"
msgstr ""

#: ../source/news.rst:183
msgid "Added a note about the removal of the explicit registration API. (:pr:`347`)"
msgstr ""

#: ../source/news.rst:186
msgid "June 2017"
msgstr ""

#: ../source/news.rst:188
msgid "Added a document on migrating uploads to :file:`PyPI.org`. (:pr:`339`)"
msgstr ""

#: ../source/news.rst:189
msgid "Added documentation for ``python_requires``. (:pr:`338`)"
msgstr ""

#: ../source/news.rst:190
msgid "Added a note about PyPI migration in the *Tool Recommendations* tutorial. (:pr:`335`)"
msgstr ""

#: ../source/news.rst:191
msgid "Added a note that :file:`manifest.in` does not affect wheels. (:pr:`332`)"
msgstr ""

#: ../source/news.rst:192
msgid "Added a license section to the distributing guide. (:pr:`331`)"
msgstr ""

#: ../source/news.rst:193
msgid "Expanded the section on the ``name`` argument. (:pr:`329`)"
msgstr ""

#: ../source/news.rst:194
msgid "Adjusted the landing page. (:pr:`327`, :pr:`326`, :pr:`324`)"
msgstr ""

#: ../source/news.rst:195
msgid "Updated to Sphinx 1.6.2. (:pr:`323`)"
msgstr ""

#: ../source/news.rst:196
msgid "Switched to the PyPA theme. (:pr:`305`)"
msgstr ""

#: ../source/news.rst:197
msgid "Re-organized the documentation into the new structure. (:pr:`318`)"
msgstr ""

#: ../source/news.rst:200
msgid "May 2017"
msgstr ""

#: ../source/news.rst:202
msgid "Added documentation for the ``Description-Content-Type`` field. (:pr:`258`)"
msgstr ""

#: ../source/news.rst:203
msgid "Added contributor and style guide. (:pr:`307`)"
msgstr ""

#: ../source/news.rst:204
msgid "Documented ``pip`` and ``easy_install``'s differences for per-project indexes. (:pr:`233`)"
msgstr ""

#: ../source/news.rst:207
msgid "April 2017"
msgstr ""

#: ../source/news.rst:209
msgid "Added travis configuration for testing pull requests. (:pr:`300`)"
msgstr ""

#: ../source/news.rst:210
msgid "Mentioned the requirement of the ``wheel`` package for creating wheels (:pr:`299`)"
msgstr ""

#: ../source/news.rst:211
msgid "Removed the ``twine register`` reference in the *Distributing Packages* tutorial. (:pr:`271`)"
msgstr ""

#: ../source/news.rst:212
msgid "Added a topic on plugin discovery. (:pr:`294`, :pr:`296`)"
msgstr ""

#: ../source/news.rst:213
msgid "Added a topic on namespace packages. (:pr:`290`)"
msgstr ""

#: ../source/news.rst:214
msgid "Added documentation explaining prominently how to install ``pip`` in ``/usr/local``. (:pr:`230`)"
msgstr ""

#: ../source/news.rst:215
msgid "Updated development mode documentation to mention that order of local packages matters. (:pr:`208`)"
msgstr ""

#: ../source/news.rst:216
msgid "Convert readthedocs link for their ``.org`` -> ``.io`` migration for hosted projects (:pr:`239`)"
msgstr ""

#: ../source/news.rst:217
msgid "Swaped order of :file:`setup.py` arguments for the upload command, as order is significant. (:pr:`260`)"
msgstr ""

#: ../source/news.rst:219
msgid "Explained how to install from unsupported sources using a helper application. (:pr:`289`)"
msgstr ""

#: ../source/news.rst:223
msgid "March 2017"
msgstr ""

#: ../source/news.rst:225
msgid "Covered ``manylinux1`` in *Platform Wheels*. (:pr:`283`)"
msgstr ""

#: ../source/news.rst:228
msgid "February 2017"
msgstr ""

#: ../source/news.rst:230
msgid "Added :pep:`518`. (:pr:`281`)"
msgstr ""

#: ../source/overview.rst:3
msgid "An Overview of Packaging for Python"
msgstr ""

#: ../source/overview.rst:7
msgid "As a general-purpose programming language, Python is designed to be used in many ways. You can build web sites or industrial robots or a game for your friends to play, and much more, all using the same core technology."
msgstr ""

#: ../source/overview.rst:12
msgid "Python's flexibility is why the first step in every Python project must be to think about the project's audience and the corresponding environment where the project will run. It might seem strange to think about packaging before writing code, but this process does wonders for avoiding future headaches."
msgstr ""

#: ../source/overview.rst:18
msgid "This overview provides a general-purpose decision tree for reasoning about Python's plethora of packaging options. Read on to choose the best technology for your next project."
msgstr ""

#: ../source/overview.rst:26
msgid "Thinking about deployment"
msgstr ""

#: ../source/overview.rst:28
msgid "Packages exist to be installed (or *deployed*), so before you package anything, you'll want to have some answers to the deployment questions below:"
msgstr ""

#: ../source/overview.rst:32
msgid "Who are your software's users? Will your software be installed by other developers doing software development, operations people in a datacenter, or a less software-savvy group?"
msgstr ""

#: ../source/overview.rst:35
msgid "Is your software intended to run on servers, desktops, mobile clients (phones, tablets, etc.), or embedded in dedicated devices?"
msgstr ""

#: ../source/overview.rst:37
msgid "Is your software installed individually, or in large deployment batches?"
msgstr ""

#: ../source/overview.rst:39
msgid "Packaging is all about target environment and deployment experience. There are many answers to the questions above and each combination of circumstances has its own solutions. With this information, the following overview will guide you to the packaging technologies best suited to your project."
msgstr ""

#: ../source/overview.rst:46
msgid "Packaging Python libraries and tools"
msgstr ""

#: ../source/overview.rst:48
msgid "You may have heard about PyPI, ``setup.py``, and ``wheel`` files. These are just a few of the tools Python's ecosystem provides for distributing Python code to developers, which you can read about in :doc:`guides/distributing-packages-using-setuptools`."
msgstr ""

#: ../source/overview.rst:53
msgid "The following approaches to packaging are meant for libraries and tools used by technical audience in a development setting. If you're looking for ways to package Python for a non-technical audience and/or a production setting, skip ahead to :ref:`packaging-applications`."
msgstr ""

#: ../source/overview.rst:59
msgid "Python modules"
msgstr ""

#: ../source/overview.rst:61
msgid "A Python file, provided it only relies on the standard library, can be redistributed and reused. You will also need to ensure it's written for the right version of Python, and only relies on the standard library."
msgstr ""

#: ../source/overview.rst:66
msgid "This is great for sharing simple scripts and snippets between people who both have compatible Python versions (such as via email, StackOverflow, or GitHub gists). There are even some entire Python libraries that offer this as an option, such as `bottle.py <https://bottlepy.org/docs/dev/>`_ and `boltons <http://boltons.readthedocs.io/en/latest/architecture.html#architecture>`_."
msgstr ""

#: ../source/overview.rst:73
msgid "However, this pattern won't scale for projects that consist of multiple files, need additional libraries, or need a specific version of Python, hence the options below."
msgstr ""

#: ../source/overview.rst:78
msgid "Python source distributions"
msgstr ""

#: ../source/overview.rst:80
msgid "If your code consists of multiple Python files, it's usually organized into a directory structure. Any directory containing Python files can comprise an :term:`Import Package`."
msgstr ""

#: ../source/overview.rst:84
msgid "Because packages consist of multiple files, they are harder to distribute. Most protocols support transferring only one file at a time (when was the last time you clicked a link and it downloaded multiple files?). It's easier to get incomplete transfers, and harder to guarantee code integrity at the destination."
msgstr ""

#: ../source/overview.rst:90
msgid "So long as your code contains nothing but pure Python code, and you know your deployment environment supports your version of Python, then you can use Python's native packaging tools to create a *source* :term:`Distribution Package`, or *sdist* for short."
msgstr ""

#: ../source/overview.rst:95
msgid "Python's *sdists* are compressed archives (``.tar.gz`` files) containing one or more packages or modules. If your code is pure-Python, and you only depend on other Python packages, you can `go here to learn more <https://docs.python.org/3/distutils/sourcedist.html>`_."
msgstr ""

#: ../source/overview.rst:100
msgid "If you rely on any non-Python code, or non-Python packages (such as `libxml2 <https://en.wikipedia.org/wiki/Libxml2>`_ in the case of `lxml <https://pypi.org/project/lxml/>`_, or BLAS libraries in the case of `numpy <https://pypi.org/project/numpy>`_), you will need to use the format detailed in the next section, which also has many advantages for pure-Python libraries."
msgstr ""

#: ../source/overview.rst:107
msgid "Python and PyPI support multiple distributions providing different implementations of the same package. For instance the unmaintained-but-seminal `PIL distribution <https://pypi.org/project/PIL/>`_ provides the PIL package, and so does `Pillow <https://pypi.org/project/Pillow/>`_, an actively-maintained fork of PIL!"
msgstr ""

#: ../source/overview.rst:114
msgid "This Python packaging superpower makes it possible for Pillow to be a drop-in replacement for PIL, just by changing your project's ``install_requires`` or ``requirements.txt``."
msgstr ""

#: ../source/overview.rst:119
msgid "Python binary distributions"
msgstr ""

#: ../source/overview.rst:121
msgid "So much of Python's practical power comes from its ability to integrate with the software ecosystem, in particular libraries written in C, C++, Fortran, Rust, and other languages."
msgstr ""

#: ../source/overview.rst:125
msgid "Not all developers have the right tools or experiences to build these components written in these compiled languages, so Python created the :term:`Wheel`, a package format designed to ship libraries with compiled artifacts. In fact, Python's package installer, ``pip``, always prefers wheels because installation is always faster, so even pure-Python packages work better with wheels."
msgstr ""

#: ../source/overview.rst:132
msgid "Binary distributions are best when they come with source distributions to match. Even if you don't upload wheels of your code for every operating system, by uploading the sdist, you're enabling users of other platforms to still build it for themselves. Default to publishing both sdist and wheel archives together, *unless* you're creating artifacts for a very specific use case where you know the recipient only needs one or the other."
msgstr ""

#: ../source/overview.rst:140
msgid "Python and PyPI make it easy to upload both wheels and sdists together. Just follow the :doc:`tutorials/packaging-projects` tutorial."
msgstr ""

#: ../source/overview.rst:148
msgid "Python's recommended built-in library and tool packaging technologies. Excerpted from `The Packaging Gradient (2017) <https://www.youtube.com/watch?v=iLVNWfPWAC8>`_."
msgstr ""

#: ../source/overview.rst:155
msgid "Packaging Python applications"
msgstr ""

#: ../source/overview.rst:157
msgid "So far we've only discussed Python's native distribution tools. Based on our introduction, you would be correct to infer these built-in approaches only target environments which have Python, and an audience who knows how to install Python packages."
msgstr ""

#: ../source/overview.rst:162
msgid "With the variety of operating systems, configurations, and people out there, this assumption is only safe when targeting a developer audience."
msgstr ""

#: ../source/overview.rst:166
msgid "Python's native packaging is mostly built for distributing reusable code, called libraries, between developers. You can piggyback **tools**, or basic applications for developers, on top of Python's library packaging, using technologies like `setuptools entry_points <https://setuptools.readthedocs.io/en/latest/userguide/entry_point.html>`_."
msgstr ""

#: ../source/overview.rst:172
msgid "Libraries are building blocks, not complete applications. For distributing applications, there's a whole new world of technologies out there."
msgstr ""

#: ../source/overview.rst:176
msgid "The next few sections organize these application packaging options according to their dependencies on the target environment, so you can choose the right one for your project."
msgstr ""

#: ../source/overview.rst:181
msgid "Depending on a framework"
msgstr ""

#: ../source/overview.rst:183
msgid "Some types of Python applications, like web site backends and other network services, are common enough that they have frameworks to enable their development and packaging. Other types of applications, like dynamic web frontends and mobile clients, are complex enough to target that a framework becomes more than a convenience."
msgstr ""

#: ../source/overview.rst:189
msgid "In all these cases, it makes sense to work backwards, from the framework's packaging and deployment story. Some frameworks include a deployment system which wraps the technologies outlined in the rest of the guide. In these cases, you'll want to defer to your framework's packaging guide for the easiest and most reliable production experience."
msgstr ""

#: ../source/overview.rst:195
msgid "If you ever wonder how these platforms and frameworks work under the hood, you can always read the sections beyond."
msgstr ""

#: ../source/overview.rst:199
msgid "Service platforms"
msgstr ""

#: ../source/overview.rst:201
msgid "If you're developing for a \"Platform-as-a-Service\" or \"PaaS\" like Heroku or Google App Engine, you are going to want to follow their respective packaging guides."
msgstr ""

#: ../source/overview.rst:205
msgid "`Heroku <https://devcenter.heroku.com/articles/getting-started-with-python>`_"
msgstr ""

#: ../source/overview.rst:206
msgid "`Google App Engine <https://cloud.google.com/appengine/docs/python/>`_"
msgstr ""

#: ../source/overview.rst:207
msgid "`PythonAnywhere <https://www.pythonanywhere.com/>`_"
msgstr ""

#: ../source/overview.rst:208
msgid "`OpenShift <https://blog.openshift.com/getting-started-python/>`_"
msgstr ""

#: ../source/overview.rst:209
msgid "\"Serverless\" frameworks like `Zappa <https://www.zappa.io/>`_"
msgstr ""

#: ../source/overview.rst:211
msgid "In all these setups, the platform takes care of packaging and deployment, as long as you follow their patterns. Most software does not fit one of these templates, hence the existence of all the other options below."
msgstr ""

#: ../source/overview.rst:216
msgid "If you're developing software that will be deployed to machines you own, users' personal computers, or any other arrangement, read on."
msgstr ""

#: ../source/overview.rst:220
msgid "Web browsers and mobile applications"
msgstr ""

#: ../source/overview.rst:222
msgid "Python's steady advances are leading it into new spaces. These days you can write a mobile app or web application frontend in Python. While the language may be familiar, the packaging and deployment practices are brand new."
msgstr ""

#: ../source/overview.rst:227
msgid "If you're planning on releasing to these new frontiers, you'll want to check out the following frameworks, and refer to their packaging guides:"
msgstr ""

#: ../source/overview.rst:231
msgid "`Kivy <https://kivy.org/#home>`_"
msgstr ""

#: ../source/overview.rst:232
msgid "`Beeware <https://pybee.org/>`_"
msgstr ""

#: ../source/overview.rst:233
msgid "`Brython <https://brython.info/>`_"
msgstr ""

#: ../source/overview.rst:234
msgid "`Flexx <http://flexx.readthedocs.io/en/latest/>`_"
msgstr ""

#: ../source/overview.rst:236
msgid "If you are *not* interested in using a framework or platform, or just wonder about some of the technologies and techniques utilized by the frameworks above, continue reading below."
msgstr ""

#: ../source/overview.rst:241
msgid "Depending on a pre-installed Python"
msgstr ""

#: ../source/overview.rst:243
msgid "Pick an arbitrary computer, and depending on the context, there's a very good chance Python is already installed. Included by default in most Linux and Mac operating systems for many years now, you can reasonably depend on Python preexisting in your data centers or on the personal machines of developers and data scientists."
msgstr ""

#: ../source/overview.rst:249
msgid "Technologies which support this model:"
msgstr ""

#: ../source/overview.rst:251
msgid "`PEX <https://github.com/pantsbuild/pex#pex>`_ (Python EXecutable)"
msgstr ""

#: ../source/overview.rst:252
msgid "`zipapp <https://docs.python.org/3/library/zipapp.html>`_ (does not help manage dependencies, requires Python 3.5+)"
msgstr ""

#: ../source/overview.rst:253
msgid "`shiv <https://github.com/linkedin/shiv#shiv>`_ (requires Python 3)"
msgstr ""

#: ../source/overview.rst:255
msgid "Of all the approaches here, depending on a pre-installed Python relies the most on the target environment. Of course, this also makes for the smallest package, as small as single-digit megabytes, or even kilobytes."
msgstr ""

#: ../source/overview.rst:260
msgid "In general, decreasing the dependency on the target system increases the size of our package, so the solutions here are roughly arranged by increasing size of output."
msgstr ""

#: ../source/overview.rst:267
msgid "Depending on a separate software distribution ecosystem"
msgstr ""

#: ../source/overview.rst:269
msgid "For a long time many operating systems, including Mac and Windows, lacked built-in package management. Only recently did these OSes gain so-called \"app stores\", but even those focus on consumer applications and offer little for developers."
msgstr ""

#: ../source/overview.rst:274
msgid "Developers long sought remedies, and in this struggle, emerged with their own package management solutions, such as `Homebrew <https://brew.sh/>`_. The most relevant alternative for Python developers is a package ecosystem called `Anaconda <https://en.wikipedia.org/wiki/Anaconda_(Python_distribution)>`_. Anaconda is built around Python and is increasingly common in academic, analytical, and other data-oriented environments, even making its way `into server-oriented environments <https://www.paypal-engineering.com/2016/09/07/python-packaging-at-paypal/>`_."
msgstr ""

#: ../source/overview.rst:284
msgid "Instructions on building and publishing for the Anaconda ecosystem:"
msgstr ""

#: ../source/overview.rst:286
msgid "`Building libraries and applications with conda <https://conda.io/docs/user-guide/tutorials/index.html>`_"
msgstr ""

#: ../source/overview.rst:287
msgid "`Transitioning a native Python package to Anaconda <https://conda.io/docs/user-guide/tutorials/build-pkgs-skeleton.html>`_"
msgstr ""

#: ../source/overview.rst:289
msgid "A similar model involves installing an alternative Python distribution, but does not support arbitrary operating system-level packages:"
msgstr ""

#: ../source/overview.rst:293
msgid "`Enthought Canopy <https://www.enthought.com/product/canopy/>`_"
msgstr ""

#: ../source/overview.rst:294
msgid "`ActiveState ActivePython <https://www.activestate.com/activepython>`_"
msgstr ""

#: ../source/overview.rst:295
msgid "`WinPython <http://winpython.github.io/>`_"
msgstr ""

#: ../source/overview.rst:300
msgid "Bringing your own Python executable"
msgstr ""

#: ../source/overview.rst:302
msgid "Computing as we know it is defined by the ability to execute programs. Every operating system natively supports one or more formats of program they can natively execute."
msgstr ""

#: ../source/overview.rst:306
msgid "There are many techniques and technologies which turn your Python program into one of these formats, most of which involve embedding the Python interpreter and any other dependencies into a single executable file."
msgstr ""

#: ../source/overview.rst:311
msgid "This approach, called *freezing*, offers wide compatibility and seamless user experience, though often requires multiple technologies, and a good amount of effort."
msgstr ""

#: ../source/overview.rst:315
msgid "A selection of Python freezers:"
msgstr ""

#: ../source/overview.rst:317
msgid "`pyInstaller <http://www.pyinstaller.org/>`_ - Cross-platform"
msgstr ""

#: ../source/overview.rst:318
msgid "`cx_Freeze <https://marcelotduarte.github.io/cx_Freeze/>`_ - Cross-platform"
msgstr ""

#: ../source/overview.rst:319
msgid "`constructor <https://github.com/conda/constructor>`_ - For command-line installers"
msgstr ""

#: ../source/overview.rst:320
msgid "`py2exe <http://www.py2exe.org/>`_ - Windows only"
msgstr ""

#: ../source/overview.rst:321
msgid "`py2app <https://py2app.readthedocs.io/en/latest/>`_ - Mac only"
msgstr ""

#: ../source/overview.rst:322
msgid "`bbFreeze <https://pypi.org/project/bbfreeze>`_ - Windows, Linux, Python 2 only"
msgstr ""

#: ../source/overview.rst:323
msgid "`osnap <https://github.com/jamesabel/osnap>`_ - Windows and Mac"
msgstr ""

#: ../source/overview.rst:324
msgid "`pynsist <https://pypi.org/project/pynsist/>`_ - Windows only"
msgstr ""

#: ../source/overview.rst:326
msgid "Most of the above imply single-user deployments. For multi-component server applications, see `Chef Omnibus <https://github.com/chef/omnibus#-omnibus>`_."
msgstr ""

#: ../source/overview.rst:332
msgid "Bringing your own userspace"
msgstr ""

#: ../source/overview.rst:334
msgid "An increasing number of operating systems -- including Linux, Mac OS, and Windows -- can be set up to run applications packaged as lightweight images, using a relatively modern arrangement often referred to as `operating-system-level virtualization <https://en.wikipedia.org/wiki/Operating-system-level_virtualization>`_, or *containerization*."
msgstr ""

#: ../source/overview.rst:341
msgid "These techniques are mostly Python agnostic, because they package whole OS filesystems, not just Python or Python packages."
msgstr ""

#: ../source/overview.rst:344
msgid "Adoption is most extensive among Linux servers, where the technology originated and where the technologies below work best:"
msgstr ""

#: ../source/overview.rst:347
msgid "`AppImage <https://appimage.org/>`_"
msgstr ""

#: ../source/overview.rst:348
msgid "`Docker <https://www.fullstackpython.com/docker.html>`_"
msgstr ""

#: ../source/overview.rst:349
msgid "`Flatpak <https://flatpak.org/>`_"
msgstr ""

#: ../source/overview.rst:350
msgid "`Snapcraft <https://snapcraft.io/>`_"
msgstr ""

#: ../source/overview.rst:353
msgid "Bringing your own kernel"
msgstr ""

#: ../source/overview.rst:355
msgid "Most operating systems support some form of classical virtualization, running applications packaged as images containing a full operating system of their own. Running these virtual machines, or VMs, is a mature approach, widespread in data center environments."
msgstr ""

#: ../source/overview.rst:360
msgid "These techniques are mostly reserved for larger scale deployments in data centers, though certain complex applications can benefit from this packaging. Technologies are Python agnostic, and include:"
msgstr ""

#: ../source/overview.rst:364
msgid "`Vagrant <https://www.vagrantup.com/>`_"
msgstr ""

#: ../source/overview.rst:365
msgid "`VHD <https://en.wikipedia.org/wiki/VHD_(file_format)>`_, `AMI <https://en.wikipedia.org/wiki/Amazon_Machine_Image>`_, and `other formats <https://docs.openstack.org/image-guide/image-formats.html>`_"
msgstr ""

#: ../source/overview.rst:366
msgid "`OpenStack <https://www.redhat.com/en/topics/openstack>`_ - A cloud management system in Python, with extensive VM support"
msgstr ""

#: ../source/overview.rst:369
msgid "Bringing your own hardware"
msgstr ""

#: ../source/overview.rst:371
msgid "The most all-encompassing way to ship your software would be to ship it already-installed on some hardware. This way, your software's user would require only electricity."
msgstr ""

#: ../source/overview.rst:375
msgid "Whereas the virtual machines described above are primarily reserved for the tech-savvy, you can find hardware appliances being used by everyone from the most advanced data centers to the youngest children."
msgstr ""

#: ../source/overview.rst:379
msgid "Embed your code on an `Adafruit <https://github.com/adafruit/circuitpython#adafruit-circuitpython>`_, `MicroPython <https://micropython.org/>`_, or more-powerful hardware running Python, then ship it to the datacenter or your users' homes. They plug and play, and you can call it a day."
msgstr ""

#: ../source/overview.rst:389
msgid "The simplified gamut of technologies used to package Python applications."
msgstr ""

#: ../source/overview.rst:392
msgid "What about..."
msgstr ""

#: ../source/overview.rst:394
msgid "The sections above can only summarize so much, and you might be wondering about some of the more conspicuous gaps."
msgstr ""

#: ../source/overview.rst:398
msgid "Operating system packages"
msgstr ""

#: ../source/overview.rst:400
msgid "As mentioned in :ref:`depending-on-a-separate-ecosystem` above, some operating systems have package managers of their own. If you're very sure of the operating system you're targeting, you can depend directly on a format like `deb <https://en.wikipedia.org/wiki/Deb_(file_format)>`_ (for Debian, Ubuntu, etc.) or `RPM <https://en.wikipedia.org/wiki/RPM_Package_Manager>`_ (for Red Hat, Fedora, etc.), and use that built-in package manager to take care of installation, and even deployment. You can even use `FPM <https://fpm.readthedocs.io/en/latest/source/virtualenv.html>`_ to generate both deb and RPMs from the same source."
msgstr ""

#: ../source/overview.rst:411
msgid "In most deployment pipelines, the OS package manager is just one piece of the puzzle."
msgstr ""

#: ../source/overview.rst:417
msgid "`Virtualenvs <http://python-guide.readthedocs.io/en/latest/dev/virtualenvs/>`_ have been an indispensable tool for multiple generations of Python developer, but are slowly fading from view, as they are being wrapped by higher-level tools. With packaging in particular, virtualenvs are used as a primitive in `the dh-virtualenv tool <http://dh-virtualenv.readthedocs.io/en/1.0/tutorial.html>`_ and `osnap <https://github.com/jamesabel/osnap>`_, both of which wrap virtualenvs in a self-contained way."
msgstr ""

#: ../source/overview.rst:427
msgid "For production deployments, do not rely on running ``python -m pip install`` from the Internet into a virtualenv, as one might do in a development environment. The overview above is full of much better solutions."
msgstr ""

#: ../source/overview.rst:432
msgid "Security"
msgstr ""

#: ../source/overview.rst:434
msgid "The further down the gradient you come, the harder it gets to update components of your package. Everything is more tightly bound together."
msgstr ""

#: ../source/overview.rst:437
msgid "For example, if a kernel security issue emerges, and you're deploying containers, the host system's kernel can be updated without requiring a new build on behalf of the application. If you deploy VM images, you'll need a new build. Whether or not this dynamic makes one option more secure is still a bit of an old debate, going back to the still-unsettled matter of `static versus dynamic linking <https://www.google.com/search?channel=fs&q=static+vs+dynamic+linking>`_."
msgstr ""

#: ../source/overview.rst:446
msgid "Wrap up"
msgstr ""

#: ../source/overview.rst:448
msgid "Packaging in Python has a bit of a reputation for being a bumpy ride. This impression is mostly a byproduct of Python's versatility. Once you understand the natural boundaries between each packaging solution, you begin to realize that the varied landscape is a small price Python programmers pay for using one of the most balanced, flexible languages available."
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:6
msgid "Binary distribution format"
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:8
msgid "The binary distribution format (:term:`wheel <Wheel>`) was originally defined in :pep:`427`. The current version of the specification is here."
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:13
msgid "Abstract"
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:15
msgid "This PEP describes a built-package format for Python called \"wheel\"."
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:17
msgid "A wheel is a ZIP-format archive with a specially formatted file name and the ``.whl`` extension.  It contains a single distribution nearly as it would be installed according to PEP 376 with a particular installation scheme.  Although a specialized installer is recommended, a wheel file may be installed by simply unpacking into site-packages with the standard 'unzip' tool while preserving enough information to spread its contents out onto their final paths at any later time."
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:27
msgid "PEP Acceptance"
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:29
msgid "This PEP was accepted, and the defined wheel version updated to 1.0, by Nick Coghlan on 16th February, 2013 [1]_"
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:34
msgid "Rationale"
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:36
msgid "Python needs a package format that is easier to install than sdist. Python's sdist packages are defined by and require the distutils and setuptools build systems, running arbitrary code to build-and-install, and re-compile, code just so it can be installed into a new virtualenv.  This system of conflating build-install is slow, hard to maintain, and hinders innovation in both build systems and installers."
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:43
msgid "Wheel attempts to remedy these problems by providing a simpler interface between the build system and the installer.  The wheel binary package format frees installers from having to know about the build system, saves time by amortizing compile time over many installations, and removes the need to install a build system in the target environment."
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:52
msgid "Details"
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:55
msgid "Installing a wheel 'distribution-1.0-py32-none-any.whl'"
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:57
msgid "Wheel installation notionally consists of two phases:"
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:59
msgid "Unpack."
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:61
msgid "Parse ``distribution-1.0.dist-info/WHEEL``."
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:62
msgid "Check that installer is compatible with Wheel-Version.  Warn if minor version is greater, abort if major version is greater."
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:64
msgid "If Root-Is-Purelib == 'true', unpack archive into purelib (site-packages)."
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:66
msgid "Else unpack archive into platlib (site-packages)."
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:68
msgid "Spread."
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:70
msgid "Unpacked archive includes ``distribution-1.0.dist-info/`` and (if there is data) ``distribution-1.0.data/``."
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:72
msgid "Move each subtree of ``distribution-1.0.data/`` onto its destination path. Each subdirectory of ``distribution-1.0.data/`` is a key into a dict of destination directories, such as ``distribution-1.0.data/(purelib|platlib|headers|scripts|data)``. The initially supported paths are taken from ``distutils.command.install``."
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:78
msgid "If applicable, update scripts starting with ``#!python`` to point to the correct interpreter."
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:80
msgid "Update ``distribution-1.0.dist-info/RECORD`` with the installed paths."
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:82
msgid "Remove empty ``distribution-1.0.data`` directory."
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:83
msgid "Compile any installed .py to .pyc. (Uninstallers should be smart enough to remove .pyc even if it is not mentioned in RECORD.)"
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:87
msgid "Recommended installer features"
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:97
msgid "Rewrite ``#!python``."
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:90
msgid "In wheel, scripts are packaged in ``{distribution}-{version}.data/scripts/``.  If the first line of a file in ``scripts/`` starts with exactly ``b'#!python'``, rewrite to point to the correct interpreter.  Unix installers may need to add the +x bit to these files if the archive was created on Windows."
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:96
msgid "The ``b'#!pythonw'`` convention is allowed. ``b'#!pythonw'`` indicates a GUI script instead of a console script."
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:102
msgid "Generate script wrappers."
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:100
msgid "In wheel, scripts packaged on Unix systems will certainly not have accompanying .exe wrappers.  Windows installers may want to add them during install."
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:105
msgid "Recommended archiver features"
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:112
msgid "Place ``.dist-info`` at the end of the archive."
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:108
msgid "Archivers are encouraged to place the ``.dist-info`` files physically at the end of the archive.  This enables some potentially interesting ZIP tricks including the ability to amend the metadata without rewriting the entire archive."
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:115
msgid "File Format"
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:118
msgid "File name convention"
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:120
msgid "The wheel filename is ``{distribution}-{version}(-{build tag})?-{python tag}-{abi tag}-{platform tag}.whl``."
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:124
msgid "distribution"
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:124
msgid "Distribution name, e.g. 'django', 'pyramid'."
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:127
msgid "Distribution version, e.g. 1.0."
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:135
msgid "build tag"
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:130
msgid "Optional build number.  Must start with a digit.  Acts as a tie-breaker if two wheel file names are the same in all other respects (i.e. name, version, and other tags).  Sort as an empty tuple if unspecified, else sort as a two-item tuple with the first item being the initial digits as an ``int``, and the second item being the remainder of the tag as a ``str``."
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:138
msgid "language implementation and version tag"
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:138
msgid "E.g. 'py27', 'py2', 'py3'."
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:141
msgid "abi tag"
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:141
msgid "E.g. 'cp33m', 'abi3', 'none'."
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:144
msgid "platform tag"
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:144
msgid "E.g. 'linux_x86_64', 'any'."
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:146
msgid "For example, ``distribution-1.0-1-py27-none-any.whl`` is the first build of a package called 'distribution', and is compatible with Python 2.7 (any Python 2.7 implementation), with no ABI (pure Python), on any CPU architecture."
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:151
msgid "The last three components of the filename before the extension are called \"compatibility tags.\"  The compatibility tags express the package's basic interpreter requirements and are detailed in PEP 425."
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:156
msgid "Escaping and Unicode"
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:158
msgid "As the components of the filename are separated by a dash (``-``, HYPHEN-MINUS), this character cannot appear within any component. This is handled as follows:"
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:161
msgid "In distribution names, any run of ``-_.`` characters (HYPHEN-MINUS, LOW LINE and FULL STOP) should be replaced with ``_`` (LOW LINE). This is equivalent to :pep:`503` normalisation followed by replacing ``-`` with ``_``."
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:164
msgid "Version numbers should be normalised according to :pep:`440`. Normalised version numbers cannot contain ``-``."
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:166
msgid "The remaining components may not contain ``-`` characters, so no escaping is necessary."
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:169
msgid "Tools producing wheels should verify that the filename components do not contain ``-``, as the resulting file may not be processed correctly if they do."
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:172
msgid "The archive filename is Unicode.  It will be some time before the tools are updated to support non-ASCII filenames, but they are supported in this specification."
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:176
msgid "The filenames *inside* the archive are encoded as UTF-8.  Although some ZIP clients in common use do not properly display UTF-8 filenames, the encoding is supported by both the ZIP specification and Python's ``zipfile``."
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:182
msgid "File contents"
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:184
msgid "The contents of a wheel file, where {distribution} is replaced with the name of the package, e.g. ``beaglevote`` and {version} is replaced with its version, e.g. ``1.0.0``, consist of:"
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:188
msgid "``/``, the root of the archive, contains all files to be installed in ``purelib`` or ``platlib`` as specified in ``WHEEL``.  ``purelib`` and ``platlib`` are usually both ``site-packages``."
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:191
msgid "``{distribution}-{version}.dist-info/`` contains metadata."
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:192
msgid "``{distribution}-{version}.data/`` contains one subdirectory for each non-empty install scheme key not already covered, where the subdirectory name is an index into a dictionary of install paths (e.g. ``data``, ``scripts``, ``include``, ``purelib``, ``platlib``)."
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:196
msgid "Python scripts must appear in ``scripts`` and begin with exactly ``b'#!python'`` in order to enjoy script wrapper generation and ``#!python`` rewriting at install time.  They may have any or no extension."
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:200
msgid "``{distribution}-{version}.dist-info/METADATA`` is Metadata version 1.1 or greater format metadata."
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:202
msgid "``{distribution}-{version}.dist-info/WHEEL`` is metadata about the archive itself in the same basic key: value format::"
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:212
msgid "``Wheel-Version`` is the version number of the Wheel specification."
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:213
msgid "``Generator`` is the name and optionally the version of the software that produced the archive."
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:215
msgid "``Root-Is-Purelib`` is true if the top level directory of the archive should be installed into purelib; otherwise the root should be installed into platlib."
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:218
msgid "``Tag`` is the wheel's expanded compatibility tags; in the example the filename would contain ``py2.py3-none-any``."
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:220
msgid "``Build`` is the build number and is omitted if there is no build number."
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:221
msgid "A wheel installer should warn if Wheel-Version is greater than the version it supports, and must fail if Wheel-Version has a greater major version than the version it supports."
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:224
msgid "Wheel, being an installation format that is intended to work across multiple versions of Python, does not generally include .pyc files."
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:226
msgid "Wheel does not contain setup.py or setup.cfg."
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:228
msgid "This version of the wheel specification is based on the distutils install schemes and does not define how to install files to other locations. The layout offers a superset of the functionality provided by the existing wininst and egg binary formats."
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:235
#: ../source/specifications/recording-installed-packages.rst:35
msgid "The .dist-info directory"
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:237
msgid "Wheel .dist-info directories include at a minimum METADATA, WHEEL, and RECORD."
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:239
msgid "METADATA is the package metadata, the same format as PKG-INFO as found at the root of sdists."
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:241
msgid "WHEEL is the wheel metadata specific to a build of the package."
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:242
msgid "RECORD is a list of (almost) all the files in the wheel and their secure hashes.  Unlike PEP 376, every file except RECORD, which cannot contain a hash of itself, must include its hash.  The hash algorithm must be sha256 or better; specifically, md5 and sha1 are not permitted, as signed wheel files rely on the strong hashes in RECORD to validate the integrity of the archive."
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:248
msgid "PEP 376's INSTALLER and REQUESTED are not included in the archive."
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:249
msgid "RECORD.jws is used for digital signatures.  It is not mentioned in RECORD."
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:251
msgid "RECORD.p7s is allowed as a courtesy to anyone who would prefer to use S/MIME signatures to secure their wheel files.  It is not mentioned in RECORD."
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:254
msgid "During extraction, wheel installers verify all the hashes in RECORD against the file contents.  Apart from RECORD and its signatures, installation will fail if any file in the archive is not both mentioned and correctly hashed in RECORD."
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:261
msgid "The .data directory"
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:263
msgid "Any file that is not normally installed inside site-packages goes into the .data directory, named as the .dist-info directory but with the .data/ extension::"
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:271
msgid "The .data directory contains subdirectories with the scripts, headers, documentation and so forth from the distribution.  During installation the contents of these subdirectories are moved onto their destination paths."
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:277
msgid "Signed wheel files"
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:279
msgid "Wheel files include an extended RECORD that enables digital signatures.  PEP 376's RECORD is altered to include a secure hash ``digestname=urlsafe_b64encode_nopad(digest)`` (urlsafe base64 encoding with no trailing = characters) as the second column instead of an md5sum.  All possible entries are hashed, including any generated files such as .pyc files, but not RECORD which cannot contain its own hash. For example::"
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:290
msgid "The signature file(s) RECORD.jws and RECORD.p7s are not mentioned in RECORD at all since they can only be added after RECORD is generated. Every other file in the archive must have a correct hash in RECORD or the installation will fail."
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:295
msgid "If JSON web signatures are used, one or more JSON Web Signature JSON Serialization (JWS-JS) signatures is stored in a file RECORD.jws adjacent to RECORD.  JWS is used to sign RECORD by including the SHA-256 hash of RECORD as the signature's JSON payload::"
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:302
msgid "(The hash value is the same format used in RECORD.)"
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:304
msgid "If RECORD.p7s is used, it must contain a detached S/MIME format signature of RECORD."
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:307
msgid "A wheel installer is not required to understand digital signatures but MUST verify the hashes in RECORD against the extracted file contents. When the installer checks file hashes against RECORD, a separate signature checker only needs to establish that RECORD matches the signature."
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:312
msgid "See"
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:314
msgid "http://self-issued.info/docs/draft-ietf-jose-json-web-signature.html"
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:315
msgid "http://self-issued.info/docs/draft-jones-jose-jws-json-serialization.html"
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:316
msgid "http://self-issued.info/docs/draft-ietf-jose-json-web-key.html"
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:317
msgid "http://self-issued.info/docs/draft-jones-jose-json-private-key.html"
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:321
msgid "Comparison to .egg"
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:323
msgid "Wheel is an installation format; egg is importable.  Wheel archives do not need to include .pyc and are less tied to a specific Python version or implementation. Wheel can install (pure Python) packages built with previous versions of Python so you don't always have to wait for the packager to catch up."
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:328
msgid "Wheel uses .dist-info directories; egg uses .egg-info.  Wheel is compatible with the new world of Python packaging and the new concepts it brings."
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:331
msgid "Wheel has a richer file naming convention for today's multi-implementation world.  A single wheel archive can indicate its compatibility with a number of Python language versions and implementations, ABIs, and system architectures.  Historically the ABI has been specific to a CPython release, wheel is ready for the stable ABI."
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:337
msgid "Wheel is lossless.  The first wheel implementation bdist_wheel always generates egg-info, and then converts it to a .whl.  It is also possible to convert existing eggs and bdist_wininst distributions."
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:341
msgid "Wheel is versioned.  Every wheel file contains the version of the wheel specification and the implementation that packaged it. Hopefully the next migration can simply be to Wheel 2.0."
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:344
msgid "Wheel is a reference to the other Python."
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:348
msgid "FAQ"
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:352
msgid "Wheel defines a .data directory.  Should I put all my data there?"
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:354
msgid "This specification does not have an opinion on how you should organize your code.  The .data directory is just a place for any files that are not normally installed inside ``site-packages`` or on the PYTHONPATH. In other words, you may continue to use ``pkgutil.get_data(package, resource)`` even though *those* files will usually not be distributed in *wheel's* ``.data`` directory."
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:363
msgid "Why does wheel include attached signatures?"
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:365
msgid "Attached signatures are more convenient than detached signatures because they travel with the archive.  Since only the individual files are signed, the archive can be recompressed without invalidating the signature or individual files can be verified without having to download the whole archive."
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:373
msgid "Why does wheel allow JWS signatures?"
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:375
msgid "The JOSE specifications of which JWS is a part are designed to be easy to implement, a feature that is also one of wheel's primary design goals.  JWS yields a useful, concise pure-Python implementation."
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:381
msgid "Why does wheel also allow S/MIME signatures?"
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:383
msgid "S/MIME signatures are allowed for users who need or want to use existing public key infrastructure with wheel."
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:386
msgid "Signed packages are only a basic building block in a secure package update system.  Wheel only provides the building block."
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:391
msgid "What's the deal with \"purelib\" vs. \"platlib\"?"
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:393
msgid "Wheel preserves the \"purelib\" vs. \"platlib\" distinction, which is significant on some platforms. For example, Fedora installs pure Python packages to '/usr/lib/pythonX.Y/site-packages' and platform dependent packages to '/usr/lib64/pythonX.Y/site-packages'."
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:398
msgid "A wheel with \"Root-Is-Purelib: false\" with all its files in ``{name}-{version}.data/purelib`` is equivalent to a wheel with \"Root-Is-Purelib: true\" with those same files in the root, and it is legal to have files in both the \"purelib\" and \"platlib\" categories."
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:403
msgid "In practice a wheel should have only one of \"purelib\" or \"platlib\" depending on whether it is pure Python or not and those files should be at the root with the appropriate setting given for \"Root-is-purelib\"."
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:409
msgid "Is it possible to import Python code directly from a wheel file?"
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:411
msgid "Technically, due to the combination of supporting installation via simple extraction and using an archive format that is compatible with ``zipimport``, a subset of wheel files *do* support being placed directly on ``sys.path``. However, while this behaviour is a natural consequence of the format design, actually relying on it is generally discouraged."
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:417
msgid "Firstly, wheel *is* designed primarily as a distribution format, so skipping the installation step also means deliberately avoiding any reliance on features that assume full installation (such as being able to use standard tools like ``pip`` and ``virtualenv`` to capture and manage dependencies in a way that can be properly tracked for auditing and security update purposes, or integrating fully with the standard build machinery for C extensions by publishing header files in the appropriate place)."
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:426
msgid "Secondly, while some Python software is written to support running directly from a zip archive, it is still common for code to be written assuming it has been fully installed. When that assumption is broken by trying to run the software from a zip archive, the failures can often be obscure and hard to diagnose (especially when they occur in third party libraries). The two most common sources of problems with this are the fact that importing C extensions from a zip archive is *not* supported by CPython (since doing so is not supported directly by the dynamic loading machinery on any platform) and that when running from a zip archive the ``__file__`` attribute no longer refers to an ordinary filesystem path, but to a combination path that includes both the location of the zip archive on the filesystem and the relative path to the module inside the archive. Even when software correctly uses the abstract resource APIs internally, interfacing with external components may still require the availability of an actual on-disk file."
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:443
msgid "Like metaclasses, monkeypatching and metapath importers, if you're not already sure you need to take advantage of this feature, you almost certainly don't need it. If you *do* decide to use it anyway, be aware that many projects will require a failure to be reproduced with a fully installed package before accepting it as a genuine bug."
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:450
msgid "Changes"
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:452
msgid "Since :pep:`427`, this specification has changed as follows:"
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:454
msgid "The rules on escaping in wheel filenames were revised, to bring them into line with what popular tools actually do (February 2021)."
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:461
msgid "PEP acceptance (https://mail.python.org/pipermail/python-dev/2013-February/124103.html)"
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:466
msgid "Appendix"
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:468
msgid "Example urlsafe-base64-nopad implementation::"
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:482
msgid "Copyright"
msgstr ""

#: ../source/specifications/binary-distribution-format.rst:484
msgid "This document has been placed into the public domain."
msgstr ""

#: ../source/specifications/core-metadata.rst:5
msgid "Core metadata specifications"
msgstr ""

#: ../source/specifications/core-metadata.rst:7
msgid "Fields defined in the following specification should be considered valid, complete and not subject to change. The required fields are:"
msgstr ""

#: ../source/specifications/core-metadata.rst:10
msgid "``Metadata-Version``"
msgstr ""

#: ../source/specifications/core-metadata.rst:11
msgid "``Name``"
msgstr ""

#: ../source/specifications/core-metadata.rst:12
msgid "``Version``"
msgstr ""

#: ../source/specifications/core-metadata.rst:14
msgid "All the other fields are optional."
msgstr ""

#: ../source/specifications/core-metadata.rst:16
msgid "The standard file format for metadata (including in :doc:`wheels <binary-distribution-format>` and :doc:`installed projects <recording-installed-packages>`) is based on the format of email headers. However, email formats have been revised several times, and exactly which email RFC applies to packaging metadata is not specified. In the absence of a precise definition, the practical standard is set by what the standard library :mod:`python:email.parser` module can parse using the :data:`~.python:email.policy.compat32` policy."
msgstr ""

#: ../source/specifications/core-metadata.rst:25
msgid "Although :pep:`566` defined a way to transform metadata into a JSON-compatible dictionary, this is not yet used as a standard interchange format. The need for tools to work with years worth of existing packages makes it difficult to shift to a new format."
msgstr ""

#: ../source/specifications/core-metadata.rst:30
msgid "*Interpreting old metadata:* In :pep:`566`, the version specifier field format specification was relaxed to accept the syntax used by popular publishing tools (namely to remove the requirement that version specifiers must be surrounded by parentheses). Metadata consumers may want to use the more relaxed formatting rules even for metadata files that are nominally less than version 2.1."
msgstr ""

#: ../source/specifications/core-metadata.rst:41
msgid "Metadata-Version"
msgstr ""

#: ../source/specifications/core-metadata.rst:45
msgid "Version of the file format; legal values are \"1.0\", \"1.1\", \"1.2\", \"2.1\" and \"2.2\"."
msgstr ""

#: ../source/specifications/core-metadata.rst:48
msgid "Automated tools consuming metadata SHOULD warn if ``metadata_version`` is greater than the highest version they support, and MUST fail if ``metadata_version`` has a greater major version than the highest version they support (as described in :pep:`440`, the major version is the value before the first dot)."
msgstr ""

#: ../source/specifications/core-metadata.rst:54
msgid "For broader compatibility, build tools MAY choose to produce distribution metadata using the lowest metadata version that includes all of the needed fields."
msgstr ""

#: ../source/specifications/core-metadata.rst:58
#: ../source/specifications/core-metadata.rst:80
#: ../source/specifications/core-metadata.rst:95
#: ../source/specifications/core-metadata.rst:155
#: ../source/specifications/core-metadata.rst:170
#: ../source/specifications/core-metadata.rst:208
#: ../source/specifications/core-metadata.rst:283
#: ../source/specifications/core-metadata.rst:287
#: ../source/specifications/core-metadata.rst:291
#: ../source/specifications/core-metadata.rst:295
#: ../source/specifications/core-metadata.rst:327
#: ../source/specifications/core-metadata.rst:347
#: ../source/specifications/core-metadata.rst:373
#: ../source/specifications/core-metadata.rst:391
#: ../source/specifications/core-metadata.rst:416
#: ../source/specifications/core-metadata.rst:438
#: ../source/specifications/core-metadata.rst:600
#: ../source/specifications/core-metadata.rst:620
#: ../source/specifications/core-metadata.rst:630
msgid "Example::"
msgstr ""

#: ../source/specifications/core-metadata.rst:66
msgid "Name"
msgstr ""

#: ../source/specifications/core-metadata.rst:69
msgid "Added additional restrictions on format from :pep:`508`"
msgstr ""

#: ../source/specifications/core-metadata.rst:72
msgid "The name of the distribution. The name field is the primary identifier for a distribution. A valid name consists only of ASCII letters and numbers, period, underscore and hyphen. It must start and end with a letter or number. Distribution names are limited to those which match the following regex (run with ``re.IGNORECASE``)::"
msgstr ""

#: ../source/specifications/core-metadata.rst:88
msgid "Version"
msgstr ""

#: ../source/specifications/core-metadata.rst:92
msgid "A string containing the distribution's version number.  This field  must be in the format specified in :pep:`440`."
msgstr ""

#: ../source/specifications/core-metadata.rst:101
msgid "Dynamic (multiple use)"
msgstr ""

#: ../source/specifications/core-metadata.rst:105
msgid "A string containing the name of another core metadata field. The field names ``Name`` and ``Version`` may not be specified in this field."
msgstr ""

#: ../source/specifications/core-metadata.rst:108
msgid "When found in the metadata of a source distribution, the following rules apply:"
msgstr ""

#: ../source/specifications/core-metadata.rst:111
msgid "If a field is *not* marked as ``Dynamic``, then the value of the field in any wheel built from the sdist MUST match the value in the sdist. If the field is not in the sdist, and not marked as ``Dynamic``, then it MUST NOT be present in the wheel."
msgstr ""

#: ../source/specifications/core-metadata.rst:115
msgid "If a field is marked as ``Dynamic``, it may contain any valid value in a wheel built from the sdist (including not being present at all)."
msgstr ""

#: ../source/specifications/core-metadata.rst:118
msgid "If the sdist metadata version is older than version 2.2, then all fields should be treated as if they were specified with ``Dynamic`` (i.e. there are no special restrictions on the metadata of wheels built from the sdist)."
msgstr ""

#: ../source/specifications/core-metadata.rst:122
msgid "In any context other than a source distribution, ``Dynamic`` is for information only, and indicates that the field value was calculated at wheel build time, and may not be the same as the value in the sdist or in other wheels for the project."
msgstr ""

#: ../source/specifications/core-metadata.rst:127
msgid "Full details of the semantics of ``Dynamic`` are described in :pep:`643`."
msgstr ""

#: ../source/specifications/core-metadata.rst:131
msgid "Platform (multiple use)"
msgstr ""

#: ../source/specifications/core-metadata.rst:135
msgid "A Platform specification describing an operating system supported by the distribution which is not listed in the \"Operating System\" Trove classifiers. See \"Classifier\" below."
msgstr ""

#: ../source/specifications/core-metadata.rst:146
msgid "Supported-Platform (multiple use)"
msgstr ""

#: ../source/specifications/core-metadata.rst:150
msgid "Binary distributions containing a PKG-INFO file will use the Supported-Platform field in their metadata to specify the OS and CPU for which the binary distribution was compiled.  The semantics of the Supported-Platform field are not specified in this PEP."
msgstr ""

#: ../source/specifications/core-metadata.rst:164
msgid "Summary"
msgstr ""

#: ../source/specifications/core-metadata.rst:168
msgid "A one-line summary of what the distribution does."
msgstr ""

#: ../source/specifications/core-metadata.rst:188
msgid "This field may be specified in the message body instead."
msgstr ""

#: ../source/specifications/core-metadata.rst:191
msgid "A longer description of the distribution that can run to several paragraphs.  Software that deals with metadata should not assume any maximum size for this field, though people shouldn't include their instruction manual as the description."
msgstr ""

#: ../source/specifications/core-metadata.rst:196
msgid "The contents of this field can be written using reStructuredText markup [1]_.  For programs that work with the metadata, supporting markup is optional; programs can also display the contents of the field as-is.  This means that authors should be conservative in the markup they use."
msgstr ""

#: ../source/specifications/core-metadata.rst:202
msgid "To support empty lines and lines with indentation with respect to the RFC 822 format, any CRLF character has to be suffixed by 7 spaces followed by a pipe (\"|\") char. As a result, the Description field is encoded into a folded field that can be interpreted by RFC822 parser [2]_."
msgstr ""

#: ../source/specifications/core-metadata.rst:219
msgid "This encoding implies that any occurrences of a CRLF followed by 7 spaces and a pipe char have to be replaced by a single CRLF when the field is unfolded using a RFC822 reader."
msgstr ""

#: ../source/specifications/core-metadata.rst:223
msgid "Alternatively, the distribution's description may instead be provided in the message body (i.e., after a completely blank line following the headers, with no indentation or other special formatting necessary)."
msgstr ""

#: ../source/specifications/core-metadata.rst:232
msgid "Description-Content-Type"
msgstr ""

#: ../source/specifications/core-metadata.rst:236
msgid "A string stating the markup syntax (if any) used in the distribution's description, so that tools can intelligently render the description."
msgstr ""

#: ../source/specifications/core-metadata.rst:239
msgid "Historically, PyPI supported descriptions in plain text and `reStructuredText (reST) <http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html>`_, and could render reST into HTML. However, it is common for distribution authors to write the description in `Markdown <https://daringfireball.net/projects/markdown/>`_ (`RFC 7763 <https://tools.ietf.org/html/rfc7763>`_) as many code hosting sites render Markdown READMEs, and authors would reuse the file for the description. PyPI didn't recognize the format and so could not render the description correctly. This resulted in many packages on PyPI with poorly-rendered descriptions when Markdown is left as plain text, or worse, was attempted to be rendered as reST. This field allows the distribution author to specify the format of their description, opening up the possibility for PyPI and other tools to be able to render Markdown and other formats."
msgstr ""

#: ../source/specifications/core-metadata.rst:253
msgid "The format of this field is the same as the ``Content-Type`` header in HTTP (i.e.: `RFC 1341 <https://www.w3.org/Protocols/rfc1341/4_Content-Type.html>`_). Briefly, this means that it has a ``type/subtype`` part and then it can optionally have a number of parameters:"
msgstr ""

#: ../source/specifications/core-metadata.rst:259
msgid "Format::"
msgstr ""

#: ../source/specifications/core-metadata.rst:263
msgid "The ``type/subtype`` part has only a few legal values:"
msgstr ""

#: ../source/specifications/core-metadata.rst:265
msgid "``text/plain``"
msgstr ""

#: ../source/specifications/core-metadata.rst:266
msgid "``text/x-rst``"
msgstr ""

#: ../source/specifications/core-metadata.rst:267
msgid "``text/markdown``"
msgstr ""

#: ../source/specifications/core-metadata.rst:269
msgid "The ``charset`` parameter can be used to specify the character encoding of the description. The only legal value is ``UTF-8``. If omitted, it is assumed to be ``UTF-8``."
msgstr ""

#: ../source/specifications/core-metadata.rst:273
msgid "Other parameters might be specific to the chosen subtype. For example, for the ``markdown`` subtype, there is an optional ``variant`` parameter that allows specifying the variant of Markdown in use (defaults to ``GFM`` if not specified). Currently, two variants are recognized:"
msgstr ""

#: ../source/specifications/core-metadata.rst:278
msgid "``GFM`` for `Github-flavored Markdown <https://tools.ietf.org/html/rfc7764#section-3.2>`_"
msgstr ""

#: ../source/specifications/core-metadata.rst:280
msgid "``CommonMark`` for `CommonMark <https://tools.ietf.org/html/rfc7764#section-3.5>`_"
msgstr ""

#: ../source/specifications/core-metadata.rst:299
msgid "If a ``Description-Content-Type`` is not specified, then applications should attempt to render it as ``text/x-rst; charset=UTF-8`` and fall back to ``text/plain`` if it is not valid rst."
msgstr ""

#: ../source/specifications/core-metadata.rst:303
msgid "If a ``Description-Content-Type`` is an unrecognized value, then the assumed content type is ``text/plain`` (Although PyPI will probably reject anything with an unrecognized value)."
msgstr ""

#: ../source/specifications/core-metadata.rst:307
msgid "If the ``Description-Content-Type`` is ``text/markdown`` and ``variant`` is not specified or is set to an unrecognized value, then the assumed ``variant`` is ``GFM``."
msgstr ""

#: ../source/specifications/core-metadata.rst:311
msgid "So for the last example above, the ``charset`` defaults to ``UTF-8`` and the ``variant`` defaults to ``GFM`` and thus it is equivalent to the example before it."
msgstr ""

#: ../source/specifications/core-metadata.rst:320
msgid "Keywords"
msgstr ""

#: ../source/specifications/core-metadata.rst:324
msgid "A list of additional keywords, separated by commas, to be used to assist searching for the distribution in a larger catalog."
msgstr ""

#: ../source/specifications/core-metadata.rst:333
msgid "The specification previously showed keywords separated by spaces, but distutils and setuptools implemented it with commas. These tools have been very widely used for many years, so it was easier to update the specification to match the de facto standard."
msgstr ""

#: ../source/specifications/core-metadata.rst:341
msgid "Home-page"
msgstr ""

#: ../source/specifications/core-metadata.rst:345
msgid "A string containing the URL for the distribution's home page."
msgstr ""

#: ../source/specifications/core-metadata.rst:353
msgid "Download-URL"
msgstr ""

#: ../source/specifications/core-metadata.rst:357
msgid "A string containing the URL from which this version of the distribution can be downloaded.  (This means that the URL can't be something like \".../BeagleVote-latest.tgz\", but instead must be \".../BeagleVote-0.45.tgz\".)"
msgstr ""

#: ../source/specifications/core-metadata.rst:366
msgid "Author"
msgstr ""

#: ../source/specifications/core-metadata.rst:370
msgid "A string containing the author's name at a minimum; additional contact information may be provided."
msgstr ""

#: ../source/specifications/core-metadata.rst:383
msgid "Author-email"
msgstr ""

#: ../source/specifications/core-metadata.rst:387
msgid "A string containing the author's e-mail address.  It can contain a name and e-mail address in the legal forms for a RFC-822 ``From:`` header."
msgstr ""

#: ../source/specifications/core-metadata.rst:395
#: ../source/specifications/core-metadata.rst:442
msgid "Per RFC-822, this field may contain multiple comma-separated e-mail addresses::"
msgstr ""

#: ../source/specifications/core-metadata.rst:405
msgid "Maintainer"
msgstr ""

#: ../source/specifications/core-metadata.rst:409
msgid "A string containing the maintainer's name at a minimum; additional contact information may be provided."
msgstr ""

#: ../source/specifications/core-metadata.rst:412
msgid "Note that this field is intended for use when a project is being maintained by someone other than the original author:  it should be omitted if it is identical to ``Author``."
msgstr ""

#: ../source/specifications/core-metadata.rst:426
msgid "Maintainer-email"
msgstr ""

#: ../source/specifications/core-metadata.rst:430
msgid "A string containing the maintainer's e-mail address.  It can contain a name and e-mail address in the legal forms for a RFC-822 ``From:`` header."
msgstr ""

#: ../source/specifications/core-metadata.rst:434
msgid "Note that this field is intended for use when a project is being maintained by someone other than the original author:  it should be omitted if it is identical to ``Author-email``."
msgstr ""

#: ../source/specifications/core-metadata.rst:452
msgid "License"
msgstr ""

#: ../source/specifications/core-metadata.rst:456
msgid "Text indicating the license covering the distribution where the license is not a selection from the \"License\" Trove classifiers. See :ref:`\"Classifier\" <metadata-classifier>` below. This field may also be used to specify a particular version of a license which is named via the ``Classifier`` field, or to indicate a variation or exception to such a license."
msgstr ""

#: ../source/specifications/core-metadata.rst:476
msgid "Classifier (multiple use)"
msgstr ""

#: ../source/specifications/core-metadata.rst:480
msgid "Each entry is a string giving a single classification value for the distribution.  Classifiers are described in :pep:`301`, and the Python Package Index publishes a dynamic list of `currently defined classifiers <https://pypi.org/classifiers/>`__."
msgstr ""

#: ../source/specifications/core-metadata.rst:485
#: ../source/specifications/core-metadata.rst:574
#: ../source/specifications/core-metadata.rst:691
#: ../source/specifications/core-metadata.rst:715
msgid "This field may be followed by an environment marker after a semicolon."
msgstr ""

#: ../source/specifications/core-metadata.rst:496
msgid "Requires-Dist (multiple use)"
msgstr ""

#: ../source/specifications/core-metadata.rst:499
#: ../source/specifications/core-metadata.rst:561
#: ../source/specifications/core-metadata.rst:663
#: ../source/specifications/core-metadata.rst:704
msgid "The field format specification was relaxed to accept the syntax used by popular publishing tools."
msgstr ""

#: ../source/specifications/core-metadata.rst:503
msgid "Each entry contains a string naming some other distutils project required by this distribution."
msgstr ""

#: ../source/specifications/core-metadata.rst:506
msgid "The format of a requirement string contains from one to four parts:"
msgstr ""

#: ../source/specifications/core-metadata.rst:508
msgid "A project name, in the same format as the ``Name:`` field. The only mandatory part."
msgstr ""

#: ../source/specifications/core-metadata.rst:510
msgid "A comma-separated list of 'extra' names. These are defined by the required project, referring to specific features which may need extra dependencies."
msgstr ""

#: ../source/specifications/core-metadata.rst:513
msgid "A version specifier. Tools parsing the format should accept optional parentheses around this, but tools generating it should not use parentheses."
msgstr ""

#: ../source/specifications/core-metadata.rst:516
msgid "An environment marker after a semicolon. This means that the requirement is only needed in the specified conditions."
msgstr ""

#: ../source/specifications/core-metadata.rst:519
msgid "See :pep:`508` for full details of the allowed format."
msgstr ""

#: ../source/specifications/core-metadata.rst:521
msgid "The project names should correspond to names as found on the `Python Package Index`_."
msgstr ""

#: ../source/specifications/core-metadata.rst:524
msgid "Version specifiers must follow the rules described in :doc:`version-specifiers`."
msgstr ""

#: ../source/specifications/core-metadata.rst:538
msgid "Requires-Python"
msgstr ""

#: ../source/specifications/core-metadata.rst:542
msgid "This field specifies the Python version(s) that the distribution is guaranteed to be compatible with. Installation tools may look at this when picking which version of a project to install."
msgstr ""

#: ../source/specifications/core-metadata.rst:546
msgid "The value must be in the format specified in :doc:`version-specifiers`."
msgstr ""

#: ../source/specifications/core-metadata.rst:548
msgid "This field cannot be followed by an environment marker."
msgstr ""

#: ../source/specifications/core-metadata.rst:558
msgid "Requires-External (multiple use)"
msgstr ""

#: ../source/specifications/core-metadata.rst:565
msgid "Each entry contains a string describing some dependency in the system that the distribution is to be used.  This field is intended to serve as a hint to downstream project maintainers, and has no semantics which are meaningful to the ``distutils`` distribution."
msgstr ""

#: ../source/specifications/core-metadata.rst:570
msgid "The format of a requirement string is a name of an external dependency, optionally followed by a version declaration within parentheses."
msgstr ""

#: ../source/specifications/core-metadata.rst:576
msgid "Because they refer to non-Python software releases, version numbers for this field are **not** required to conform to the format specified in :pep:`440`:  they should correspond to the version scheme used by the external dependency."
msgstr ""

#: ../source/specifications/core-metadata.rst:581
msgid "Notice that there is no particular rule on the strings to be used."
msgstr ""

#: ../source/specifications/core-metadata.rst:593
msgid "Project-URL (multiple-use)"
msgstr ""

#: ../source/specifications/core-metadata.rst:597
msgid "A string containing a browsable URL for the project and a label for it, separated by a comma."
msgstr ""

#: ../source/specifications/core-metadata.rst:604
msgid "The label is free text limited to 32 characters."
msgstr ""

#: ../source/specifications/core-metadata.rst:612
msgid "Provides-Extra (multiple use)"
msgstr ""

#: ../source/specifications/core-metadata.rst:616
msgid "A string containing the name of an optional feature. Must be a valid Python identifier. May be used to make a dependency conditional on whether the optional feature has been requested."
msgstr ""

#: ../source/specifications/core-metadata.rst:625
msgid "A second distribution requires an optional dependency by placing it inside square brackets, and can request multiple features by separating them with a comma (,). The requirements are evaluated for each requested feature and added to the set of requirements for the distribution."
msgstr ""

#: ../source/specifications/core-metadata.rst:635
msgid "Two feature names ``test`` and ``doc`` are reserved to mark dependencies that are needed for running automated tests and generating documentation, respectively."
msgstr ""

#: ../source/specifications/core-metadata.rst:639
msgid "It is legal to specify ``Provides-Extra:`` without referencing it in any ``Requires-Dist:``."
msgstr ""

#: ../source/specifications/core-metadata.rst:644
msgid "Rarely Used Fields"
msgstr ""

#: ../source/specifications/core-metadata.rst:646
msgid "The fields in this section are currently rarely used, as their design was inspired by comparable mechanisms in Linux package management systems, and it isn't at all clear how tools should interpret them in the context of an open index server such as `PyPI <https://pypi.org>`__."
msgstr ""

#: ../source/specifications/core-metadata.rst:651
msgid "As a result, popular installation tools ignore them completely, which in turn means there is little incentive for package publishers to set them appropriately. However, they're retained in the metadata specification, as they're still potentially useful for informational purposes, and can also be used for their originally intended purpose in combination with a curated package repository."
msgstr ""

#: ../source/specifications/core-metadata.rst:660
msgid "Provides-Dist (multiple use)"
msgstr ""

#: ../source/specifications/core-metadata.rst:667
msgid "Each entry contains a string naming a Distutils project which is contained within this distribution.  This field *must* include the project identified in the ``Name`` field, followed by the version : Name (Version)."
msgstr ""

#: ../source/specifications/core-metadata.rst:672
msgid "A distribution may provide additional names, e.g. to indicate that multiple projects have been bundled together.  For instance, source distributions of the ``ZODB`` project have historically included the ``transaction`` project, which is now available as a separate distribution.  Installing such a source distribution satisfies requirements for both ``ZODB`` and ``transaction``."
msgstr ""

#: ../source/specifications/core-metadata.rst:679
msgid "A distribution may also provide a \"virtual\" project name, which does not correspond to any separately-distributed project:  such a name might be used to indicate an abstract capability which could be supplied by one of multiple projects.  E.g., multiple projects might supply RDBMS bindings for use by a given ORM:  each project might declare that it provides ``ORM-bindings``, allowing other projects to depend only on having at most one of them installed."
msgstr ""

#: ../source/specifications/core-metadata.rst:687
msgid "A version declaration may be supplied and must follow the rules described in :doc:`version-specifiers`. The distribution's version number will be implied if none is specified."
msgstr ""

#: ../source/specifications/core-metadata.rst:701
msgid "Obsoletes-Dist (multiple use)"
msgstr ""

#: ../source/specifications/core-metadata.rst:708
msgid "Each entry contains a string describing a distutils project's distribution which this distribution renders obsolete, meaning that the two projects should not be installed at the same time."
msgstr ""

#: ../source/specifications/core-metadata.rst:712
msgid "Version declarations can be supplied.  Version numbers must be in the format specified in :doc:`version-specifiers`."
msgstr ""

#: ../source/specifications/core-metadata.rst:717
msgid "The most common use of this field will be in case a project name changes, e.g. Gorgon 2.3 gets subsumed into Torqued Python 1.0. When you install Torqued Python, the Gorgon distribution should be removed."
msgstr ""

#: ../source/specifications/core-metadata.rst:730
msgid "reStructuredText markup: http://docutils.sourceforge.net/"
msgstr ""

#: ../source/specifications/core-metadata.rst:735
msgid "RFC 822 Long Header Fields: http://www.freesoft.org/CIE/RFC/822/7.htm"
msgstr ""

#: ../source/specifications/declaring-build-dependencies.rst:6
msgid "Declaring build system dependencies"
msgstr ""

#: ../source/specifications/declaring-build-dependencies.rst:8
msgid "`pyproject.toml` is a build system independent file format defined in :pep:`518` that projects may provide in order to declare any Python level dependencies that must be installed in order to run the project's build system successfully."
msgstr ""

#: ../source/specifications/declaring-project-metadata.rst:5
msgid "Declaring project metadata"
msgstr ""

#: ../source/specifications/declaring-project-metadata.rst:7
msgid ":pep:`621` specifies how to write a project's :ref:`core metadata <core-metadata>` in a ``pyproject.toml`` file for packaging-related tools to consume. It defines the following specification as the canonical source for the format used."
msgstr ""

#: ../source/specifications/declaring-project-metadata.rst:12
msgid "There are two kinds of metadata: *static* and *dynamic*. Static metadata is specified in the ``pyproject.toml`` file directly and cannot be specified or changed by a tool. Dynamic metadata is listed via the ``dynamic`` field (defined later in this specification) and represents metadata that a tool will later provide."
msgstr ""

#: ../source/specifications/declaring-project-metadata.rst:18
msgid "The fields defined in this specification MUST be in a table named ``[project]`` in ``pyproject.toml``. No tools may add fields to this table which are not defined by this specification. For tools wishing to store their own settings in ``pyproject.toml``, they may use the ``[tool]`` table as defined in the :ref:`build dependency declaration specification <declaring-build-dependencies>`. The lack of a ``[project]`` table implicitly means the build back-end will dynamically provide all fields."
msgstr ""

#: ../source/specifications/declaring-project-metadata.rst:27
msgid "The only fields required to be statically defined are:"
msgstr ""

#: ../source/specifications/declaring-project-metadata.rst:29
#: ../source/specifications/declaring-project-metadata.rst:41
msgid "``name``"
msgstr ""

#: ../source/specifications/declaring-project-metadata.rst:31
msgid "The fields which are required but may be specified *either* statically or listed as dynamic are:"
msgstr ""

#: ../source/specifications/declaring-project-metadata.rst:34
#: ../source/specifications/declaring-project-metadata.rst:54
msgid "``version``"
msgstr ""

#: ../source/specifications/declaring-project-metadata.rst:36
msgid "All other fields are considered optional and my be specified statically, listed as dynamic, or left unspecified."
msgstr ""

#: ../source/specifications/declaring-project-metadata.rst:43
#: ../source/specifications/declaring-project-metadata.rst:56
#: ../source/specifications/declaring-project-metadata.rst:68
#: ../source/specifications/declaring-project-metadata.rst:117
msgid "TOML_ type: string"
msgstr ""

#: ../source/specifications/declaring-project-metadata.rst:44
msgid "Corresponding :ref:`core metadata <core-metadata>` field: :ref:`Name <core-metadata-name>`"
msgstr ""

#: ../source/specifications/declaring-project-metadata.rst:47
msgid "The name of the project."
msgstr ""

#: ../source/specifications/declaring-project-metadata.rst:49
msgid "Tools SHOULD normalize this name, as specified by :pep:`503`, as soon as it is read for internal consistency."
msgstr ""

#: ../source/specifications/declaring-project-metadata.rst:57
msgid "Corresponding :ref:`core metadata <core-metadata>` field: :ref:`Version <core-metadata-version>`"
msgstr ""

#: ../source/specifications/declaring-project-metadata.rst:60
msgid "The version of the project as supported by :pep:`440`."
msgstr ""

#: ../source/specifications/declaring-project-metadata.rst:62
msgid "Users SHOULD prefer to specify already-normalized versions."
msgstr ""

#: ../source/specifications/declaring-project-metadata.rst:66
msgid "``description``"
msgstr ""

#: ../source/specifications/declaring-project-metadata.rst:69
msgid "Corresponding :ref:`core metadata <core-metadata>` field: :ref:`Summary <core-metadata-summary>`"
msgstr ""

#: ../source/specifications/declaring-project-metadata.rst:72
msgid "The summary description of the project."
msgstr ""

#: ../source/specifications/declaring-project-metadata.rst:76
msgid "``readme``"
msgstr ""

#: ../source/specifications/declaring-project-metadata.rst:78
msgid "TOML_ type: string or table"
msgstr ""

#: ../source/specifications/declaring-project-metadata.rst:79
msgid "Corresponding :ref:`core metadata <core-metadata>` field: :ref:`Description <core-metadata-description>` and :ref:`Description-Content-Type <core-metadata-description-content-type>`"
msgstr ""

#: ../source/specifications/declaring-project-metadata.rst:83
msgid "The full description of the project (i.e. the README)."
msgstr ""

#: ../source/specifications/declaring-project-metadata.rst:85
msgid "The field accepts either a string or a table. If it is a string then it is a path relative to ``pyproject.toml`` to a text file containing the full description. Tools MUST assume the file's encoding is UTF-8. If the file path ends in a case-insensitive ``.md`` suffix, then tools MUST assume the content-type is ``text/markdown``. If the file path ends in a case-insensitive ``.rst``, then tools MUST assume the content-type is ``text/x-rst``. If a tool recognizes more extensions than this PEP, they MAY infer the content-type for the user without specifying this field as ``dynamic``. For all unrecognized suffixes when a content-type is not provided, tools MUST raise an error."
msgstr ""

#: ../source/specifications/declaring-project-metadata.rst:96
msgid "The ``readme`` field may also take a table. The ``file`` key has a string value representing a path relative to ``pyproject.toml`` to a file containing the full description. The ``text`` key has a string value which is the full description. These keys are mutually-exclusive, thus tools MUST raise an error if the metadata specifies both keys."
msgstr ""

#: ../source/specifications/declaring-project-metadata.rst:103
msgid "A table specified in the ``readme`` field also has a ``content-type`` field which takes a string specifying the content-type of the full description. A tool MUST raise an error if the metadata does not specify this field in the table. If the metadata does not specify the ``charset`` parameter, then it is assumed to be UTF-8. Tools MAY support other encodings if they choose to. Tools MAY support alternative content-types which they can transform to a content-type as supported by the :ref:`core metadata <core-metadata>`. Otherwise tools MUST raise an error for unsupported content-types."
msgstr ""

#: ../source/specifications/declaring-project-metadata.rst:115
msgid "``requires-python``"
msgstr ""

#: ../source/specifications/declaring-project-metadata.rst:118
msgid "Corresponding :ref:`core metadata <core-metadata>` field: :ref:`Requires-Python <core-metadata-requires-python>`"
msgstr ""

#: ../source/specifications/declaring-project-metadata.rst:121
msgid "The Python version requirements of the project."
msgstr ""

#: ../source/specifications/declaring-project-metadata.rst:125
msgid "``license``"
msgstr ""

#: ../source/specifications/declaring-project-metadata.rst:127
msgid "TOML_ type: table"
msgstr ""

#: ../source/specifications/declaring-project-metadata.rst:128
msgid "Corresponding :ref:`core metadata <core-metadata>` field: :ref:`License <core-metadata-license>`"
msgstr ""

#: ../source/specifications/declaring-project-metadata.rst:131
msgid "The table may have one of two keys. The ``file`` key has a string value that is a file path relative to ``pyproject.toml`` to the file which contains the license for the project. Tools MUST assume the file's encoding is UTF-8. The ``text`` key has a string value which is the license of the project.  These keys are mutually exclusive, so a tool MUST raise an error if the metadata specifies both keys."
msgstr ""

#: ../source/specifications/declaring-project-metadata.rst:140
msgid "``authors``/``maintainers``"
msgstr ""

#: ../source/specifications/declaring-project-metadata.rst:142
msgid "TOML_ type: Array of inline tables with string keys and values"
msgstr ""

#: ../source/specifications/declaring-project-metadata.rst:143
msgid "Corresponding :ref:`core metadata <core-metadata>` field: :ref:`Author <core-metadata-author>`, :ref:`Author-email <core-metadata-author-email>`, :ref:`Maintainer <core-metadata-maintainer>`, and :ref:`Maintainer-email <core-metadata-maintainer-email>`"
msgstr ""

#: ../source/specifications/declaring-project-metadata.rst:149
msgid "The people or organizations considered to be the \"authors\" of the project. The exact meaning is open to interpretation — it may list the original or primary authors, current maintainers, or owners of the package."
msgstr ""

#: ../source/specifications/declaring-project-metadata.rst:154
msgid "The \"maintainers\" field is similar to \"authors\" in that its exact meaning is open to interpretation."
msgstr ""

#: ../source/specifications/declaring-project-metadata.rst:157
msgid "These fields accept an array of tables with 2 keys: ``name`` and ``email``. Both values must be strings. The ``name`` value MUST be a valid email name (i.e. whatever can be put as a name, before an email, in `RFC 822`_) and not contain commas. The ``email`` value MUST be a valid email address. Both keys are optional."
msgstr ""

#: ../source/specifications/declaring-project-metadata.rst:163
msgid "Using the data to fill in :ref:`core metadata <core-metadata>` is as follows:"
msgstr ""

#: ../source/specifications/declaring-project-metadata.rst:166
msgid "If only ``name`` is provided, the value goes in :ref:`Author <core-metadata-author>` or :ref:`Maintainer <core-metadata-maintainer>` as appropriate."
msgstr ""

#: ../source/specifications/declaring-project-metadata.rst:169
msgid "If only ``email`` is provided, the value goes in :ref:`Author-email <core-metadata-author-email>` or :ref:`Maintainer-email <core-metadata-maintainer-email>` as appropriate."
msgstr ""

#: ../source/specifications/declaring-project-metadata.rst:173
msgid "If both ``email`` and ``name`` are provided, the value goes in :ref:`Author-email <core-metadata-author-email>` or :ref:`Maintainer-email <core-metadata-maintainer-email>` as appropriate, with the format ``{name} <{email}>``."
msgstr ""

#: ../source/specifications/declaring-project-metadata.rst:177
msgid "Multiple values should be separated by commas."
msgstr ""

#: ../source/specifications/declaring-project-metadata.rst:181
msgid "``keywords``"
msgstr ""

#: ../source/specifications/declaring-project-metadata.rst:183
#: ../source/specifications/declaring-project-metadata.rst:193
msgid "TOML_ type: array of strings"
msgstr ""

#: ../source/specifications/declaring-project-metadata.rst:184
msgid "Corresponding :ref:`core metadata <core-metadata>` field: :ref:`Keywords <core-metadata-keywords>`"
msgstr ""

#: ../source/specifications/declaring-project-metadata.rst:187
msgid "The keywords for the project."
msgstr ""

#: ../source/specifications/declaring-project-metadata.rst:191
msgid "``classifiers``"
msgstr ""

#: ../source/specifications/declaring-project-metadata.rst:194
msgid "Corresponding :ref:`core metadata <core-metadata>` field: :ref:`Classifier <core-metadata-classifier>`"
msgstr ""

#: ../source/specifications/declaring-project-metadata.rst:197
msgid "Trove classifiers which apply to the project."
msgstr ""

#: ../source/specifications/declaring-project-metadata.rst:201
msgid "``urls``"
msgstr ""

#: ../source/specifications/declaring-project-metadata.rst:203
msgid "TOML_ type: table with keys and values of strings"
msgstr ""

#: ../source/specifications/declaring-project-metadata.rst:204
msgid "Corresponding :ref:`core metadata <core-metadata>` field: :ref:`Project-URL <core-metadata-project-url>`"
msgstr ""

#: ../source/specifications/declaring-project-metadata.rst:207
msgid "A table of URLs where the key is the URL label and the value is the URL itself."
msgstr ""

#: ../source/specifications/declaring-project-metadata.rst:212
msgid "Entry points"
msgstr ""

#: ../source/specifications/declaring-project-metadata.rst:214
msgid "TOML_ type: table (``[project.scripts]``, ``[project.gui-scripts]``, and ``[project.entry-points]``)"
msgstr ""

#: ../source/specifications/declaring-project-metadata.rst:216
msgid ":ref:`Entry points specification <entry-points>`"
msgstr ""

#: ../source/specifications/declaring-project-metadata.rst:218
msgid "There are three tables related to entry points. The ``[project.scripts]`` table corresponds to the ``console_scripts`` group in the :ref:`entry points specification <entry-points>`. The key of the table is the name of the entry point and the value is the object reference."
msgstr ""

#: ../source/specifications/declaring-project-metadata.rst:224
msgid "The ``[project.gui-scripts]`` table corresponds to the ``gui_scripts`` group in the :ref:`entry points specification <entry-points>`. Its format is the same as ``[project.scripts]``."
msgstr ""

#: ../source/specifications/declaring-project-metadata.rst:228
msgid "The ``[project.entry-points]`` table is a collection of tables. Each sub-table's name is an entry point group. The key and value semantics are the same as ``[project.scripts]``. Users MUST NOT create nested sub-tables but instead keep the entry point groups to only one level deep."
msgstr ""

#: ../source/specifications/declaring-project-metadata.rst:234
msgid "Build back-ends MUST raise an error if the metadata defines a ``[project.entry-points.console_scripts]`` or ``[project.entry-points.gui_scripts]`` table, as they would be ambiguous in the face of ``[project.scripts]`` and ``[project.gui-scripts]``, respectively."
msgstr ""

#: ../source/specifications/declaring-project-metadata.rst:242
msgid "``dependencies``/``optional-dependencies``"
msgstr ""

#: ../source/specifications/declaring-project-metadata.rst:244
msgid "TOML_ type: Array of :pep:`508` strings (``dependencies``), and a table with values of arrays of :pep:`508` strings (``optional-dependencies``)"
msgstr ""

#: ../source/specifications/declaring-project-metadata.rst:247
msgid "Corresponding :ref:`core metadata <core-metadata>` field: :ref:`Requires-Dist <core-metadata-requires-dist>` and :ref:`Provides-Extra <core-metadata-provides-extra>`"
msgstr ""

#: ../source/specifications/declaring-project-metadata.rst:251
msgid "The (optional) dependencies of the project."
msgstr ""

#: ../source/specifications/declaring-project-metadata.rst:253
msgid "For ``dependencies``, it is a key whose value is an array of strings. Each string represents a dependency of the project and MUST be formatted as a valid :pep:`508` string. Each string maps directly to a :ref:`Requires-Dist <core-metadata-requires-dist>` entry."
msgstr ""

#: ../source/specifications/declaring-project-metadata.rst:258
msgid "For ``optional-dependencies``, it is a table where each key specifies an extra and whose value is an array of strings. The strings of the arrays must be valid :pep:`508` strings. The keys MUST be valid values for :ref:`Provides-Extra <core-metadata-provides-extra>`. Each value in the array thus becomes a corresponding :ref:`Requires-Dist <core-metadata-requires-dist>` entry for the matching :ref:`Provides-Extra <core-metadata-provides-extra>` metadata."
msgstr ""

#: ../source/specifications/declaring-project-metadata.rst:269
msgid "``dynamic``"
msgstr ""

#: ../source/specifications/declaring-project-metadata.rst:271
msgid "TOML_ type: array of string"
msgstr ""

#: ../source/specifications/declaring-project-metadata.rst:272
msgid "A corresponding :ref:`core metadata <core-metadata>` field does not exist"
msgstr ""

#: ../source/specifications/declaring-project-metadata.rst:275
msgid "Specifies which fields listed by this PEP were intentionally unspecified so another tool can/will provide such metadata dynamically. This clearly delineates which metadata is purposefully unspecified and expected to stay unspecified compared to being provided via tooling later on."
msgstr ""

#: ../source/specifications/declaring-project-metadata.rst:281
msgid "A build back-end MUST honour statically-specified metadata (which means the metadata did not list the field in ``dynamic``)."
msgstr ""

#: ../source/specifications/declaring-project-metadata.rst:283
msgid "A build back-end MUST raise an error if the metadata specifies ``name`` in ``dynamic``."
msgstr ""

#: ../source/specifications/declaring-project-metadata.rst:285
msgid "If the :ref:`core metadata <core-metadata>` specification lists a field as \"Required\", then the metadata MUST specify the field statically or list it in ``dynamic`` (build back-ends MUST raise an error otherwise, i.e. it should not be possible for a required field to not be listed somehow in the ``[project]`` table)."
msgstr ""

#: ../source/specifications/declaring-project-metadata.rst:290
msgid "If the :ref:`core metadata <core-metadata>` specification lists a field as \"Optional\", the metadata MAY list it in ``dynamic`` if the expectation is a build back-end will provide the data for the field later."
msgstr ""

#: ../source/specifications/declaring-project-metadata.rst:294
msgid "Build back-ends MUST raise an error if the metadata specifies a field statically as well as being listed in ``dynamic``."
msgstr ""

#: ../source/specifications/declaring-project-metadata.rst:296
msgid "If the metadata does not list a field in ``dynamic``, then a build back-end CANNOT fill in the requisite metadata on behalf of the user (i.e. ``dynamic`` is the only way to allow a tool to fill in metadata and the user must opt into the filling in)."
msgstr ""

#: ../source/specifications/declaring-project-metadata.rst:300
msgid "Build back-ends MUST raise an error if the metadata specifies a field in ``dynamic`` but the build back-end was unable to determine the data for it (omitting the data, if determined to be the accurate value, is acceptable)."
msgstr ""

#: ../source/specifications/dependency-specifiers.rst:6
msgid "Dependency specifiers"
msgstr ""

#: ../source/specifications/dependency-specifiers.rst:8
msgid "The dependency specifier format used to declare a dependency on another component is defined in :pep:`508`."
msgstr ""

#: ../source/specifications/dependency-specifiers.rst:11
msgid "The environment markers section in this PEP supersedes the environment markers section in :pep:`345`."
msgstr ""

#: ../source/specifications/direct-url.rst:6
msgid "Recording the Direct URL Origin of installed distributions"
msgstr ""

#: ../source/specifications/direct-url.rst:8
msgid "This document specifies a :file:`direct_url.json` file in the :file:`*.dist-info` directory of an installed distribution, to record the Direct URL Origin of the distribution. The layout of this file was originally specified in :pep:`610` and is formally documented here."
msgstr ""

#: ../source/specifications/direct-url.rst:17
msgid "Specification"
msgstr ""

#: ../source/specifications/direct-url.rst:19
msgid "The :file:`direct_url.json` file MUST be created in the :file:`*.dist-info` directory by installers when installing a distribution from a requirement specifying a direct URL reference (including a VCS URL)."
msgstr ""

#: ../source/specifications/direct-url.rst:23
#: ../source/specifications/recording-installed-packages.rst:206
msgid "This file MUST NOT be created when installing a distribution from an other type of requirement (i.e. name plus version specifier)."
msgstr ""

#: ../source/specifications/direct-url.rst:26
msgid "This JSON file MUST be a dictionary, compliant with `RFC 8259 <https://tools.ietf.org/html/rfc8259>`_ and UTF-8 encoded."
msgstr ""

#: ../source/specifications/direct-url.rst:29
msgid "If present, it MUST contain at least two fields. The first one is ``url``, with type ``string``. Depending on what ``url`` refers to, the second field MUST be one of ``vcs_info`` (if ``url`` is a VCS reference), ``archive_info`` (if ``url`` is a source archives or a wheel), or ``dir_info`` (if ``url``  is a local directory). These info fields have a (possibly empty) subdictionary as value, with the possible keys defined below."
msgstr ""

#: ../source/specifications/direct-url.rst:36
msgid "``url`` MUST be stripped of any sensitive authentication information, for security reasons."
msgstr ""

#: ../source/specifications/direct-url.rst:39
msgid "The user:password section of the URL MAY however be composed of environment variables, matching the following regular expression::"
msgstr ""

#: ../source/specifications/direct-url.rst:45
msgid "Additionally, the user:password section of the URL MAY be a well-known, non security sensitive string. A typical example is ``git`` in the case of an URL such as ``ssh://git@gitlab.com/user/repo``."
msgstr ""

#: ../source/specifications/direct-url.rst:49
msgid "When ``url`` refers to a VCS repository, the ``vcs_info`` key MUST be present as a dictionary with the following keys:"
msgstr ""

#: ../source/specifications/direct-url.rst:52
msgid "A ``vcs`` key (type ``string``) MUST be present, containing the name of the VCS (i.e. one of ``git``, ``hg``, ``bzr``, ``svn``). Other VCS's SHOULD be registered by writing a PEP to amend this specification. The ``url`` value MUST be compatible with the corresponding VCS, so an installer can hand it off without transformation to a checkout/download command of the VCS."
msgstr ""

#: ../source/specifications/direct-url.rst:58
msgid "A ``requested_revision`` key (type ``string``) MAY be present naming a branch/tag/ref/commit/revision/etc (in a format compatible with the VCS) to install."
msgstr ""

#: ../source/specifications/direct-url.rst:61
msgid "A ``commit_id`` key (type ``string``) MUST be present, containing the exact commit/revision number that was installed. If the VCS supports commit-hash based revision identifiers, such commit-hash MUST be used as ``commit_id`` in order to reference the immutable version of the source code that was installed."
msgstr ""

#: ../source/specifications/direct-url.rst:68
msgid "When ``url`` refers to a source archive or a wheel, the ``archive_info`` key MUST be present as a dictionary with the following key:"
msgstr ""

#: ../source/specifications/direct-url.rst:71
msgid "A ``hash`` key (type ``string``) SHOULD be present, with value ``<hash-algorithm>=<expected-hash>``. It is RECOMMENDED that only hashes which are unconditionally provided by the latest version of the standard library's ``hashlib`` module be used for source archive hashes. At time of writing, that list consists of 'md5', 'sha1', 'sha224', 'sha256', 'sha384', and 'sha512'."
msgstr ""

#: ../source/specifications/direct-url.rst:78
msgid "When ``url`` refers to a local directory, the ``dir_info`` key MUST be present as a dictionary with the following key:"
msgstr ""

#: ../source/specifications/direct-url.rst:81
msgid "``editable`` (type: ``boolean``): ``true`` if the distribution was installed in editable mode, ``false`` otherwise. If absent, default to ``false``."
msgstr ""

#: ../source/specifications/direct-url.rst:84
msgid "When ``url`` refers to a local directory, it MUST have the ``file`` sheme and be compliant with `RFC 8089 <https://tools.ietf.org/html/rfc8089>`_. In particular, the path component must be absolute. Symbolic links SHOULD be preserved when making relative paths absolute."
msgstr ""

#: ../source/specifications/direct-url.rst:91
msgid "When the requested URL has the file:// scheme and points to a local directory that happens to contain a VCS checkout, installers MUST NOT attempt to infer any VCS information and therefore MUST NOT output any VCS related information (such as ``vcs_info``) in :file:`direct_url.json`."
msgstr ""

#: ../source/specifications/direct-url.rst:96
msgid "A top-level ``subdirectory`` field MAY be present containing a directory path, relative to the root of the VCS repository, source archive or local directory, to specify where ``pyproject.toml`` or ``setup.py`` is located."
msgstr ""

#: ../source/specifications/direct-url.rst:102
msgid "As a general rule, installers should as much as possible preserve the information that was provided in the requested URL when generating :file:`direct_url.json`. For example user:password environment variables should be preserved and ``requested_revision`` should reflect the revision that was provided in the requested URL as faithfully as possible. This information is however *enriched* with more precise data, such as ``commit_id``."
msgstr ""

#: ../source/specifications/direct-url.rst:110
msgid "Registered VCS"
msgstr ""

#: ../source/specifications/direct-url.rst:112
msgid "This section lists the registered VCS's; expanded, VCS-specific information on how to use the ``vcs``, ``requested_revision``, and other fields of ``vcs_info``; and in some cases additional VCS-specific fields. Tools MAY support other VCS's although it is RECOMMENDED to register them by writing a PEP to amend this specification. The ``vcs`` field SHOULD be the command name (lowercased). Additional fields that would be necessary to support such VCS SHOULD be prefixed with the VCS command name."
msgstr ""

#: ../source/specifications/direct-url.rst:122
msgid "Git"
msgstr ""

#: ../source/specifications/direct-url.rst:124
#: ../source/specifications/direct-url.rst:156
#: ../source/specifications/direct-url.rst:179
#: ../source/specifications/direct-url.rst:202
msgid "Home page"
msgstr ""

#: ../source/specifications/direct-url.rst:126
msgid "https://git-scm.com/"
msgstr ""

#: ../source/specifications/direct-url.rst:128
#: ../source/specifications/direct-url.rst:160
#: ../source/specifications/direct-url.rst:183
#: ../source/specifications/direct-url.rst:206
msgid "vcs command"
msgstr ""

#: ../source/specifications/direct-url.rst:130
#: ../source/specifications/direct-url.rst:134
msgid "git"
msgstr ""

#: ../source/specifications/direct-url.rst:132
#: ../source/specifications/direct-url.rst:164
#: ../source/specifications/direct-url.rst:187
#: ../source/specifications/direct-url.rst:210
msgid "``vcs`` field"
msgstr ""

#: ../source/specifications/direct-url.rst:136
#: ../source/specifications/direct-url.rst:168
#: ../source/specifications/direct-url.rst:191
#: ../source/specifications/direct-url.rst:214
msgid "``requested_revision`` field"
msgstr ""

#: ../source/specifications/direct-url.rst:138
msgid "A tag name, branch name, Git ref, commit hash, shortened commit hash, or other commit-ish."
msgstr ""

#: ../source/specifications/direct-url.rst:141
#: ../source/specifications/direct-url.rst:172
#: ../source/specifications/direct-url.rst:195
#: ../source/specifications/direct-url.rst:219
msgid "``commit_id`` field"
msgstr ""

#: ../source/specifications/direct-url.rst:143
msgid "A commit hash (40 hexadecimal characters sha1)."
msgstr ""

#: ../source/specifications/direct-url.rst:147
msgid "Installers can use the ``git show-ref`` and ``git symbolic-ref`` commands to determine if the ``requested_revision`` corresponds to a Git ref. In turn, a ref beginning with ``refs/tags/`` corresponds to a tag, and a ref beginning with ``refs/remotes/origin/`` after cloning corresponds to a branch."
msgstr ""

#: ../source/specifications/direct-url.rst:154
msgid "Mercurial"
msgstr ""

#: ../source/specifications/direct-url.rst:158
msgid "https://www.mercurial-scm.org/"
msgstr ""

#: ../source/specifications/direct-url.rst:162
#: ../source/specifications/direct-url.rst:166
msgid "hg"
msgstr ""

#: ../source/specifications/direct-url.rst:170
msgid "A tag name, branch name, changeset ID, shortened changeset ID."
msgstr ""

#: ../source/specifications/direct-url.rst:174
msgid "A changeset ID (40 hexadecimal characters)."
msgstr ""

#: ../source/specifications/direct-url.rst:177
msgid "Bazaar"
msgstr ""

#: ../source/specifications/direct-url.rst:181
msgid "https://bazaar.canonical.com/"
msgstr ""

#: ../source/specifications/direct-url.rst:185
#: ../source/specifications/direct-url.rst:189
msgid "bzr"
msgstr ""

#: ../source/specifications/direct-url.rst:193
msgid "A tag name, branch name, revision id."
msgstr ""

#: ../source/specifications/direct-url.rst:197
msgid "A revision id."
msgstr ""

#: ../source/specifications/direct-url.rst:200
msgid "Subversion"
msgstr ""

#: ../source/specifications/direct-url.rst:204
msgid "https://subversion.apache.org/"
msgstr ""

#: ../source/specifications/direct-url.rst:208
#: ../source/specifications/direct-url.rst:212
msgid "svn"
msgstr ""

#: ../source/specifications/direct-url.rst:216
msgid "``requested_revision`` must be compatible with ``svn checkout`` ``--revision`` option. In Subversion, branch or tag is part of ``url``."
msgstr ""

#: ../source/specifications/direct-url.rst:221
msgid "Since Subversion does not support globally unique identifiers, this field is the Subversion revision number in the corresponding repository."
msgstr ""

#: ../source/specifications/direct-url.rst:229
msgid "Example direct_url.json"
msgstr ""

#: ../source/specifications/direct-url.rst:231
msgid "Source archive:"
msgstr ""

#: ../source/specifications/direct-url.rst:242
msgid "Git URL with tag and commit-hash:"
msgstr ""

#: ../source/specifications/direct-url.rst:255
msgid "Local directory:"
msgstr ""

#: ../source/specifications/direct-url.rst:264
msgid "Local directory installed in editable mode:"
msgstr ""

#: ../source/specifications/direct-url.rst:277
msgid "Example pip commands and their effect on direct_url.json"
msgstr ""

#: ../source/specifications/direct-url.rst:279
msgid "Commands that generate a ``direct_url.json``:"
msgstr ""

#: ../source/specifications/direct-url.rst:281
msgid "pip install https://example.com/app-1.0.tgz"
msgstr ""

#: ../source/specifications/direct-url.rst:282
msgid "pip install https://example.com/app-1.0.whl"
msgstr ""

#: ../source/specifications/direct-url.rst:283
msgid "pip install \"git+https://example.com/repo/app.git#egg=app&subdirectory=setup\""
msgstr ""

#: ../source/specifications/direct-url.rst:284
msgid "pip install ./app"
msgstr ""

#: ../source/specifications/direct-url.rst:285
msgid "pip install file:///home/user/app"
msgstr ""

#: ../source/specifications/direct-url.rst:286
msgid "pip install --editable \"git+https://example.com/repo/app.git#egg=app&subdirectory=setup\" (in which case, ``url`` will be the local directory where the git repository has been cloned to, and ``dir_info`` will be present with ``\"editable\": true`` and no ``vcs_info`` will be set)"
msgstr ""

#: ../source/specifications/direct-url.rst:290
msgid "pip install -e ./app"
msgstr ""

#: ../source/specifications/direct-url.rst:292
msgid "Commands that *do not* generate a ``direct_url.json``"
msgstr ""

#: ../source/specifications/direct-url.rst:294
msgid "pip install app"
msgstr ""

#: ../source/specifications/direct-url.rst:295
msgid "pip install app --no-index --find-links https://example.com/"
msgstr ""

#: ../source/specifications/entry-points.rst:5
msgid "Entry points specification"
msgstr ""

#: ../source/specifications/entry-points.rst:7
msgid "*Entry points* are a mechanism for an installed distribution to advertise components it provides to be discovered and used by other code. For example:"
msgstr ""

#: ../source/specifications/entry-points.rst:11
msgid "Distributions can specify ``console_scripts`` entry points, each referring to a function. When *pip* (or another console_scripts aware installer) installs the distribution, it will create a command-line wrapper for each entry point."
msgstr ""

#: ../source/specifications/entry-points.rst:14
msgid "Applications can use entry points to load plugins; e.g. Pygments (a syntax highlighting tool) can use additional lexers and styles from separately installed packages. For more about this, see :doc:`/guides/creating-and-discovering-plugins`."
msgstr ""

#: ../source/specifications/entry-points.rst:19
msgid "The entry point file format was originally developed to allow packages built with setuptools to provide integration point metadata that would be read at runtime with ``importlib.metadata``. It is now defined as a PyPA interoperability specification in order to allow build tools other than setuptools to publish ``importlib.metadata`` compatible entry point metadata, and runtime libraries other than ``importlib.metadata`` to portably read published entry point metadata (potentially with different caching and conflict resolution strategies)."
msgstr ""

#: ../source/specifications/entry-points.rst:28
msgid "Data model"
msgstr ""

#: ../source/specifications/entry-points.rst:30
msgid "Conceptually, an entry point is defined by three required properties:"
msgstr ""

#: ../source/specifications/entry-points.rst:32
msgid "The **group** that an entry point belongs to indicates what sort of object it provides. For instance, the group ``console_scripts`` is for entry points referring to functions which can be used as a command, while ``pygments.styles`` is the group for classes defining pygments styles. The consumer typically defines the expected interface. To avoid clashes, consumers defining a new group should use names starting with a PyPI name owned by the consumer project, followed by ``.``. Group names must be one or more groups of letters, numbers and underscores, separated by dots (regex ``^\\w+(\\.\\w+)*$``)."
msgstr ""

#: ../source/specifications/entry-points.rst:42
msgid "The **name** identifies this entry point within its group. The precise meaning of this is up to the consumer. For console scripts, the name of the entry point is the command that will be used to launch it. Within a distribution, entry point names should be unique. If different distributions provide the same name, the consumer decides how to handle such conflicts. The name may contain any characters except ``=``, but it cannot start or end with any whitespace character, or start with ``[``. For new entry points, it is recommended to use only letters, numbers, underscores, dots and dashes (regex ``[\\w.-]+``)."
msgstr ""

#: ../source/specifications/entry-points.rst:51
msgid "The **object reference** points to a Python object. It is either in the form ``importable.module``, or ``importable.module:object.attr``. Each of the parts delimited by dots and the colon is a valid Python identifier. It is intended to be looked up like this::"
msgstr ""

#: ../source/specifications/entry-points.rst:64
msgid "Some tools call this kind of object reference by itself an 'entry point', for want of a better term, especially where it points to a function to launch a program."
msgstr ""

#: ../source/specifications/entry-points.rst:68
msgid "There is also an optional property: the **extras** are a set of strings identifying optional features of the distribution providing the entry point. If these are specified, the entry point requires the dependencies of those 'extras'. See the metadata field :ref:`metadata_provides_extra`."
msgstr ""

#: ../source/specifications/entry-points.rst:73
msgid "Using extras for an entry point is no longer recommended. Consumers should support parsing them from existing distributions, but may then ignore them. New publishing tools need not support specifying extras. The functionality of handling extras was tied to setuptools' model of managing 'egg' packages, but newer tools such as pip and virtualenv use a different model."
msgstr ""

#: ../source/specifications/entry-points.rst:80
msgid "File format"
msgstr ""

#: ../source/specifications/entry-points.rst:82
msgid "Entry points are defined in a file called :file:`entry_points.txt` in the :file:`*.dist-info` directory of the distribution. This is the directory described in :pep:`376` for installed distributions, and in :pep:`427` for wheels.  The file uses the UTF-8 character encoding."
msgstr ""

#: ../source/specifications/entry-points.rst:87
msgid "The file contents are in INI format, as read by Python's :mod:`configparser` module. However, configparser treats names as case-insensitive by default, whereas entry point names are case sensitive. A case-sensitive config parser can be made like this::"
msgstr ""

#: ../source/specifications/entry-points.rst:97
msgid "The entry points file must always use ``=`` to delimit names from values (whereas configparser also allows using ``:``)."
msgstr ""

#: ../source/specifications/entry-points.rst:100
msgid "The sections of the config file represent entry point groups, the names are names, and the values encode both the object reference and the optional extras. If extras are used, they are a comma-separated list inside square brackets."
msgstr ""

#: ../source/specifications/entry-points.rst:104
msgid "Within a value, readers must accept and ignore spaces (including multiple consecutive spaces) before or after the colon, between the object reference and the left square bracket, between the extra names and the square brackets and colons delimiting them, and after the right square bracket. The syntax for extras is formally specified as part of :pep:`508` (as ``extras``). For tools writing the file, it is recommended only to insert a space between the object reference and the left square bracket."
msgstr ""

#: ../source/specifications/entry-points.rst:112
msgid "For example::"
msgstr ""

#: ../source/specifications/entry-points.rst:124
msgid "Use for scripts"
msgstr ""

#: ../source/specifications/entry-points.rst:126
msgid "Two groups of entry points have special significance in packaging: ``console_scripts`` and ``gui_scripts``. In both groups, the name of the entry point should be usable as a command in a system shell after the package is installed. The object reference points to a function which will be called with no arguments when this command is run. The function may return an integer to be used as a process exit code, and returning ``None`` is equivalent to returning ``0``."
msgstr ""

#: ../source/specifications/entry-points.rst:134
msgid "For instance, the entry point ``mycmd = mymod:main`` would create a command ``mycmd`` launching a script like this::"
msgstr ""

#: ../source/specifications/entry-points.rst:141
msgid "The difference between ``console_scripts`` and ``gui_scripts`` only affects Windows systems. ``console_scripts`` are wrapped in a console executable, so they are attached to a console and can use ``sys.stdin``, ``sys.stdout`` and ``sys.stderr`` for input and output. ``gui_scripts`` are wrapped in a GUI executable, so they can be started without a console, but cannot use standard streams unless application code redirects them. Other platforms do not have the same distinction."
msgstr ""

#: ../source/specifications/entry-points.rst:149
msgid "Install tools are expected to set up wrappers for both ``console_scripts`` and ``gui_scripts`` in the scripts directory of the install scheme. They are not responsible for putting this directory in the ``PATH`` environment variable which defines where command-line tools are found."
msgstr ""

#: ../source/specifications/entry-points.rst:154
msgid "As files are created from the names, and some filesystems are case-insensitive, packages should avoid using names in these groups which differ only in case. The behaviour of install tools when names differ only in case is undefined."
msgstr ""

#: ../source/specifications/index.rst:4
msgid "PyPA specifications"
msgstr ""

#: ../source/specifications/index.rst:6
msgid "This is a list of currently active interoperability specifications maintained by the Python Packaging Authority. The process for updating these standards, and for proposing new ones, is documented on `pypa.io <https://www.pypa.io/en/latest/specifications/>`__."
msgstr ""

#: ../source/specifications/index.rst:13
msgid "Package Distribution Metadata"
msgstr ""

#: ../source/specifications/index.rst:30
msgid "Package Distribution File Formats"
msgstr ""

#: ../source/specifications/index.rst:40
msgid "Package Index Interfaces"
msgstr ""

#: ../source/specifications/platform-compatibility-tags.rst:6
msgid "Platform compatibility tags"
msgstr ""

#: ../source/specifications/platform-compatibility-tags.rst:8
msgid "Platform compatibility tags allow build tools to mark distributions as being compatible with specific platforms, and allows installers to understand which distributions are compatible with the system they are running on."
msgstr ""

#: ../source/specifications/platform-compatibility-tags.rst:12
msgid "The platform compatibility tagging model used for the ``wheel`` distribution format is defined in :pep:`425`."
msgstr ""

#: ../source/specifications/platform-compatibility-tags.rst:16
msgid "Platform tags for Windows"
msgstr ""

#: ../source/specifications/platform-compatibility-tags.rst:18
msgid "The scheme defined in :pep:`425` covers public distribution of wheel files to systems running Windows."
msgstr ""

#: ../source/specifications/platform-compatibility-tags.rst:22
msgid "Platform tags for macOS (Mac OS X)"
msgstr ""

#: ../source/specifications/platform-compatibility-tags.rst:24
msgid "The scheme defined in :pep:`425` covers public distribution of wheel files to systems running macOS (previously known as Mac OS X)."
msgstr ""

#: ../source/specifications/platform-compatibility-tags.rst:28
msgid "Platform tags for common Linux distributions"
msgstr ""

#: ../source/specifications/platform-compatibility-tags.rst:32
msgid "The scheme defined in :pep:`425` is insufficient for public distribution of wheel files (and \\*nix wheel files in general) to Linux platforms, due to the large ecosystem of Linux platforms and subtle differences between them."
msgstr ""

#: ../source/specifications/platform-compatibility-tags.rst:36
msgid "Instead, :pep:`600` defines the ``manylinux`` standard, which represents a common subset of Linux platforms, and allows building wheels tagged with the ``manylinux`` platform tag which can be used across most common Linux distributions."
msgstr ""

#: ../source/specifications/platform-compatibility-tags.rst:41
msgid "There were multiple iterations of the ``manylinux`` specification, each representing the common subset of Linux platforms at a given point in time:"
msgstr ""

#: ../source/specifications/platform-compatibility-tags.rst:44
msgid "``manylinux1`` (:pep:`513`) supports ``x86_64`` and ``i686`` architectures, and is based on a compatible Linux platform from 2007."
msgstr ""

#: ../source/specifications/platform-compatibility-tags.rst:46
msgid "``manylinux2010`` (:pep:`571`) supports ``x86_64`` and ``i686`` architectures. and updates the previous specification to be based on a compatible Linux platform from 2010 instead."
msgstr ""

#: ../source/specifications/platform-compatibility-tags.rst:49
msgid "``manylinux2014`` (:pep:`599`) adds support for a number of additional architectures (``aarch64``, ``armv7l``, ``ppc64``, ``ppc64le``, and ``s390x``) and updates the base platform to a compatible Linux platform from 2014."
msgstr ""

#: ../source/specifications/platform-compatibility-tags.rst:54
msgid "``manylinux_x_y`` (:pep:`600`) supersedes all previous PEPs to define a future-proof standard. It defines ``x`` and ``y`` as glibc major an minor versions supported (e.g. ``manylinux_2_24`` should work on any distro using glibc 2.24+). Previous tags are still supported for backward compatibility."
msgstr ""

#: ../source/specifications/platform-compatibility-tags.rst:59
msgid "In general, distributions built for older versions of the specification are forwards-compatible (meaning that ``manylinux1`` distributions should continue to work on modern systems) but not backwards-compatible (meaning that ``manylinux2010`` distributions are not expected to work on platforms that existed before 2010)."
msgstr ""

#: ../source/specifications/platform-compatibility-tags.rst:65
msgid "Package maintainers should attempt to target the most compatible specification possible, with the caveat that the provided build environment for ``manylinux1`` and ``manylinux2010`` have reached end-of-life meaning that these images will no longer receive security updates."
msgstr ""

#: ../source/specifications/platform-compatibility-tags.rst:71
msgid "Manylinux compatibility support"
msgstr ""

#: ../source/specifications/platform-compatibility-tags.rst:74
msgid "The ``manylinux2014`` specification is relatively new and is not yet widely recognised by install tools."
msgstr ""

#: ../source/specifications/platform-compatibility-tags.rst:76
msgid "The ``manylinux_x_y`` specification is relatively new and is not yet widely recognised by install tools."
msgstr ""

#: ../source/specifications/platform-compatibility-tags.rst:79
msgid "The following table shows the minimum versions of relevant projects to support the various ``manylinux`` standards:"
msgstr ""

#: ../source/specifications/platform-compatibility-tags.rst:83
msgid "Tool"
msgstr ""

#: ../source/specifications/platform-compatibility-tags.rst:83
msgid "``manylinux1``"
msgstr ""

#: ../source/specifications/platform-compatibility-tags.rst:83
msgid "``manylinux2010``"
msgstr ""

#: ../source/specifications/platform-compatibility-tags.rst:83
msgid "``manylinux2014``"
msgstr ""

#: ../source/specifications/platform-compatibility-tags.rst:83
msgid "``manylinux_x_y``"
msgstr ""

#: ../source/specifications/platform-compatibility-tags.rst:85
msgid "``>=8.1.0``"
msgstr ""

#: ../source/specifications/platform-compatibility-tags.rst:85
msgid "``>=19.0``"
msgstr ""

#: ../source/specifications/platform-compatibility-tags.rst:85
msgid "``>=19.3``"
msgstr ""

#: ../source/specifications/platform-compatibility-tags.rst:85
msgid "``>=20.3``"
msgstr ""

#: ../source/specifications/platform-compatibility-tags.rst:86
msgid "auditwheel"
msgstr ""

#: ../source/specifications/platform-compatibility-tags.rst:86
msgid "``>=1.0.0``"
msgstr ""

#: ../source/specifications/platform-compatibility-tags.rst:86
msgid "``>=2.0.0``"
msgstr ""

#: ../source/specifications/platform-compatibility-tags.rst:86
msgid "``>=3.0.0``"
msgstr ""

#: ../source/specifications/platform-compatibility-tags.rst:86
msgid "``>=3.3.0`` [#]_"
msgstr ""

#: ../source/specifications/platform-compatibility-tags.rst:90
msgid "Platform tags for other \\*nix platforms"
msgstr ""

#: ../source/specifications/platform-compatibility-tags.rst:92
msgid "The scheme defined in :pep:`425` is not generally sufficient for public distribution of wheel files to other \\*nix platforms. Efforts are currently (albeit intermittently) under way to define improved compatibility tagging schemes for AIX and for Alpine Linux."
msgstr ""

#: ../source/specifications/platform-compatibility-tags.rst:98
msgid "Only support for ``manylinux_2_24`` has been added in auditwheel 3.3.0"
msgstr ""

#: ../source/specifications/pypirc.rst:6
msgid "The :file:`.pypirc` file"
msgstr ""

#: ../source/specifications/pypirc.rst:8
msgid "A :file:`.pypirc` file allows you to define the configuration for :term:`package indexes <Package Index>` (referred to here as \"repositories\"), so that you don't have to enter the URL, username, or password whenever you upload a package with :ref:`twine` or :ref:`flit`."
msgstr ""

#: ../source/specifications/pypirc.rst:13
msgid "The format (originally defined by the :ref:`distutils` package) is:"
msgstr ""

#: ../source/specifications/pypirc.rst:32
msgid "The ``distutils`` section defines an ``index-servers`` field that lists the name of all sections describing a repository."
msgstr ""

#: ../source/specifications/pypirc.rst:35
msgid "Each section describing a repository defines three fields:"
msgstr ""

#: ../source/specifications/pypirc.rst:37
msgid "``repository``: The URL of the repository."
msgstr ""

#: ../source/specifications/pypirc.rst:38
msgid "``username``: The registered username on the repository."
msgstr ""

#: ../source/specifications/pypirc.rst:39
msgid "``password``: The password that will used to authenticate the username."
msgstr ""

#: ../source/specifications/pypirc.rst:43
msgid "Be aware that this stores your password in plain text. For better security, consider an alternative like `keyring`_, setting environment variables, or providing the password on the command line."
msgstr ""

#: ../source/specifications/pypirc.rst:47
msgid "Otherwise, set the permissions on :file:`.pypirc` so that only you can view or modify it. For example, on Linux or macOS, run:"
msgstr ""

#: ../source/specifications/pypirc.rst:57
msgid "Common configurations"
msgstr ""

#: ../source/specifications/pypirc.rst:61
msgid "These examples apply to :ref:`twine`, and projects like :ref:`hatch` that use it under the hood. Other projects (e.g. :ref:`flit`) also use :file:`.pypirc`, but with different defaults. Please refer to each project's documentation for more details and usage instructions."
msgstr ""

#: ../source/specifications/pypirc.rst:66
msgid "Twine's default configuration mimics a :file:`.pypirc` with repository sections for PyPI and TestPyPI:"
msgstr ""

#: ../source/specifications/pypirc.rst:82
msgid "Twine will add additional configuration from :file:`$HOME/.pypirc`, the command line, and environment variables to this default configuration."
msgstr ""

#: ../source/specifications/pypirc.rst:86
msgid "Using a PyPI token"
msgstr ""

#: ../source/specifications/pypirc.rst:88
msgid "To set your `API token`_ for PyPI, you can create a :file:`$HOME/.pypirc` similar to:"
msgstr ""

#: ../source/specifications/pypirc.rst:97
msgid "For :ref:`TestPyPI <using-test-pypi>`, add a ``[testpypi]`` section, using the API token from your TestPyPI account."
msgstr ""

#: ../source/specifications/pypirc.rst:103
msgid "Using another package index"
msgstr ""

#: ../source/specifications/pypirc.rst:105
msgid "To configure an additional repository, you'll need to redefine the ``index-servers`` field to include the repository name. Here is a complete example of a :file:`$HOME/.pypirc` for PyPI, TestPyPI, and a private repository:"
msgstr ""

#: ../source/specifications/pypirc.rst:132
msgid "Instead of using the ``password`` field, consider saving your API tokens and passwords securely using `keyring`_ (which is installed by Twine):"
msgstr ""

#: ../source/specifications/recording-installed-packages.rst:5
msgid "Recording installed projects"
msgstr ""

#: ../source/specifications/recording-installed-packages.rst:7
msgid "This document specifies a common format of recording information about Python :term:`projects <Project>` installed in an environment. A common metadata format allows tools to query, manage or uninstall projects, regardless of how they were installed."
msgstr ""

#: ../source/specifications/recording-installed-packages.rst:12
msgid "Almost all information is optional. This allows tools outside the Python ecosystem, such as Linux package managers, to integrate with Python tooling as much as possible. For example, even if an installer cannot easily provide a list of installed files in a format specific to Python tooling, it should still record the name and version of the installed project."
msgstr ""

#: ../source/specifications/recording-installed-packages.rst:21
msgid "History and change workflow"
msgstr ""

#: ../source/specifications/recording-installed-packages.rst:23
msgid "The metadata described here was first specified in :pep:`376`, and later amended in :pep:`627`. It was formerly known as *Database of Installed Python Distributions*. Further amendments (except trivial language or typography fixes) must be made through the PEP process (see :pep:`1`)."
msgstr ""

#: ../source/specifications/recording-installed-packages.rst:29
msgid "While this document is the normative specification, these PEPs that introduce changes to it may include additional information such as rationales and backwards compatibility considerations."
msgstr ""

#: ../source/specifications/recording-installed-packages.rst:37
msgid "Each project installed from a distribution must, in addition to files, install a \"``.dist-info``\" directory located alongside importable modules and packages (commonly, the ``site-packages`` directory)."
msgstr ""

#: ../source/specifications/recording-installed-packages.rst:41
msgid "This directory is named as ``{name}-{version}.dist-info``, with ``name`` and ``version`` fields corresponding to :ref:`core-metadata`. Both fields must be normalized (see :pep:`PEP 503 <503#normalized-names>` and :pep:`PEP 440 <440#normalization>` for the definition of normalization for each field respectively), and replace dash (``-``) characters with underscore (``_``) chacaters, so the ``.dist-info`` directory always has exactly one dash (``-``) character in its stem, separating the ``name`` and ``version`` fields."
msgstr ""

#: ../source/specifications/recording-installed-packages.rst:50
msgid "Historically, tools have failed to replace dot characters or normalize case in the ``name`` field, or not perform normalization in the ``version`` field. Tools consuming ``.dist-info`` directories should expect those fields to be unnormalized, and treat them as equivalent to their normalized counterparts. New tools that write ``.dist-info`` directories MUST normalize both ``name`` and ``version`` fields using the rules described above, and existing tools are encouraged to start normalizing those fields."
msgstr ""

#: ../source/specifications/recording-installed-packages.rst:60
msgid "The ``.dist-info`` directory's name is formatted to unambigiously represent a distribution as a filesystem path. Tools presenting a distribution name to a user should avoid using the normalized name, and instead present the specified name (when needed prior to resolution to an installed package), or read the respective fields in Core Metadata, since values listed there are unescaped and accurately reflect the distribution. Libraries should provide API for such tools to consume, so tools can have access to the unnormalized name when displaying distrubution information."
msgstr ""

#: ../source/specifications/recording-installed-packages.rst:69
msgid "This ``.dist-info`` directory can contain these files, described in detail below:"
msgstr ""

#: ../source/specifications/recording-installed-packages.rst:72
msgid "``METADATA``: contains project metadata"
msgstr ""

#: ../source/specifications/recording-installed-packages.rst:73
msgid "``RECORD``: records the list of installed files."
msgstr ""

#: ../source/specifications/recording-installed-packages.rst:74
msgid "``INSTALLER``: records the name of the tool used to install the project."
msgstr ""

#: ../source/specifications/recording-installed-packages.rst:76
msgid "The ``METADATA`` file is mandatory. All other files may be omitted at the installing tool's discretion. Additional installer-specific files may be present."
msgstr ""

#: ../source/specifications/recording-installed-packages.rst:82
msgid "The :ref:`binary-distribution-format` specification describes additional files that may appear in the ``.dist-info`` directory of a :term:`Wheel`. Such files may be copied to the ``.dist-info`` directory of an installed project."
msgstr ""

#: ../source/specifications/recording-installed-packages.rst:87
msgid "The previous versions of this specification also specified a ``REQUESTED`` file. This file is now considered a tool-specific extension, but may be standardized again in the future. See `PEP 376 <https://www.python.org/dev/peps/pep-0376/#requested>`_ for its original meaning."
msgstr ""

#: ../source/specifications/recording-installed-packages.rst:94
msgid "The METADATA file"
msgstr ""

#: ../source/specifications/recording-installed-packages.rst:96
msgid "The ``METADATA`` file contains metadata as described in the :ref:`core-metadata` specification, version 1.1 or greater."
msgstr ""

#: ../source/specifications/recording-installed-packages.rst:99
msgid "The ``METADATA`` file is mandatory. If it cannot be created, or if required core metadata is not available, installers must report an error and fail to install the project."
msgstr ""

#: ../source/specifications/recording-installed-packages.rst:105
msgid "The RECORD file"
msgstr ""

#: ../source/specifications/recording-installed-packages.rst:107
msgid "The ``RECORD`` file holds the list of installed files. It is a CSV file containing one record (line) per installed file."
msgstr ""

#: ../source/specifications/recording-installed-packages.rst:110
msgid "The CSV dialect must be readable with the default ``reader`` of Python's ``csv`` module:"
msgstr ""

#: ../source/specifications/recording-installed-packages.rst:113
msgid "field delimiter: ``,`` (comma),"
msgstr ""

#: ../source/specifications/recording-installed-packages.rst:114
msgid "quoting char: ``\"`` (straight double quote),"
msgstr ""

#: ../source/specifications/recording-installed-packages.rst:115
msgid "line terminator: either ``\\r\\n`` or ``\\n``."
msgstr ""

#: ../source/specifications/recording-installed-packages.rst:117
msgid "Each record is composed of three elements: the file's **path**, the **hash** of the contents, and its **size**."
msgstr ""

#: ../source/specifications/recording-installed-packages.rst:120
msgid "The *path* may be either absolute, or relative to the directory containing the ``.dist-info`` directory (commonly, the ``site-packages`` directory). On Windows, directories may be separated either by forward- or backslashes (``/`` or ``\\``)."
msgstr ""

#: ../source/specifications/recording-installed-packages.rst:125
msgid "The *hash* is either an empty string or the name of a hash algorithm from ``hashlib.algorithms_guaranteed``, followed by the equals character ``=`` and the digest of the file's contents, encoded with the urlsafe-base64-nopad encoding (``base64.urlsafe_b64encode(digest)`` with trailing ``=`` removed)."
msgstr ""

#: ../source/specifications/recording-installed-packages.rst:130
msgid "The *size* is either the empty string, or file's size in bytes, as a base 10 integer."
msgstr ""

#: ../source/specifications/recording-installed-packages.rst:133
msgid "For any file, either or both of the *hash* and *size* fields may be left empty. Commonly, entries for ``.pyc`` files and the ``RECORD`` file itself have empty *hash* and *size*. For other files, leaving the information out is discouraged, as it prevents verifying the integrity of the installed project."
msgstr ""

#: ../source/specifications/recording-installed-packages.rst:139
msgid "If the ``RECORD`` file is present, it must list all installed files of the project, except ``.pyc`` files corresponding to ``.py`` files listed in ``RECORD``, which are optional. Notably, the contents of the ``.dist-info`` directory (including the ``RECORD`` file itself) must be listed. Directories should not be listed."
msgstr ""

#: ../source/specifications/recording-installed-packages.rst:146
msgid "To completely uninstall a package, a tool needs to remove all files listed in ``RECORD``, all ``.pyc`` files (of all optimization levels) corresponding to removed ``.py`` files, and any directories emptied by the uninstallation."
msgstr ""

#: ../source/specifications/recording-installed-packages.rst:151
msgid "Here is an example snippet of a possible ``RECORD`` file::"
msgstr ""

#: ../source/specifications/recording-installed-packages.rst:170
msgid "If the ``RECORD`` file is missing, tools that rely on ``.dist-info`` must not atempt to uninstall or upgrade the package. (This does not apply to tools that rely on other sources of information, such as system package managers in Linux distros.)"
msgstr ""

#: ../source/specifications/recording-installed-packages.rst:177
msgid "The INSTALLER file"
msgstr ""

#: ../source/specifications/recording-installed-packages.rst:179
msgid "If present, ``INSTALLER`` is a single-line text file naming the tool used to install the project. If the installer is executable from the command line, ``INSTALLER`` should contain the command name. Otherwise, it should contain a printable ASCII string."
msgstr ""

#: ../source/specifications/recording-installed-packages.rst:185
msgid "The file can be terminated by zero or more ASCII whitespace characters."
msgstr ""

#: ../source/specifications/recording-installed-packages.rst:187
msgid "Here are examples of two possible ``INSTALLER`` files::"
msgstr ""

#: ../source/specifications/recording-installed-packages.rst:195
msgid "This value should be used for informational purposes only. For example, if a tool is asked to uninstall a project but finds no ``RECORD`` file, it may suggest that the tool named in ``INSTALLER`` may be able to do the uninstallation."
msgstr ""

#: ../source/specifications/recording-installed-packages.rst:201
msgid "The direct_url.json file"
msgstr ""

#: ../source/specifications/recording-installed-packages.rst:203
msgid "This file MUST be created by installers when installing a distribution from a requirement specifying a direct URL reference (including a VCS URL)."
msgstr ""

#: ../source/specifications/recording-installed-packages.rst:209
msgid "Its detailed specification is at :ref:`direct-url`."
msgstr ""

#: ../source/specifications/simple-repository-api.rst:6
msgid "Simple repository API"
msgstr ""

#: ../source/specifications/simple-repository-api.rst:8
msgid "The current interface for querying available package versions and retrieving packages from an index server is defined in :pep:`503`, with the addition of \"yank\" support (allowing a kind of file deletion) as defined in :pep:`592` and specifying the interface version provided by an index server in :pep:`629`."
msgstr ""

#: ../source/specifications/source-distribution-format.rst:6
msgid "Source distribution format"
msgstr ""

#: ../source/specifications/source-distribution-format.rst:8
msgid "The current standard format of source distribution format is identified by the presence of a :file:`pyproject.toml` file in the distribution archive.  The layout of such a distribution was originally specified in :pep:`517` and is formally documented here."
msgstr ""

#: ../source/specifications/source-distribution-format.rst:13
msgid "There is also the legacy source distribution format, implicitly defined by the behaviour of ``distutils`` module in the standard library, when executing :command:`setup.py sdist`. This document does not attempt to standardise this format, except to note that if a legacy source distribution contains a ``PKG-INFO`` file using metadata version 2.2 or later, then it MUST follow the rules applicable to source distributions defined in the metadata specification."
msgstr ""

#: ../source/specifications/source-distribution-format.rst:21
msgid "Source distributions are also known as *sdists* for short."
msgstr ""

#: ../source/specifications/source-distribution-format.rst:24
msgid "Source distribution file name"
msgstr ""

#: ../source/specifications/source-distribution-format.rst:26
msgid "The file name of a sdist is not currently standardised, although the *de facto* form is ``{name}-{version}.tar.gz``, where ``{name}`` is the canonicalized form of the project name (see :pep:`503` for the canonicalization rules) with ``-`` characters replaced with ``_``, and ``{version}`` is the project version."
msgstr ""

#: ../source/specifications/source-distribution-format.rst:31
msgid "The name and version components of the filename MUST match the values stored in the metadata contained in the file."
msgstr ""

#: ../source/specifications/source-distribution-format.rst:35
msgid "Source distribution file format"
msgstr ""

#: ../source/specifications/source-distribution-format.rst:37
msgid "A ``.tar.gz`` source distribution (sdist) contains a single top-level directory called ``{name}-{version}`` (e.g. ``foo-1.0``), containing the source files of the package. The name and version MUST match the metadata stored in the file. This directory must also contain a :file:`pyproject.toml` in the format defined in :ref:`declaring-build-dependencies`, and a ``PKG-INFO`` file containing metadata in the format described in the :ref:`core-metadata` specification. The metadata MUST conform to at least version 2.2 of the metadata specification."
msgstr ""

#: ../source/specifications/source-distribution-format.rst:45
msgid "No other content of a sdist is required or defined. Build systems can store whatever information they need in the sdist to build the project."
msgstr ""

#: ../source/specifications/source-distribution-format.rst:48
msgid "The tarball should use the modern POSIX.1-2001 pax tar format, which specifies UTF-8 based file names."
msgstr ""

#: ../source/specifications/version-specifiers.rst:6
msgid "Version specifiers"
msgstr ""

#: ../source/specifications/version-specifiers.rst:8
msgid "Version numbering requirements and the semantics for specifying comparisons between versions are defined in :pep:`440`."
msgstr ""

#: ../source/specifications/version-specifiers.rst:11
msgid "The version specifiers section in this PEP supersedes the version specifiers section in :pep:`345`."
msgstr ""

#: ../source/support.rst:3
msgid "How to Get Support"
msgstr ""

#: ../source/support.rst:5
msgid "For support related to a specific project, see the links on the :doc:`Projects <key_projects>` page."
msgstr ""

#: ../source/support.rst:8
msgid "For something more general, or when you're just not sure, please `open an issue <https://github.com/pypa/packaging-problems/issues/new>`_ on the `packaging-problems <https://github.com/pypa/packaging-problems>`_ repository on GitHub."
msgstr ""

#: ../source/tutorials/creating-documentation.rst:5
msgid "Creating Documentation"
msgstr ""

#: ../source/tutorials/creating-documentation.rst:7
msgid "This section covers the basics of how to create documentation using `Sphinx`_ and host the documentation for free in `Read The Docs`_."
msgstr ""

#: ../source/tutorials/creating-documentation.rst:13
msgid "Installing Sphinx"
msgstr ""

#: ../source/tutorials/creating-documentation.rst:14
msgid "Use ``pip`` to install Sphinx:"
msgstr ""

#: ../source/tutorials/creating-documentation.rst:28
msgid "For other installation methods, see this `installation guide`_ by Sphinx."
msgstr ""

#: ../source/tutorials/creating-documentation.rst:33
msgid "Getting Started With Sphinx"
msgstr ""

#: ../source/tutorials/creating-documentation.rst:35
msgid "Create a ``docs`` directory inside your project to hold your documentation:"
msgstr ""

#: ../source/tutorials/creating-documentation.rst:42
msgid "Run ``sphinx-quickstart`` inside the ``docs`` directory:"
msgstr ""

#: ../source/tutorials/creating-documentation.rst:49
msgid "This sets up a source directory, walks you through some basic configurations, and creates an ``index.rst`` file as well as a ``conf.py`` file."
msgstr ""

#: ../source/tutorials/creating-documentation.rst:51
msgid "You can add some information about your project in ``index.rst``, then build them:"
msgstr ""

#: ../source/tutorials/creating-documentation.rst:57
msgid "For more details on the build process, see this `guide`_ by Read The Docs."
msgstr ""

#: ../source/tutorials/creating-documentation.rst:62
msgid "Other Sources"
msgstr ""

#: ../source/tutorials/creating-documentation.rst:64
msgid "For a more detailed guide on how to use Sphinx and reStructuredText, please see this `documentation tutorial`_ on Hitchhiker's Guide to Python."
msgstr ""

#: ../source/tutorials/index.rst:4
msgid "**Tutorials** are opinionated step-by-step guides to help you get familiar with packaging concepts. For more detailed information on specific packaging topics, see :doc:`/guides/index`."
msgstr ""

#: ../source/tutorials/installing-packages.rst:5
msgid "Installing Packages"
msgstr ""

#: ../source/tutorials/installing-packages.rst:7
msgid "This section covers the basics of how to install Python :term:`packages <Distribution Package>`."
msgstr ""

#: ../source/tutorials/installing-packages.rst:10
msgid "It's important to note that the term \"package\" in this context is being used to describe a bundle of software to be installed (i.e. as a synonym for a :term:`distribution <Distribution Package>`). It does not to refer to the kind of :term:`package <Import Package>` that you import in your Python source code (i.e. a container of modules). It is common in the Python community to refer to a :term:`distribution <Distribution Package>` using the term \"package\".  Using the term \"distribution\" is often not preferred, because it can easily be confused with a Linux distribution, or another larger software distribution like Python itself."
msgstr ""

#: ../source/tutorials/installing-packages.rst:28
msgid "Requirements for Installing Packages"
msgstr ""

#: ../source/tutorials/installing-packages.rst:30
msgid "This section describes the steps to follow before installing other Python packages."
msgstr ""

#: ../source/tutorials/installing-packages.rst:35
msgid "Ensure you can run Python from the command line"
msgstr ""

#: ../source/tutorials/installing-packages.rst:37
msgid "Before you go any further, make sure you have Python and that the expected version is available from your command line. You can check this by running:"
msgstr ""

#: ../source/tutorials/installing-packages.rst:53
msgid "You should get some output like ``Python 3.6.3``. If you do not have Python, please install the latest 3.x version from `python.org`_ or refer to the `Installing Python`_ section of the Hitchhiker's Guide to Python."
msgstr ""

#: ../source/tutorials/installing-packages.rst:57
msgid "If you're a newcomer and you get an error like this:"
msgstr ""

#: ../source/tutorials/installing-packages.rst:66
msgid "It's because this command and other suggested commands in this tutorial are intended to be run in a *shell* (also called a *terminal* or *console*). See the Python for Beginners `getting started tutorial`_ for an introduction to using your operating system's shell and interacting with Python."
msgstr ""

#: ../source/tutorials/installing-packages.rst:72
msgid "If you're using an enhanced shell like IPython or the Jupyter notebook, you can run system commands like those in this tutorial by prefacing them with a ``!`` character:"
msgstr ""

#: ../source/tutorials/installing-packages.rst:82
msgid "It's recommended to write ``{sys.executable}`` rather than plain ``python`` in order to ensure that commands are run in the Python installation matching the currently running notebook (which may not be the same Python installation that the ``python`` command refers to)."
msgstr ""

#: ../source/tutorials/installing-packages.rst:87
msgid "Due to the way most Linux distributions are handling the Python 3 migration, Linux users using the system Python without creating a virtual environment first should replace the ``python`` command in this tutorial with ``python3`` and the ``python -m pip`` command with ``python3 -m pip --user``. Do *not* run any of the commands in this tutorial with ``sudo``: if you get a permissions error, come back to the section on creating virtual environments, set one up, and then continue with the tutorial as written."
msgstr ""

#: ../source/tutorials/installing-packages.rst:99
msgid "Ensure you can run pip from the command line"
msgstr ""

#: ../source/tutorials/installing-packages.rst:101
msgid "Additionally, you'll need to make sure you have :ref:`pip` available. You can check this by running:"
msgstr ""

#: ../source/tutorials/installing-packages.rst:116
msgid "If you installed Python from source, with an installer from `python.org`_, or via `Homebrew`_ you should already have pip. If you're on Linux and installed using your OS package manager, you may have to install pip separately, see :doc:`/guides/installing-using-linux-tools`."
msgstr ""

#: ../source/tutorials/installing-packages.rst:124
msgid "If ``pip`` isn't already installed, then first try to bootstrap it from the standard library:"
msgstr ""

#: ../source/tutorials/installing-packages.rst:139
msgid "If that still doesn't allow you to run ``python -m pip``:"
msgstr ""

#: ../source/tutorials/installing-packages.rst:141
msgid "Securely Download `get-pip.py <https://bootstrap.pypa.io/get-pip.py>`_ [1]_"
msgstr ""

#: ../source/tutorials/installing-packages.rst:144
msgid "Run ``python get-pip.py``. [2]_  This will install or upgrade pip. Additionally, it will install :ref:`setuptools` and :ref:`wheel` if they're not installed already."
msgstr ""

#: ../source/tutorials/installing-packages.rst:150
msgid "Be cautious if you're using a Python install that's managed by your operating system or another package manager. get-pip.py does not coordinate with those tools, and may leave your system in an inconsistent state. You can use ``python get-pip.py --prefix=/usr/local/`` to install in ``/usr/local`` which is designed for locally-installed software."
msgstr ""

#: ../source/tutorials/installing-packages.rst:159
msgid "Ensure pip, setuptools, and wheel are up to date"
msgstr ""

#: ../source/tutorials/installing-packages.rst:161
msgid "While ``pip`` alone is sufficient to install from pre-built binary archives, up to date copies of the ``setuptools`` and ``wheel`` projects are useful to ensure you can also install from source archives::"
msgstr ""

#: ../source/tutorials/installing-packages.rst:169
msgid "Optionally, create a virtual environment"
msgstr ""

#: ../source/tutorials/installing-packages.rst:171
msgid "See :ref:`section below <Creating and using Virtual Environments>` for details, but here's the basic `venv`_ [3]_ command to use on a typical Linux system:"
msgstr ""

#: ../source/tutorials/installing-packages.rst:188
msgid "This will create a new virtual environment in the ``tutorial_env`` subdirectory, and configure the current shell to use it as the default ``python`` environment."
msgstr ""

#: ../source/tutorials/installing-packages.rst:195
msgid "Creating Virtual Environments"
msgstr ""

#: ../source/tutorials/installing-packages.rst:197
msgid "Python \"Virtual Environments\" allow Python :term:`packages <Distribution Package>` to be installed in an isolated location for a particular application, rather than being installed globally. If you are looking to safely install global command line tools, see :doc:`/guides/installing-stand-alone-command-line-tools`."
msgstr ""

#: ../source/tutorials/installing-packages.rst:203
msgid "Imagine you have an application that needs version 1 of LibFoo, but another application requires version 2. How can you use both these applications? If you install everything into /usr/lib/python3.6/site-packages (or whatever your platform’s standard location is), it’s easy to end up in a situation where you unintentionally upgrade an application that shouldn’t be upgraded."
msgstr ""

#: ../source/tutorials/installing-packages.rst:209
msgid "Or more generally, what if you want to install an application and leave it be? If an application works, any change in its libraries or the versions of those libraries can break the application."
msgstr ""

#: ../source/tutorials/installing-packages.rst:213
msgid "Also, what if you can’t install :term:`packages <Distribution Package>` into the global site-packages directory? For instance, on a shared host."
msgstr ""

#: ../source/tutorials/installing-packages.rst:216
msgid "In all these cases, virtual environments can help you. They have their own installation directories and they don’t share libraries with other virtual environments."
msgstr ""

#: ../source/tutorials/installing-packages.rst:220
msgid "Currently, there are two common tools for creating Python virtual environments:"
msgstr ""

#: ../source/tutorials/installing-packages.rst:222
msgid "`venv`_ is available by default in Python 3.3 and later, and installs :ref:`pip` and :ref:`setuptools` into created virtual environments in Python 3.4 and later."
msgstr ""

#: ../source/tutorials/installing-packages.rst:225
msgid ":ref:`virtualenv` needs to be installed separately, but supports Python 2.7+ and Python 3.3+, and :ref:`pip`, :ref:`setuptools` and :ref:`wheel` are always installed into created virtual environments by default (regardless of Python version)."
msgstr ""

#: ../source/tutorials/installing-packages.rst:230
msgid "The basic usage is like so:"
msgstr ""

#: ../source/tutorials/installing-packages.rst:232
msgid "Using `venv`_:"
msgstr ""

#: ../source/tutorials/installing-packages.rst:248
msgid "Using :ref:`virtualenv`:"
msgstr ""

#: ../source/tutorials/installing-packages.rst:264
msgid "For more information, see the `venv`_ docs or the `virtualenv <http://virtualenv.pypa.io>`_ docs."
msgstr ""

#: ../source/tutorials/installing-packages.rst:266
msgid "The use of :command:`source` under Unix shells ensures that the virtual environment's variables are set within the current shell, and not in a subprocess (which then disappears, having no useful effect)."
msgstr ""

#: ../source/tutorials/installing-packages.rst:271
msgid "In both of the above cases, Windows users should _not_ use the :command:`source` command, but should rather run the :command:`activate` script directly from the command shell like so:"
msgstr ""

#: ../source/tutorials/installing-packages.rst:281
msgid "Managing multiple virtual environments directly can become tedious, so the :ref:`dependency management tutorial <managing-dependencies>` introduces a higher level tool, :ref:`Pipenv`, that automatically manages a separate virtual environment for each project and application that you work on."
msgstr ""

#: ../source/tutorials/installing-packages.rst:288
msgid "Use pip for Installing"
msgstr ""

#: ../source/tutorials/installing-packages.rst:290
msgid ":ref:`pip` is the recommended installer.  Below, we'll cover the most common usage scenarios. For more detail, see the `pip docs <https://pip.pypa.io>`_, which includes a complete `Reference Guide <https://pip.pypa.io/en/latest/reference/index.html>`_."
msgstr ""

#: ../source/tutorials/installing-packages.rst:297
msgid "Installing from PyPI"
msgstr ""

#: ../source/tutorials/installing-packages.rst:299
msgid "The most common usage of :ref:`pip` is to install from the :term:`Python Package Index <Python Package Index (PyPI)>` using a :term:`requirement specifier <Requirement Specifier>`. Generally speaking, a requirement specifier is composed of a project name followed by an optional :term:`version specifier <Version Specifier>`.  :pep:`440` contains a :pep:`full specification <440#version-specifiers>` of the currently supported specifiers. Below are some examples."
msgstr ""

#: ../source/tutorials/installing-packages.rst:307
msgid "To install the latest version of \"SomeProject\":"
msgstr ""

#: ../source/tutorials/installing-packages.rst:321
msgid "To install a specific version:"
msgstr ""

#: ../source/tutorials/installing-packages.rst:335
msgid "To install greater than or equal to one version and less than another:"
msgstr ""

#: ../source/tutorials/installing-packages.rst:350
msgid "To install a version that's :pep:`\"compatible\" <440#compatible-release>` with a certain version: [4]_"
msgstr ""

#: ../source/tutorials/installing-packages.rst:365
msgid "In this case, this means to install any version \"==1.4.*\" version that's also \">=1.4.2\"."
msgstr ""

#: ../source/tutorials/installing-packages.rst:370
msgid "Source Distributions vs Wheels"
msgstr ""

#: ../source/tutorials/installing-packages.rst:372
msgid ":ref:`pip` can install from either :term:`Source Distributions (sdist) <Source Distribution (or \"sdist\")>` or :term:`Wheels <Wheel>`, but if both are present on PyPI, pip will prefer a compatible :term:`wheel <Wheel>`. You can override pip`s default behavior by e.g. using its :ref:`--no-binary <pip:install_--no-binary>` option."
msgstr ""

#: ../source/tutorials/installing-packages.rst:378
msgid ":term:`Wheels <Wheel>` are a pre-built :term:`distribution <Distribution Package>` format that provides faster installation compared to :term:`Source Distributions (sdist) <Source Distribution (or \"sdist\")>`, especially when a project contains compiled extensions."
msgstr ""

#: ../source/tutorials/installing-packages.rst:383
msgid "If :ref:`pip` does not find a wheel to install, it will locally build a wheel and cache it for future installs, instead of rebuilding the source distribution in the future."
msgstr ""

#: ../source/tutorials/installing-packages.rst:391
msgid "Upgrade an already installed ``SomeProject`` to the latest from PyPI."
msgstr ""

#: ../source/tutorials/installing-packages.rst:408
msgid "Installing to the User Site"
msgstr ""

#: ../source/tutorials/installing-packages.rst:410
msgid "To install :term:`packages <Distribution Package>` that are isolated to the current user, use the ``--user`` flag:"
msgstr ""

#: ../source/tutorials/installing-packages.rst:425
msgid "For more information see the `User Installs <https://pip.readthedocs.io/en/latest/user_guide.html#user-installs>`_ section from the pip docs."
msgstr ""

#: ../source/tutorials/installing-packages.rst:429
msgid "Note that the ``--user`` flag has no effect when inside a virtual environment - all installation commands will affect the virtual environment."
msgstr ""

#: ../source/tutorials/installing-packages.rst:432
msgid "If ``SomeProject`` defines any command-line scripts or console entry points, ``--user`` will cause them to be installed inside the `user base`_'s binary directory, which may or may not already be present in your shell's :envvar:`PATH`.  (Starting in version 10, pip displays a warning when installing any scripts to a directory outside :envvar:`PATH`.)  If the scripts are not available in your shell after installation, you'll need to add the directory to your :envvar:`PATH`:"
msgstr ""

#: ../source/tutorials/installing-packages.rst:440
msgid "On Linux and macOS you can find the user base binary directory by running ``python -m site --user-base`` and adding ``bin`` to the end. For example, this will typically print ``~/.local`` (with ``~`` expanded to the absolute path to your home directory) so you'll need to add ``~/.local/bin`` to your ``PATH``.  You can set your ``PATH`` permanently by `modifying ~/.profile`_."
msgstr ""

#: ../source/tutorials/installing-packages.rst:446
msgid "On Windows you can find the user base binary directory by running ``py -m site --user-site`` and replacing ``site-packages`` with ``Scripts``. For example, this could return ``C:\\Users\\Username\\AppData\\Roaming\\Python36\\site-packages`` so you would need to set your ``PATH`` to include ``C:\\Users\\Username\\AppData\\Roaming\\Python36\\Scripts``. You can set your user ``PATH`` permanently in the `Control Panel`_. You may need to log out for the ``PATH`` changes to take effect."
msgstr ""

#: ../source/tutorials/installing-packages.rst:462
msgid "Install a list of requirements specified in a :ref:`Requirements File <pip:Requirements Files>`."
msgstr ""

#: ../source/tutorials/installing-packages.rst:478
msgid "Installing from VCS"
msgstr ""

#: ../source/tutorials/installing-packages.rst:480
msgid "Install a project from VCS in \"editable\" mode.  For a full breakdown of the syntax, see pip's section on :ref:`VCS Support <pip:VCS Support>`."
msgstr ""

#: ../source/tutorials/installing-packages.rst:502
msgid "Installing from other Indexes"
msgstr ""

#: ../source/tutorials/installing-packages.rst:504
msgid "Install from an alternate index"
msgstr ""

#: ../source/tutorials/installing-packages.rst:518
msgid "Search an additional index during install, in addition to :term:`PyPI <Python Package Index (PyPI)>`"
msgstr ""

#: ../source/tutorials/installing-packages.rst:534
msgid "Installing from a local src tree"
msgstr ""

#: ../source/tutorials/installing-packages.rst:537
msgid "Installing from local src in `Development Mode <https://setuptools.readthedocs.io/en/latest/setuptools.html#development-mode>`_, i.e. in such a way that the project appears to be installed, but yet is still editable from the src tree."
msgstr ""

#: ../source/tutorials/installing-packages.rst:554
msgid "You can also install normally from src"
msgstr ""

#: ../source/tutorials/installing-packages.rst:571
msgid "Install a particular source archive file."
msgstr ""

#: ../source/tutorials/installing-packages.rst:585
msgid "Install from a local directory containing archives (and don't check :term:`PyPI <Python Package Index (PyPI)>`)"
msgstr ""

#: ../source/tutorials/installing-packages.rst:605
msgid "Installing from other sources"
msgstr ""

#: ../source/tutorials/installing-packages.rst:607
msgid "To install from other data sources (for example Amazon S3 storage) you can create a helper application that presents the data in a :pep:`503` compliant index format, and use the ``--extra-index-url`` flag to direct pip to use that index."
msgstr ""

#: ../source/tutorials/installing-packages.rst:619
msgid "Installing Prereleases"
msgstr ""

#: ../source/tutorials/installing-packages.rst:621
msgid "Find pre-release and development versions, in addition to stable versions.  By default, pip only finds stable versions."
msgstr ""

#: ../source/tutorials/installing-packages.rst:637
msgid "Installing Setuptools \"Extras\""
msgstr ""

#: ../source/tutorials/installing-packages.rst:639
msgid "Install `setuptools extras`_."
msgstr ""

#: ../source/tutorials/installing-packages.rst:659
msgid "\"Secure\" in this context means using a modern browser or a tool like :command:`curl` that verifies SSL certificates when downloading from https URLs."
msgstr ""

#: ../source/tutorials/installing-packages.rst:668
msgid "Beginning with Python 3.4, ``venv`` (a stdlib alternative to :ref:`virtualenv`) will create virtualenv environments with ``pip`` pre-installed, thereby making it an equal alternative to :ref:`virtualenv`."
msgstr ""

#: ../source/tutorials/installing-packages.rst:673
msgid "The compatible release specifier was accepted in :pep:`440` and support was released in :ref:`setuptools` v8.0 and :ref:`pip` v6.0"
msgstr ""

#: ../source/tutorials/managing-dependencies.rst:4
msgid "Managing Application Dependencies"
msgstr ""

#: ../source/tutorials/managing-dependencies.rst:6
msgid "The :ref:`package installation tutorial <installing-packages>` covered the basics of getting set up to install and update Python packages."
msgstr ""

#: ../source/tutorials/managing-dependencies.rst:9
msgid "However, running these commands interactively can get tedious even for your own personal projects, and things get even more difficult when trying to set up development environments automatically for projects with multiple contributors."
msgstr ""

#: ../source/tutorials/managing-dependencies.rst:13
msgid "This tutorial walks you through the use of :ref:`Pipenv` to manage dependencies for an application. It will show you how to install and use the necessary tools and make strong recommendations on best practices."
msgstr ""

#: ../source/tutorials/managing-dependencies.rst:17
msgid "Keep in mind that Python is used for a great many different purposes, and precisely how you want to manage your dependencies may change based on how you decide to publish your software. The guidance presented here is most directly applicable to the development and deployment of network services (including web applications), but is also very well suited to managing development and testing environments for any kind of project."
msgstr ""

#: ../source/tutorials/managing-dependencies.rst:24
msgid "Developers of Python libraries, or of applications that support distribution as Python libraries, should also consider the `poetry <https://github.com/python-poetry/poetry>`_ project as an alternative dependency management solution."
msgstr ""

#: ../source/tutorials/managing-dependencies.rst:30
msgid "Installing Pipenv"
msgstr ""

#: ../source/tutorials/managing-dependencies.rst:32
msgid ":ref:`Pipenv` is a dependency manager for Python projects. If you're familiar with Node.js' `npm`_ or Ruby's `bundler`_, it is similar in spirit to those tools. While :ref:`pip` alone is often sufficient for personal use, Pipenv is recommended for collaborative projects as it's a higher-level tool that simplifies dependency management for common use cases."
msgstr ""

#: ../source/tutorials/managing-dependencies.rst:38
msgid "Use ``pip`` to install Pipenv:"
msgstr ""

#: ../source/tutorials/managing-dependencies.rst:54
msgid "This does a `user installation`_ to prevent breaking any system-wide packages. If ``pipenv`` isn't available in your shell after installation, you'll need to add the `user base`_'s binary directory to your ``PATH``. See :ref:`Installing to the User Site` for more information."
msgstr ""

#: ../source/tutorials/managing-dependencies.rst:65
msgid "Installing packages for your project"
msgstr ""

#: ../source/tutorials/managing-dependencies.rst:67
msgid "Pipenv manages dependencies on a per-project basis. To install packages, change into your project's directory (or just an empty directory for this tutorial) and run:"
msgstr ""

#: ../source/tutorials/managing-dependencies.rst:76
msgid "Pipenv will install the `Requests`_ library and create a ``Pipfile`` for you in your project's directory. The :ref:`Pipfile` is used to track which dependencies your project needs in case you need to re-install them, such as when you share your project with others. You should get output similar to this (although the exact paths shown will vary):"
msgstr ""

#: ../source/tutorials/managing-dependencies.rst:112
msgid "Using installed packages"
msgstr ""

#: ../source/tutorials/managing-dependencies.rst:114
msgid "Now that Requests is installed you can create a simple :file:`main.py` file to use it:"
msgstr ""

#: ../source/tutorials/managing-dependencies.rst:125
msgid "Then you can run this script using ``pipenv run``:"
msgstr ""

#: ../source/tutorials/managing-dependencies.rst:131
msgid "You should get output similar to this:"
msgstr ""

#: ../source/tutorials/managing-dependencies.rst:137
msgid "Using ``pipenv run`` ensures that your installed packages are available to your script. It's also possible to spawn a new shell that ensures all commands have access to your installed packages with ``pipenv shell``."
msgstr ""

#: ../source/tutorials/managing-dependencies.rst:143
#: ../source/tutorials/packaging-projects.rst:594
msgid "Next steps"
msgstr ""

#: ../source/tutorials/managing-dependencies.rst:145
msgid "Congratulations, you now know how to effectively manage dependencies and development environments on a collaborative Python project! ✨ 🍰 ✨"
msgstr ""

#: ../source/tutorials/managing-dependencies.rst:148
msgid "If you're interested in creating and distributing your own Python packages, see the :ref:`tutorial on packaging and distributing packages <distributing-packages>`."
msgstr ""

#: ../source/tutorials/managing-dependencies.rst:151
msgid "Note that when your application includes definitions of Python source packages, they (and their dependencies) can be added to your ``pipenv`` environment with ``pipenv install -e <relative-path-to-source-directory>`` (e.g. ``pipenv install -e .`` or ``pipenv install -e src``)."
msgstr ""

#: ../source/tutorials/managing-dependencies.rst:160
msgid "Other Tools for Application Dependency Management"
msgstr ""

#: ../source/tutorials/managing-dependencies.rst:162
msgid "If you find this particular approach to managing application dependencies isn't working well for you or your use case, you may want to explore these other tools and techniques to see if one of them is a better fit:"
msgstr ""

#: ../source/tutorials/managing-dependencies.rst:166
msgid "`poetry <https://github.com/python-poetry/poetry>`__ for a tool comparable in scope to ``pipenv`` that focuses more directly on use cases where the repository being managed is structured as a Python project with a valid ``pyproject.toml`` file (by contrast, ``pipenv`` explicitly avoids making the assumption that the application being worked on that's depending on components from PyPI will itself support distribution as a ``pip``-installable Python package)."
msgstr ""

#: ../source/tutorials/managing-dependencies.rst:172
msgid "`hatch <https://github.com/ofek/hatch>`_ for opinionated coverage of even more steps in the project management workflow (such as incrementing versions, tagging releases, and creating new skeleton projects from project templates)"
msgstr ""

#: ../source/tutorials/managing-dependencies.rst:175
msgid "`pip-tools <https://github.com/jazzband/pip-tools>`_ to build your own custom workflow from lower level pieces like ``pip-compile`` and ``pip-sync``"
msgstr ""

#: ../source/tutorials/managing-dependencies.rst:177
msgid "`micropipenv <https://github.com/thoth-station/micropipenv>`_ is a lightweight wrapper for pip to support requirements.txt, Pipenv and Poetry lock files or converting them to pip-tools compatible output. Designed for containerized Python applications but not limited to them."
msgstr ""

#: ../source/tutorials/packaging-projects.rst:2
msgid "Packaging Python Projects"
msgstr ""

#: ../source/tutorials/packaging-projects.rst:4
msgid "This tutorial walks you through how to package a simple Python project. It will show you how to add the necessary files and structure to create the package, how to build the package, and how to upload it to the Python Package Index."
msgstr ""

#: ../source/tutorials/packaging-projects.rst:10
msgid "If you have trouble running the commands in this tutoral, please copy the command and its output, then `open an issue`_ on the `packaging-problems`_ repository on GitHub. We'll do our best to help you!"
msgstr ""

#: ../source/tutorials/packaging-projects.rst:18
msgid "Some of the commands require a newer version of :ref:`pip`, so start by making sure you have the latest version installed:"
msgstr ""

#: ../source/tutorials/packaging-projects.rst:35
msgid "A simple project"
msgstr ""

#: ../source/tutorials/packaging-projects.rst:37
msgid "This tutorial uses a simple project named ``example_package``.  We recommend following this tutorial as-is using this project, before packaging your own project."
msgstr ""

#: ../source/tutorials/packaging-projects.rst:41
msgid "Create the following file structure locally:"
msgstr ""

#: ../source/tutorials/packaging-projects.rst:51
msgid ":file:`__init__.py` is required to import the directory as a package, and should be empty."
msgstr ""

#: ../source/tutorials/packaging-projects.rst:54
msgid ":file:`example.py` is an example of a module within the package that could contain the logic (functions, classes, constants, etc.) of your package. Open that file and enter the following content:"
msgstr ""

#: ../source/tutorials/packaging-projects.rst:63
msgid "If you are unfamiliar with Python's :term:`modules <Module>` and :term:`import packages <Import Package>`, take a few minutes to read over the `Python documentation for packages and modules`_."
msgstr ""

#: ../source/tutorials/packaging-projects.rst:67
msgid "Once you create this structure, you'll want to run all of the commands in this tutorial within the ``packaging_tutorial`` directory."
msgstr ""

#: ../source/tutorials/packaging-projects.rst:75
msgid "Creating the package files"
msgstr ""

#: ../source/tutorials/packaging-projects.rst:77
msgid "You will now add files that are used to prepare the project for distribution. When you're done, the project structure will look like this:"
msgstr ""

#: ../source/tutorials/packaging-projects.rst:95
msgid "Creating a test directory"
msgstr ""

#: ../source/tutorials/packaging-projects.rst:97
msgid ":file:`tests/` is a placeholder for test files. Leave it empty for now."
msgstr ""

#: ../source/tutorials/packaging-projects.rst:101
msgid "Creating pyproject.toml"
msgstr ""

#: ../source/tutorials/packaging-projects.rst:103
msgid ":file:`pyproject.toml` tells build tools (like :ref:`pip` and :ref:`build`) what is required to build your project. This tutorial uses :ref:`setuptools`, so open :file:`pyproject.toml` and enter the following content:"
msgstr ""

#: ../source/tutorials/packaging-projects.rst:117
msgid "``build-system.requires`` gives a list of packages that are needed to build your package. Listing something here will *only* make it available during the build, not after it is installed."
msgstr ""

#: ../source/tutorials/packaging-projects.rst:121
msgid "``build-system.build-backend`` is the name of Python object that will be used to perform the build. If you were to use a different build system, such as :ref:`flit` or :ref:`poetry`, those would go here, and the configuration details would be completely different than the :ref:`setuptools` configuration described below."
msgstr ""

#: ../source/tutorials/packaging-projects.rst:127
msgid "See :pep:`517` and :pep:`518` for background and details."
msgstr ""

#: ../source/tutorials/packaging-projects.rst:131
msgid "Configuring metadata"
msgstr ""

#: ../source/tutorials/packaging-projects.rst:133
msgid "There are two types of metadata: static and dynamic."
msgstr ""

#: ../source/tutorials/packaging-projects.rst:135
msgid "Static metadata (:file:`setup.cfg`): guaranteed to be the same every time. This is simpler, easier to read, and avoids many common errors, like encoding errors."
msgstr ""

#: ../source/tutorials/packaging-projects.rst:137
msgid "Dynamic metadata (:file:`setup.py`): possibly non-deterministic. Any items that are dynamic or determined at install-time, as well as extension modules or extensions to setuptools, need to go into :file:`setup.py`."
msgstr ""

#: ../source/tutorials/packaging-projects.rst:141
msgid "Static metadata (:file:`setup.cfg`) should be preferred. Dynamic metadata (:file:`setup.py`) should be used only as an escape hatch when absolutely necessary. :file:`setup.py` used to be required, but can be omitted with newer versions of setuptools and pip."
msgstr ""

#: ../source/tutorials/packaging-projects.rst:148
msgid ":file:`setup.cfg` is the configuration file for :ref:`setuptools`. It tells setuptools about your package (such as the name and version) as well as which code files to include. Eventually much of this configuration may be able to move to :file:`pyproject.toml`."
msgstr ""

#: ../source/tutorials/packaging-projects.rst:153
msgid "Open :file:`setup.cfg` and enter the following content. Change the ``name`` to include your username; this ensures that you have a unique package name and that your package doesn't conflict with packages uploaded by other people following this tutorial."
msgstr ""

#: ../source/tutorials/packaging-projects.rst:185
msgid "There are a `variety of metadata and options <https://setuptools.readthedocs.io/en/latest/userguide/declarative_config.html>`_ supported here. This is in :doc:`configparser <python:library/configparser>` format; do not place quotes around values. This example package uses a relatively minimal set of ``metadata``:"
msgstr ""

#: ../source/tutorials/packaging-projects.rst:191
#: ../source/tutorials/packaging-projects.rst:286
msgid "``name`` is the *distribution name* of your package. This can be any name as long as it only contains letters, numbers, ``_`` , and ``-``. It also must not already be taken on pypi.org. **Be sure to update this with your username,** as this ensures you won't try to upload a package with the same name as one which already exists."
msgstr ""

#: ../source/tutorials/packaging-projects.rst:196
msgid "``version`` is the package version. See :pep:`440` for more details on versions. You can use ``file:`` or ``attr:`` directives to read from a file or package attribute."
msgstr ""

#: ../source/tutorials/packaging-projects.rst:199
#: ../source/tutorials/packaging-projects.rst:293
msgid "``author`` and ``author_email`` are used to identify the author of the package."
msgstr ""

#: ../source/tutorials/packaging-projects.rst:201
#: ../source/tutorials/packaging-projects.rst:295
msgid "``description`` is a short, one-sentence summary of the package."
msgstr ""

#: ../source/tutorials/packaging-projects.rst:202
msgid "``long_description`` is a detailed description of the package. This is shown on the package detail page on the Python Package Index. In this case, the long description is loaded from :file:`README.md` (which is a common pattern) using the ``file:`` directive."
msgstr ""

#: ../source/tutorials/packaging-projects.rst:206
#: ../source/tutorials/packaging-projects.rst:300
msgid "``long_description_content_type`` tells the index what type of markup is used for the long description. In this case, it's Markdown."
msgstr ""

#: ../source/tutorials/packaging-projects.rst:208
#: ../source/tutorials/packaging-projects.rst:302
msgid "``url`` is the URL for the homepage of the project. For many projects, this will just be a link to GitHub, GitLab, Bitbucket, or similar code hosting service."
msgstr ""

#: ../source/tutorials/packaging-projects.rst:211
#: ../source/tutorials/packaging-projects.rst:305
msgid "``project_urls`` lets you list any number of extra links to show on PyPI. Generally this could be to documentation, issue trackers, etc."
msgstr ""

#: ../source/tutorials/packaging-projects.rst:213
#: ../source/tutorials/packaging-projects.rst:307
msgid "``classifiers`` gives the index and :ref:`pip` some additional metadata about your package. In this case, the package is only compatible with Python 3, is licensed under the MIT license, and is OS-independent. You should always include at least which version(s) of Python your package works on, which license your package is available under, and which operating systems your package will work on. For a complete list of classifiers, see https://pypi.org/classifiers/."
msgstr ""

#: ../source/tutorials/packaging-projects.rst:221
msgid "In the ``options`` category, we have controls for setuptools itself:"
msgstr ""

#: ../source/tutorials/packaging-projects.rst:223
msgid "``package_dir`` is a mapping of package names and directories. An empty package name represents the \"root package\" --- the directory in the project that contains all Python source files for the package --- so in this case the ``src`` directory is designated the root package."
msgstr ""

#: ../source/tutorials/packaging-projects.rst:227
msgid "``packages`` is a list of all Python :term:`import packages <Import Package>` that should be included in the :term:`distribution package <Distribution Package>`. Instead of listing each package manually, we can use the ``find:`` directive to automatically discover all packages and subpackages and ``options.packages.find`` to specify the ``package_dir`` to use. In this case, the list of packages will be ``example_package`` as that's the only package present."
msgstr ""

#: ../source/tutorials/packaging-projects.rst:234
msgid "``python_requires`` gives the versions of Python supported by your project. Installers like :ref:`pip` will look back through older versions of packages until it finds one that has a matching Python version."
msgstr ""

#: ../source/tutorials/packaging-projects.rst:238
#: ../source/tutorials/packaging-projects.rst:329
msgid "There are many more than the ones mentioned here. See :doc:`/guides/distributing-packages-using-setuptools` for more details."
msgstr ""

#: ../source/tutorials/packaging-projects.rst:244
msgid ":file:`setup.py` is the build script for :ref:`setuptools`. It tells setuptools about your package (such as the name and version) as well as which code files to include."
msgstr ""

#: ../source/tutorials/packaging-projects.rst:248
msgid "Open :file:`setup.py` and enter the following content.  Change the ``name`` to include your username; this ensures that you have a unique package name and that your package doesn't conflict with packages uploaded by other people following this tutorial."
msgstr ""

#: ../source/tutorials/packaging-projects.rst:283
msgid ":func:`setup` takes several arguments. This example package uses a relatively minimal set:"
msgstr ""

#: ../source/tutorials/packaging-projects.rst:291
msgid "``version`` is the package version. See :pep:`440` for more details on versions."
msgstr ""

#: ../source/tutorials/packaging-projects.rst:296
msgid "``long_description`` is a detailed description of the package. This is shown on the package detail page on the Python Package Index. In this case, the long description is loaded from :file:`README.md`, which is a common pattern."
msgstr ""

#: ../source/tutorials/packaging-projects.rst:314
msgid "``package_dir`` is a dictionary with package names for keys and directories for values. An empty package name represents the \"root package\" --- the directory in the project that contains all Python source files for the package --- so in this case the ``src`` directory is designated the root package."
msgstr ""

#: ../source/tutorials/packaging-projects.rst:319
msgid "``packages`` is a list of all Python :term:`import packages <Import Package>` that should be included in the :term:`distribution package <Distribution Package>`. Instead of listing each package manually, we can use :func:`find_packages` to automatically discover all packages and subpackages under ``package_dir``. In this case, the list of packages will be ``example_package`` as that's the only package present."
msgstr ""

#: ../source/tutorials/packaging-projects.rst:325
msgid "``python_requires`` gives the versions of Python supported by your project. Installers like :ref:`pip` will look back though older versions of packages until it finds one that has a matching Python version."
msgstr ""

#: ../source/tutorials/packaging-projects.rst:333
msgid "Creating README.md"
msgstr ""

#: ../source/tutorials/packaging-projects.rst:335
msgid "Open :file:`README.md` and enter the following content. You can customize this if you'd like."
msgstr ""

#: ../source/tutorials/packaging-projects.rst:347
msgid "Because our configuration loads :file:`README.md` to provide a ``long_description``, :file:`README.md` must be included along with your code when you :ref:`generate a source distribution <generating archives>`. Newer versions of :ref:`setuptools` will do this automatically."
msgstr ""

#: ../source/tutorials/packaging-projects.rst:354
msgid "Creating a LICENSE"
msgstr ""

#: ../source/tutorials/packaging-projects.rst:356
msgid "It's important for every package uploaded to the Python Package Index to include a license. This tells users who install your package the terms under which they can use your package. For help picking a license, see https://choosealicense.com/. Once you have chosen a license, open :file:`LICENSE` and enter the license text. For example, if you had chosen the MIT license:"
msgstr ""

#: ../source/tutorials/packaging-projects.rst:387
msgid "Including other files"
msgstr ""

#: ../source/tutorials/packaging-projects.rst:389
msgid "The files listed above will be included automatically in your :term:`source distribution <Source Distribution (or \"sdist\")>`. If you want to control what goes in this explicitly, see :ref:`Using MANIFEST.in`."
msgstr ""

#: ../source/tutorials/packaging-projects.rst:393
msgid "The final :term:`built distribution <Built Distribution>` will have the Python files in the discovered or listed Python packages. If you want to control what goes here, such as to add data files, see :doc:`Including Data Files <setuptools:userguide/datafiles>` from the :doc:`setuptools docs <setuptools:index>`."
msgstr ""

#: ../source/tutorials/packaging-projects.rst:402
msgid "Generating distribution archives"
msgstr ""

#: ../source/tutorials/packaging-projects.rst:404
msgid "The next step is to generate :term:`distribution packages <Distribution Package>` for the package. These are archives that are uploaded to the Python Package Index and can be installed by :ref:`pip`."
msgstr ""

#: ../source/tutorials/packaging-projects.rst:408
msgid "Make sure you have the latest version of PyPA's :ref:`build` installed:"
msgstr ""

#: ../source/tutorials/packaging-projects.rst:422
msgid "If you have trouble installing these, see the :doc:`installing-packages` tutorial."
msgstr ""

#: ../source/tutorials/packaging-projects.rst:425
msgid "Now run this command from the same directory where :file:`pyproject.toml` is located:"
msgstr ""

#: ../source/tutorials/packaging-projects.rst:439
msgid "This command should output a lot of text and once completed should generate two files in the :file:`dist` directory:"
msgstr ""

#: ../source/tutorials/packaging-projects.rst:449
msgid "The ``tar.gz`` file is a :term:`source archive <Source Archive>` whereas the ``.whl`` file is a :term:`built distribution <Built Distribution>`. Newer :ref:`pip` versions preferentially install built distributions, but will fall back to source archives if needed. You should always upload a source archive and provide built archives for the platforms your project is compatible with. In this case, our example package is compatible with Python on any platform so only one built distribution is needed."
msgstr ""

#: ../source/tutorials/packaging-projects.rst:458
msgid "Uploading the distribution archives"
msgstr ""

#: ../source/tutorials/packaging-projects.rst:460
msgid "Finally, it's time to upload your package to the Python Package Index!"
msgstr ""

#: ../source/tutorials/packaging-projects.rst:462
msgid "The first thing you'll need to do is register an account on TestPyPI, which is a separate instance of the package index intended for testing and experimentation. It's great for things like this tutorial where we don't necessarily want to upload to the real index. To register an account, go to https://test.pypi.org/account/register/ and complete the steps on that page. You will also need to verify your email address before you're able to upload any packages.  For more details, see :doc:`/guides/using-testpypi`."
msgstr ""

#: ../source/tutorials/packaging-projects.rst:470
msgid "To securely upload your project, you'll need a PyPI `API token`_. Create one at https://test.pypi.org/manage/account/#api-tokens, setting the \"Scope\" to \"Entire account\". **Don't close the page until you have copied and saved the token — you won't see that token again.**"
msgstr ""

#: ../source/tutorials/packaging-projects.rst:477
msgid "Now that you are registered, you can use :ref:`twine` to upload the distribution packages. You'll need to install Twine:"
msgstr ""

#: ../source/tutorials/packaging-projects.rst:492
msgid "Once installed, run Twine to upload all of the archives under :file:`dist`:"
msgstr ""

#: ../source/tutorials/packaging-projects.rst:506
msgid "You will be prompted for a username and password. For the username, use ``__token__``. For the password, use the token value, including the ``pypi-`` prefix."
msgstr ""

#: ../source/tutorials/packaging-projects.rst:510
msgid "After the command completes, you should see output similar to this:"
msgstr ""

#: ../source/tutorials/packaging-projects.rst:523
msgid "Once uploaded your package should be viewable on TestPyPI, for example, https://test.pypi.org/project/example-pkg-YOUR-USERNAME-HERE"
msgstr ""

#: ../source/tutorials/packaging-projects.rst:528
msgid "Installing your newly uploaded package"
msgstr ""

#: ../source/tutorials/packaging-projects.rst:530
msgid "You can use :ref:`pip` to install your package and verify that it works. Create a :ref:`virtual environment <Creating and using Virtual Environments>` and install your package from TestPyPI:"
msgstr ""

#: ../source/tutorials/packaging-projects.rst:546
msgid "Make sure to specify your username in the package name!"
msgstr ""

#: ../source/tutorials/packaging-projects.rst:548
msgid "pip should install the package from TestPyPI and the output should look something like this:"
msgstr ""

#: ../source/tutorials/packaging-projects.rst:558
msgid "This example uses ``--index-url`` flag to specify TestPyPI instead of live PyPI. Additionally, it specifies ``--no-deps``. Since TestPyPI doesn't have the same packages as the live PyPI, it's possible that attempting to install dependencies may fail or install something unexpected. While our example package doesn't have any dependencies, it's a good practice to avoid installing dependencies when using TestPyPI."
msgstr ""

#: ../source/tutorials/packaging-projects.rst:565
msgid "You can test that it was installed correctly by importing the package. Make sure you're still in your virtual environment, then run Python:"
msgstr ""

#: ../source/tutorials/packaging-projects.rst:580
msgid "and import the package:"
msgstr ""

#: ../source/tutorials/packaging-projects.rst:588
msgid "Note that the :term:`import package <Import Package>` is ``example_package`` regardless of what ``name`` you gave your :term:`distribution package <Distribution Package>` in :file:`setup.cfg` or :file:`setup.py` (in this case, ``example-pkg-YOUR-USERNAME-HERE``)."
msgstr ""

#: ../source/tutorials/packaging-projects.rst:596
msgid "**Congratulations, you've packaged and distributed a Python project!** ✨ 🍰 ✨"
msgstr ""

#: ../source/tutorials/packaging-projects.rst:599
msgid "Keep in mind that this tutorial showed you how to upload your package to Test PyPI, which isn't a permanent storage. The Test system occasionally deletes packages and accounts. It is best to use TestPyPI for testing and experiments like this tutorial."
msgstr ""

#: ../source/tutorials/packaging-projects.rst:604
msgid "When you are ready to upload a real package to the Python Package Index you can do much the same as you did in this tutorial, but with these important differences:"
msgstr ""

#: ../source/tutorials/packaging-projects.rst:608
msgid "Choose a memorable and unique name for your package. You don't have to append your username as you did in the tutorial."
msgstr ""

#: ../source/tutorials/packaging-projects.rst:610
msgid "Register an account on https://pypi.org - note that these are two separate servers and the login details from the test server are not shared with the main server."
msgstr ""

#: ../source/tutorials/packaging-projects.rst:613
msgid "Use ``twine upload dist/*`` to upload your package and enter your credentials for the account you registered on the real PyPI.  Now that you're uploading the package in production, you don't need to specify ``--repository``; the package will upload to https://pypi.org/ by default."
msgstr ""

#: ../source/tutorials/packaging-projects.rst:617
msgid "Install your package from the real PyPI using ``python3 -m pip install [your-package]``."
msgstr ""

#: ../source/tutorials/packaging-projects.rst:619
msgid "At this point if you want to read more on packaging Python libraries here are some things you can do:"
msgstr ""

#: ../source/tutorials/packaging-projects.rst:622
msgid "Read more about using :ref:`setuptools` to package libraries in :doc:`/guides/distributing-packages-using-setuptools`."
msgstr ""

#: ../source/tutorials/packaging-projects.rst:624
msgid "Read about :doc:`/guides/packaging-binary-extensions`."
msgstr ""

#: ../source/tutorials/packaging-projects.rst:625
msgid "Consider alternatives to :ref:`setuptools` such as :ref:`flit`, :ref:`hatch`, and :ref:`poetry`."
msgstr ""
