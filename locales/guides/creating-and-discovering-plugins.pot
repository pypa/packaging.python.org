# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2013â€“2020, PyPA
# This file is distributed under the same license as the Python Packaging User Guide package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python Packaging User Guide \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-06-29 15:34+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../source/guides/creating-and-discovering-plugins.rst:3
#: 5b7b3eb9ff7b475e887394731904b06d
msgid "Creating and discovering plugins"
msgstr ""

#: ../source/guides/creating-and-discovering-plugins.rst:5
#: e54114a0451344f69bf2a3805b3e6585
msgid "Often when creating a Python application or library you'll want the ability to provide customizations or extra features via **plugins**. Because Python packages can be separately distributed, your application or library may want to automatically **discover** all of the plugins available."
msgstr ""

#: ../source/guides/creating-and-discovering-plugins.rst:10
#: 7cb24b962d1840cf96fcc58f7167d5b2
msgid "There are three major approaches to doing automatic plugin discovery:"
msgstr ""

#: ../source/guides/creating-and-discovering-plugins.rst:12
#: 93b49869f2d5464e840a0909f325c976
msgid "`Using naming convention`_."
msgstr ""

#: ../source/guides/creating-and-discovering-plugins.rst:13
#: 446be48311c449a3b673d0afbe63c8f1
msgid "`Using namespace packages`_."
msgstr ""

#: ../source/guides/creating-and-discovering-plugins.rst:14
#: 3ba23f3bb8634d8aa5d3c3d1cb29861d
msgid "`Using package metadata`_."
msgstr ""

#: ../source/guides/creating-and-discovering-plugins.rst:18
#: 662f0deb9f4c4f06b9a72e28f3b2e3ce
msgid "Using naming convention"
msgstr ""

#: ../source/guides/creating-and-discovering-plugins.rst:20
#: 97f33b7f1d2647ac873652397f841ea7
msgid "If all of the plugins for your application follow the same naming convention, you can use :func:`pkgutil.iter_modules` to discover all of the top-level modules that match the naming convention. For example, `Flask`_ uses the naming convention ``flask_{plugin_name}``. If you wanted to automatically discover all of the Flask plugins installed:"
msgstr ""

#: ../source/guides/creating-and-discovering-plugins.rst:38
#: 13964a2df6a942c294aea6040a05a85d
msgid "If you had both the `Flask-SQLAlchemy`_ and `Flask-Talisman`_ plugins installed then ``discovered_plugins`` would be:"
msgstr ""

#: ../source/guides/creating-and-discovering-plugins.rst:48
#: 1588d3f750e1490fa78aeff3863e6c71
msgid "Using naming convention for plugins also allows you to query the Python Package Index's `simple API`_ for all packages that conform to your naming convention."
msgstr ""

#: ../source/guides/creating-and-discovering-plugins.rst:59
#: 0152b117281446b580f3f3a2bf581dbc
msgid "Using namespace packages"
msgstr ""

#: ../source/guides/creating-and-discovering-plugins.rst:61
#: 4587d507336b49fb87ac842123ae1e6c
msgid ":doc:`Namespace packages <packaging-namespace-packages>` can be used to provide a convention for where to place plugins and also provides a way to perform discovery. For example, if you make the sub-package ``myapp.plugins`` a namespace package then other :term:`distributions <Distribution Package>` can provide modules and packages to that namespace. Once installed, you can use :func:`pkgutil.iter_modules` to discover all modules and packages installed under that namespace:"
msgstr ""

#: ../source/guides/creating-and-discovering-plugins.rst:89
#: 54ba49643108407797d84bff4db1fa19
msgid "Specifying ``myapp.plugins.__path__`` to :func:`~pkgutil.iter_modules` causes it to only look for the modules directly under that namespace. For example, if you have installed distributions that provide the modules ``myapp.plugins.a`` and ``myapp.plugins.b`` then ``discovered_plugins`` in this case would be:"
msgstr ""

#: ../source/guides/creating-and-discovering-plugins.rst:101
#: 7fc9c0b031f8442ca472867f8cf32f29
msgid "This sample uses a sub-package as the namespace package (``myapp.plugins``), but it's also possible to use a top-level package for this purpose (such as ``myapp_plugins``). How to pick the namespace to use is a matter of preference, but it's not recommended to make your project's main top-level package (``myapp`` in this case) a namespace package for the purpose of plugins, as one bad plugin could cause the entire namespace to break which would in turn make your project unimportable. For the \"namespace sub-package\" approach to work, the plugin packages must omit the :file:`__init__.py` for your top-level package directory (``myapp`` in this case) and include the namespace-package style :file:`__init__.py` in the namespace sub-package directory (``myapp/plugins``).  This also means that plugins will need to explicitly pass a list of packages to :func:`setup`'s ``packages`` argument instead of using :func:`setuptools.find_packages`."
msgstr ""

#: ../source/guides/creating-and-discovering-plugins.rst:115
#: e7bffbee773a4b249899f27283445419
msgid "Namespace packages are a complex feature and there are several different ways to create them. It's highly recommended to read the :doc:`packaging-namespace-packages` documentation and clearly document which approach is preferred for plugins to your project."
msgstr ""

#: ../source/guides/creating-and-discovering-plugins.rst:121
#: e1796d1293384dd1a1fcb11560f4a2c7
msgid "Using package metadata"
msgstr ""

#: ../source/guides/creating-and-discovering-plugins.rst:123
#: 43496dd1477d45c5bfbb7a79ab8402ba
msgid "`Setuptools`_ provides :doc:`special support <setuptools:userguide/entry_point>` for plugins. By providing the ``entry_points`` argument to :func:`setup` in :file:`setup.py` plugins can register themselves for discovery."
msgstr ""

#: ../source/guides/creating-and-discovering-plugins.rst:128
#: 3667c880cf314472a2fc1d0c27439fb7
msgid "For example if you have a package named ``myapp-plugin-a`` and it includes in its :file:`setup.py`:"
msgstr ""

#: ../source/guides/creating-and-discovering-plugins.rst:139
#: 1148fe39e3524d27b78f2debf9a0c85f
msgid "Then you can discover and load all of the registered entry points by using :func:`importlib.metadata.entry_points` (or the `backport`_ ``importlib_metadata >= 3.6`` for Python 3.6-3.9):"
msgstr ""

#: ../source/guides/creating-and-discovering-plugins.rst:154
#: 0ce7e813852b4b118348ac3b23689574
msgid "In this example, ``discovered_plugins`` would be a collection of type :class:`importlib.metadata.EntryPoint`:"
msgstr ""

#: ../source/guides/creating-and-discovering-plugins.rst:163
#: 3fb116bc1d0f4f6891aceaef6716b640
msgid "Now the module of your choice can be imported by executing ``discovered_plugins['a'].load()``."
msgstr ""

#: ../source/guides/creating-and-discovering-plugins.rst:166
#: 70d749cc065e45429dec50dd8150bd4e
msgid "The ``entry_point`` specification in :file:`setup.py` is fairly flexible and has a lot of options. It's recommended to read over the entire section on :doc:`entry points <setuptools:userguide/entry_point>` ."
msgstr ""

#: ../source/guides/creating-and-discovering-plugins.rst:170
#: 8bb8256382c14e2ba90260e90d50dd07
msgid "Since this specification is part of the :doc:`standard library <python:library/importlib.metadata>`, most packaging tools other than setuptools provide support for defining entry points."
msgstr ""
